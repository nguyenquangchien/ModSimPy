% LaTeX source for ``Modeling and Simulation in Python''
% Copyright 2017  Allen B. Downey.
% Bản tiếng Việt 2019-2023: Nguyễn Quang Chiến 

% License: Creative Commons Attribution-NonCommercial 4.0 Unported License.
% https://creativecommons.org/licenses/by-nc/4.0/
%

\documentclass[12pt]{book}

%%%% Both LATEX and PLASTEX

\usepackage{graphicx}
\usepackage{hevea}
\usepackage{makeidx}
\usepackage{setspace}
\usepackage{upquote}
\usepackage{xcolor}
\usepackage[listings]{tcolorbox}
\usepackage[utf8]{vietnam}

\title{Mô hình hoá và mô phỏng bằng Python}
\author{Allen B. Downey}

\newcommand{\thetitle}{Mô hình hoá và mô phỏng bằng Python}
\newcommand{\thesubtitle}{}
\newcommand{\theauthors}{Allen B. Downey}
\newcommand{\theversion}{2.3}


% to get siunitx
% sudo apt-get install texlive-science
\usepackage{siunitx}
\sisetup{per-mode=symbol}

\definecolor{light-gray}{gray}{0.95}

\newtcblisting{python}{
  skin=standard,
  boxrule=0.4pt,
  colback=light-gray,
  listing only,
  top=0pt,
  bottom=0pt,
  left=0pt,
  right=0pt,
  boxsep=2pt,
  listing options={
    basicstyle=\ttfamily,
    language=python,
    showstringspaces=false,
  },
}
 
\newtcblisting{result}{
  skin=standard,
  boxrule=0.0pt,
  colback=white,
  listing only,
  top=0pt,
  bottom=0pt,
  left=0pt,
  right=0pt,
  boxsep=2pt,
  listing options={
    basicstyle=\ttfamily,
    language=python,
    showstringspaces=false,
  },
}
 
\makeindex

% automatically index glossary terms
\newcommand{\term}[1]{%
\item[#1:]\index{#1}}

\usepackage{amsmath}
\usepackage{amsthm}

% format end of chapter excercises
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

\usepackage{afterpage}

\newcommand\blankpage{%
    \null
    \thispagestyle{empty}%
    \addtocounter{page}{-1}%
    \newpage}

\newif\ifplastex
\plastexfalse

%%%% PLASTEX ONLY
\ifplastex

\usepackage{localdef}

\usepackage{url}

\newcount\anchorcnt
\newcommand*{\Anchor}[1]{%
  \@bsphack%
    \Hy@GlobalStepCount\anchorcnt%
    \edef\@currentHref{anchor.\the\anchorcnt}%
    \Hy@raisedlink{\hyper@anchorstart{\@currentHref}\hyper@anchorend}%
    \M@gettitle{}\label{#1}%
    \@esphack%
}

% code listing environments:
% we don't need these for plastex because they get replaced
% by preprocess.py
%\newenvironment{code}{\begin{code}}{\end{code}}
%\newenvironment{stdout}{\begin{code}}{\end{code}}

% inline syntax formatting
\newcommand{\py}{\verb}%}

%%%% LATEX ONLY
\else

\input{latexonly}

\fi

%%%% END OF PREAMBLE
\begin{document}

\frontmatter

%%%% PLASTEX ONLY
\ifplastex

\maketitle

%%%% LATEX ONLY
\else

\begin{latexonly}

%-half title--------------------------------------------------
%\thispagestyle{empty}
%
%\begin{flushright}
%\vspace*{2.0in}
%
%\begin{spacing}{3}
%{\huge \thetitle}
%\end{spacing}
%
%\vspace{0.25in}
%
%Version \theversion
%
%\vfill
%
%\end{flushright}

%--verso------------------------------------------------------

%\afterpage{\blankpage}

%\newpage
%\newpage
%\clearemptydoublepage
%\pagebreak
%\thispagestyle{empty}
%\vspace*{6in}

%--title page--------------------------------------------------
\pagebreak
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

\begin{spacing}{3}
{\huge \thetitle}
\end{spacing}

\vspace{0.25in}

Phiên bản \theversion

\vspace{1in}


{\Large
\theauthors \\
}


\vspace{0.5in}

{\Large Green Tea Press (NXB)}

{\small Needham, Massachusetts, Hoa Kỳ}

%\includegraphics[width=1in]{figs/logo1.eps}
\vfill

\end{flushright}



%--bản quyền--------------------------------------------------
\pagebreak
\thispagestyle{empty}

Bản quyền \copyright ~2017 \theauthors.



\vspace{0.2in}

\begin{flushleft}
Green Tea Press (NXB)       \\
9 Washburn Ave \\
Needham MA 02492, Hoa Kỳ
\end{flushleft}

Cho phép sao chép, phân phối, truyền tin và chỉnh sửa tác phẩm này theo Giấy phép Quốc tế Creative Commons Attribution-NonCommercial-ShareAlike 4.0: \url{http://modsimpy.com/license}.

% TODO: đảm bảo URL vắn tắt hoạt động được với https

Nếu bạn quan tâm đến việc phân phối một phiên bản thương mại của tác phẩm này, hãy liên hệ với tác giả.

Mã nguồn \LaTeX\ và mã lệnh của cuốn sách này có sẵn ở

\begin{code}
https://github.com/AllenDowney/ModSimPy
\end{code}

Bản dịch tiếng Việt: Nguyễn Quang Chiến \url{nguyenquangchien@gmail.com}

Năm 2020-2021.

%--table of contents------------------------------------------

\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

\end{latexonly}


% trang tiêu đề HTML ------------------------------------------

\begin{htmlonly}

\vspace{1em}

{\Large \thetitle}

{\large \theauthors}

Version \theversion

\vspace{1em}

Copyright \copyright ~2017 \theauthors.

Cho phép sao chép, phân phối, truyền tin và chỉnh sửa tác phẩm này theo Giấy phép Quốc tế Creative Commons Attribution-NonCommercial-ShareAlike 4.0, vốn sẵn có ở \url{http://modsimpy.com/license}.

\vspace{1em}

\setcounter{chapter}{-1}

\end{htmlonly}

% END OF THE PART WE SKIP FOR PLASTEX
\fi

\chapter{Mở đầu}
\label{preface}


\section{Phương pháp mô hình hoá có thể dạy được không?}

Những kĩ năng thiết yếu của mô hình hoá --- trừu tượng hoá, phân tích, mô phỏng, và kiểm định --- luôn là then chốt trong ngành kĩ thuật, khoa học tự nhiên, khoa học xã hội, y tế, và nhiều ngành khác. Một số sinh viên ngầm học được những kĩ năng trên, nhưng đa số trường không dạy riêng những môn này, và sinh viên ít được thực tập. Đó là vấn đề mà cuốn sách này tập trung hướng đến.

Tại trường đại học Olin, chúng tôi sử dụng quyển sách này trong lớp học có tên `Modeling and Simulation' (Mô hình hoá và mô phỏng), trong đó các sinh viên đăng ký học trong năm thứ nhất. Những đồng nghiệp của tôi, John Geddes và Mark Somerville, cùng tôi đã lập nên lớp này và dạy nó vào năm đầu tiên là 2009.

Chúng tôi tin rằng việc mô hình hoá cần được giảng dạy quy củ, từ sớm, và trong suốt chương trình học. Chúng tôi cũng tin rằng tính toán là khâu thiết yếu trong quá trình này. 

Nếu sinh viên bị hạn chế trong phạm vi các phép toán tính được bằng tay, thì họ sẽ bị gò bó trong một nhóm ít các hệ thống tự nhiên đơn giản, kiểu như tên lửa chuyển động trong chân không hoặc một khối vật thể chuyển động trên mặt phẳng không ma sát.

Và họ chỉ làm việc với các mô hình tồi -- những mô hình quá đơn giản cho mục tiêu ban đầu của họ. Ở gần như mọi hệ thống cơ học, sức cản không khí và ma sát là những yếu tố thiết yếu; nếu ta bỏ qua chúng thì các dự đoán sẽ bị sai và những thiết kế của ta không hoạt động được.

Trong đa số các lớp vật lý cho sinh viên năm thứ nhất, người học không được ra quyết định về mô hình hoá; đôi khi họ còn không nhận thức được về những quyết định đã được làm hộ. Mục đích của tác giả là giảng dạy toàn bộ quá trình mô hình hoá và dành cho sinh viên cơ hội để thực tập quá trình này.


\section{Tôi cần phải lập trình bao nhiêu?}

Nếu bạn chưa từng lập trình thì bạn cũng có thể đọc hiểu quyển sách này, và làm các bài tập. Tôi sẽ cố gắng hết sức để giải thích mọi thứ bạn cần biết; cụ thể là tôi đã chọn kĩ từ vựng được giới thiệu, và đã cố gắng định nghĩa từng thuật ngữ được dùng lần đầu. Nếu bạn bắt gặp tôi đùng một thuật ngữ mà chưa định nghĩa nó, hãy báo tôi biết.

Nếu đã từng lập trình rồi, bạn sẽ khởi đầu dễ dàng hơn, nhưng đôi chỗ bạn có thể sẽ cảm thấy lúng túng. Tôi chọn cách tiếp cận lập trình mà có thể trước đây bạn chưa từng gặp.

Đa số các lớp lập trình\footnote{Gồm cả nhiều lớp mà tôi từng dạy.} có hai vấn đề lớn:

\begin{enumerate}

\item Lớp đi theo hướng ``từ dưới lên", nghĩa là khởi đầu bằng các yếu tố ngôn ngữ đơn giản và dần bổ sung các công cụ mạnh hơn. Kết quả là sẽ mất nhiều thời gian trước khi người học làm được điều gì đó ý nghĩa hơn là việc quy đổi từ thang nhiệt độ Fahrenheit sang độ C.

\index{từ dưới lên | bottom up}

\item Học mà không có bối cảnh. Người học lập trình mà trong suy nghĩ không có một định hướng cụ thể, bởi vậy, các bài tập rải rác khắp các chủ đề không có kết nối gì với nhau cả; và những bài tập này thường không có ``động cơ'' phát sinh.

\end{enumerate}

Trong cuốn sách này, bạn học lập trình với một mục tiêu ngay trong ý tưởng: đó là lập nên các mô phỏng cho các hệ vật lý. Và ta đi theo hướng ``từ trên xuống"; ý của tôi là ta sẽ dùng ngay những cấu trúc dữ liệu và yếu tố ngôn ngữ lập trình một cách chuyên nghiệp. Cụ thể, chúng ta sử dụng các {\bf thư viện} Python sau đây:

\index{từ trên xuống | top down}

\begin{itemize}

\item NumPy cho tính toán số cơ bản (xem \url{https://www.numpy.org/}).

\index{NumPy}

\item SciPy cho tính toán khoa học (xem \url{https://www.scipy.org/}).

\index{SciPy}

\item Matplotlib cho hiển thị (xem \url{https://matplotlib.org/}).

\index{Matplotlib}

\item Pandas để làm việc với dữ liệu (xem  url{https://pandas.pydata.org/}).

\index{Pandas}

\item SymPy cho tính toán với biểu tượng, (xem \url{https://www.sympy.org}).

\index{SymPy}

\item Pint để tính cho các đơn vị như kg hay mét (xem \url{https://pint.readthedocs.io}).

\index{Pint}

\item Jupyter để đọc, chạy, và phát triển mã lệnh (xem \url{https://jupyter.org}).

\index{Jupyter}

\end{itemize}

Những công cụ này cho phép bạn sớm làm việc với các bài toán thú vị, nhưng cũng có những hạn chế: chúng có thể khó sử dụng, và có thể rất khó theo dõi xem thư viện nào làm công việc gì và các thư viện tương tác như thế nào.

Tôi đã cố gắng giảm thiểu những vấn đề này bằng cách cung cấp một thư viện có tên \py{modsim}, để bạn dễ làm quen những công cụ lập trình nêu trên, và cung cấp thêm một số tính năng khác nữa.

\index{modsim (thư viện)}

Vài yếu tố trong thư viện \py{modsim} giống như các bánh xe tập; đến một lúc nào đó bạn sẽ không dùng đến chúng nữa và bắt đầu làm việc trực tiếp với các thư viện bên trong. Những yếu tố khác, bạn có thể sẽ thấy hữu ích xuyên suốt quyển sách.

Tôi khuyến khích bạn đọc mã lệnh thư viện \py{modsim}. Hầu hết chúng không phức tạp gì, và tôi đã cố gắng viết chúng để dễ đọc. Đặc biệt, nếu bạn đã có kinh nghiệm lập trình rồi, bạn có thể học thêm vài điều bằng cách dùng kỹ nghệ đảo ngược phân tích khâu thiết kế của tôi.


\section{Tôi cần bao nhiêu kiến thức toán và khoa học?} 

Tôi sẽ coi như bạn đã biết về đạo hàm và tích phân, và chỉ cần thế thôi. Cụ thể hơn, bạn không cần biết (hoặc nhớ) nhiều quy tắc lấy đạo hàm và tích phân như trong môn giải tích. Nếu bạn biết đạo hàm của $x^2$ và lấy tích phân của $2x~dx$, vậy là tốt rồi\footnote{Và nếu nhận ra được là câu hỏi này là đáp án cho câu hỏi kia thì càng tốt.}.  Điều quan trọng là bạn hiểu được {\em ý nghĩa} của những khái niệm đạo hàm và tích phân; nếu chưa hiểu, quyển sách này sẽ giúp bạn hình dung được.

\index{giải tích}

Bạn không cần biết gì về các phương trình vi phân.

Về mặt khoa học, chúng ta sẽ đi qua rất nhiều lĩnh vực bao gồm dân số, dịch bệnh, y tế, nhiệt động lực học, và cơ học. Đa phần, tôi không yêu cầu bạn phải biết gì về những môn học trên. Thật ra, một trong những kĩ năng mà bạn cần để mô hình hóa là khả năng học được những lĩnh vực mới, ở mức đủ để phát triển các mô hình và mô phỏng.

Khi đến lĩnh vực cơ học, tôi như bạn đã hiểu được mối liên hệ giữa vị trí, vận tốc, gia tốc, và bạn nắm được các định luật Newton vè chuyển động, đặc biệt là định luật thứ hai, vốn thường được biểu diễn theo dạng $F = ma$ (lực bằng tích khối lượng với gia tốc).

\index{khoa học}
\index{cơ học}

Tôi nghĩ rằng đó là tất cả mọi thứ bạn cần biết; nhưng nếu bạn thấy có điểm gì tôi bỏ quên mất thì hãy cho tôi biết.


\section{Bắt đầu vào cuộc}
\label{code}

Để chạy được các ví dụ và thao tác được những bài tập trong cuốn sách này, bạn cần phải:

\begin{enumerate}

\item Cài đặt Python lên máy tính, cùng với các thư viện ta sẽ sử dụng.

\item Sao chép các file của tôi lên máy tính của bạn.

\item Chạy Jupyter, vốn là một công cụ dùng để chạy và viết các chương trình, rồi tải một {\bf notebook}, vốn là một file có chứa mã lệnh và văn bản.

\end{enumerate}

Ba mục tiếp theo sẽ trình bày chi tiết của các bước trên. Tôi mong rằng có một cách dễ dàng hơn để nhập cuộc; thật tiếc là bạn phải thao tác khá nhiều trước khi viết nên chương trình đầu tiên của mình. Hãy kiên nhẫn!


\section{Cài đặt Python}

Bạn có thể đã cài sẵn Python lên máy tính của mình, nhưng bạn có thể không có được phiên bản mới nhất. Để dùng được mã lệnh trong cuốn sách này, bạn cần đến Python 3.6 hoặc mới hơn. Ngay cả khi bạn có phiên bản mới nhất nhưng có thể bạn vẫn chưa có đầy đủ thư viện mà chúng ta cần.

\index{cài đặt Python}

Bạn có thể cập nhật Python và cài những thư viện đó, nhưng tôi thật sự khuyên bạn đừng làm vậy. Theo tôi bạn sẽ dễ dàng hơn nhiều khi dùng {\bf Anaconda}, vốn là một phiên bản Python tự do, trong đó chứa tất cả các thư viện cần cho cuốn sách này (và kể cả thư viện khác nữa).

\index{Anaconda}

Anaconda có sẵn cho các hệ điều hành Linux, macOS, và Windows.  Mặc định là nó sẽ đặt tất cả các file trong thư mục cá nhân (home) của bạn, bởi vậy bạn sẽ không cần quyền quản trị (admin hay root) để cài nó. Và nếu bạn đã có cài một phiên bản Python rồi, thì Anaconda sẽ không gỡ bỏ hay chỉnh sửa gì nó cả.

Hãy bắt đầu từ \url{https://www.anaconda.com/download}.  Tải về bộ cài cho hệ điều hành của bạn và chạy nó. Bạn không cần quyền admin để cài Anaconda, vì vậy tôi khuyên bạn cài đặt với vai trò người dùng thông thường chứ không phải admin (hay root).

Tôi đề nghị bạn chấp nhận các lựa chọn mặc định khi cài đặt. Trong Windớ, bạn được lựa chọn cài Visual Studio Code hay không. Đây là một môi trường tương tác để viết các chương trình. Bạn không cần nó trong khuôn khổ cuốn sách này, nhưng có thể vẫn muốn dùng cho các dự án khác. 

Theo mặc định, Anaconda sẽ cài đặt hầu hết các gói mà bạn cần, nhưng vẫn còn một vài gói mà bạn có thể phải bổ sung. Một khi việc cài đặt đã hoàn thành, bạn hãy mở một cửa sổ dòng lệnh. Nếu dùng macOS hoặc Linux, bạn có thể dùng Terminal.  Đối với Windows, hãy mở Anaconda Prompt vốn sẽ xuất hiện trong Start menu.

Chạy dòng lệnh sau (hoặc nếu có thể thì copy và paste nó, để tránh lỗi gõ phím):

\begin{code}
conda install jupyterlab pandas seaborn sympy beautifulsoup4 lxml
\end{code}

Trong số trên có thể một vài gói đã được cài rối. Sau cùng, chạy lệnh này:

\begin{code}
conda install -c unidata pint
\end{code}

Đó sẽ là tất cả những gì bạn cần đến.


\section{Copy các file của tôi}

Mã lệnh của cuốn sách này có thể lấy về từ 
\url{https://github.com/AllenDowney/ModSimPy}, vốn là một {\bf Git repository}.  Git là một công cụ phần mềm giúp bạn theo dõi các chương trình cùng những file khác tạo nên một dự án. Một tập hợp các file dưới sự kiểm soát của Git thì được gọi là một repository (với tên gọi thân quen là ``repo").  GitHub là một dịch vụ hosting cung cấp dung lượng lưu trữ các Git repository cùng với một giao diện web tiện lợi.

\index{repository}
\index{Git}
\index{GitHub}

Trước khi bạn tải về những file này, tôi khuyên bạn sao chép repository của tôi ở GitHub, có tên là {\bf forking}.  Nếu chưa có sẵn tài khoản GitHub, bạn sẽ cần phải tạo một cái.  
Dùng một trình duyệt để xem trang chủ của repository của tôi tại \url{https://github.com/AllenDowney/ModSimPy}.   Bạn sẽ thấy một nút màu xám ở góc bên phải phía trên, ghi chữ {\sf Fork}.  Nếu ấn vào nó, GitHub sẽ tạo ra một bản sao cho repository của tôi nhưng thuộc về bạn.

Bây giờ, cách tốt nhất để tải các file về là dùng một {\bf Git client}, vốn là một chương trình để quản lý các git repository.  Bạn có thể nhận những hướng dẫn cài đặt vào Windows, macOS, và Linux tại \url{http://modsimpy.com/getgit}. 

Trên nền Windows, tôi đề nghị bạn chấp nhận các tùy chọn mà trình cài đặt đã gợi ý, nhưng có hai ngoại lệ sau:

\begin{itemize}

\item Về trình biên tập mặc định, hãy chọn \py{nano} thay vì \py{vim}.

\item Ở ``Configuring line ending conversions", chọn ``Check out as is, commit as is".

\end{itemize}

Đối với macOS và Linux, tôi khuyên bạn chấp nhận tất cả tùy chọn được gợi ý.

Một khi việc cài đặt thành công, hãy mở một cửa sổ dòng lệnh. Trên Windows, hãy mở Git Bash, vốn sẽ xuất hiện trong Start menu của bạn.  Trên macOS hoặc Linux, bạn có thể dùng Terminal.  

Để biết hiện bạn đang ở thư mục nào, hãy gõ \py{pwd}, vốn là chữ viết tắt của ``print working directory".  Trên nền Windows, có nhiều khả năng là bạn ở \py{Users\\yourusername}.  Với MacOS hoặc Linux, có thể bạn đang ở thư mục home của mình, \py{/home/yourusername}.  

Bước tiếp theo là copy các file từ repository của bạn trên GitHub về máy tính; theo thuật ngữ Git, quá trình này được gọi là {\bf clone}.  Hãy chạy lệnh sau:

\begin{python}
git clone https://github.com/YourGitHubUserName/ModSimPy
\end{python}

Dĩ nhiên, bạn phải thay thế \py{YourGitHubUserName} bằng tên người dùng GitHub của bạn. Sau khi clone xong, bạn sẽ có một thư mục mới tên là \py{ModSimPy}.

Nếu bạn không muốn dùng Git, bạn có thể tải về các file của tôi dưới dạng nén Zip từ  \url{http://modsimpy.com/zip}.  Bạn sẽ cần có một chương trình như WinZip hoặc gzip để giải nén file Zip này.  Hãy ghi lại chỗ mà bạn vừa tải các file về.


\section{Chạy Jupyter}

Mã lệnh cho từng chương, và mã lệnh bắt đầu cho các bài tập, đều ở dạng tập Jupyter (Jupyter notebook). Nếu bạn chưa từng sử dụng Jupyter before, bạn có thể đọc về nó ở \url{https://jupyter.org}.

\index{Jupyter}

Để khởi động Jupyter trên nền macOS hoặc Linux, hãy mở một Terminal; còn trên Windows, mở Git Bash. Dùng lệnh \py{cd} để chuyển vào thư mục có chứa mã lệnh của repository:

\begin{code}
cd ModSimPy/code
\end{code}

Sau đó hãy khởi động server tập Jupyter:

\begin{code}
jupyter notebook
\end{code}

Lúc này Jupyter mở một cửa sổ trình duyệt, và bạn thấy một danh sách các tập (notebook) trong repository của tôi.  Kích chuột vào tập đầu tiên, \py{chap01.ipynb} rồi làm theo các chỉ đẫn để chạy vài ô (``cell'') đầu tiên. Lần đầu tiên bạn chạy một tập, có thể sẽ mất vài giây để khởi động, trong khi chờ một số file Python được khởi tạo. Sau đó, nó sẽ chạy nhanh hơn.

Hãy thoải mái đọc qua hết các notebook này, nhưng có thể chúng chưa có nhiều ý nghĩa trước khi bạn đọc Chương~\ref{chap01}.

Bạn cũng có thể bật Jupyter từ Start của Windows, thanh Dock trên macOS, hay Anaconda Navigator ở hệ điều hành bất kì. Nếu bạn làm vậy, Jupyter sẽ khởi động từ thư mục home của bạn hoặc từ một thư mục nào đó trong hệ thống file, khi này bạn phải di chuyển đến thư mục \py{ModSimPy}.


\section*{Danh sách người đóng góp}

Nếu bạn có gợi ý hoặc sửa chữa nào, hãy gửi về 
{\tt downey@allendowney.com}.  Hoặc nếu bạn là người dùng Git, hãy gửi tôi một yêu cầu ``pull''!

Nếu tôi thực hiện bất kì chỉnh sửa nào theo ý kiến phản hồi của bạn, tôi sẽ đề tên bạn vào danh sách người đóng góp, trừ phi bạn đề nghị tôi không làm vậy.
\index{contributors}

Nếu bạn bao gồm ít nhất là một phần câu văn trong sách mà có lỗi, thì sẽ tạo điều kiện để tôi tìm kiếm dễ dàng hơn. Còn nếu bạn chỉ ghi số trang hay số đề mục thì cũng tạm được nhưng không hay bằng. Xin cám ơn!

\begin{itemize}

\item Xin chân thành cảm ơn John Geddes và Mark Somerville về những cộng tác với tôi từ sớm để hình thành `Modeling and Simulation' (Mô hình hoá và Mô phỏng), lớp họp tại Olin College mà nội dung cuốn sách này dựa theo.

\item Bản thảo ban đầu của cuốn sách này hưởng lợi từ những cuộc đối thoại với các đồng nghiệp tuyệt vời của tôi tại trường Olin College, bao gồm John Geddes, Alison Wood, Chris Lee, và Jason Woodard.

\item Tôi cám ơn Lisa Downey và Jason Woodard đã chuyên tâm rà soát bản thảo cẩn thận.

\item Cám ơn Alessandra Ferzoco, Erhardt Graeff, Emily Tow, Kelsey Houston-Edwards, Linda Vanasupa, Matt Neal, Joanne Pratt, và Steve Matsumoto đã có những gợi ý hữu ích.

% ENDCONTRIB

\end{itemize}



\normalsize

\cleardoublepage

% TABLE OF CONTENTS
\begin{latexonly}

% \tableofcontents

\cleardoublepage

\end{latexonly}

% START THE BOOK
\mainmatter


\chapter{Mô hình hoá}
\label{chap01}

Cuốn sách này là về mô hình hoá và mô phỏng các hệ thống vật lý.
Sơ đồ sau đây cho thấy tôi có ý gì khi nhắc đến ``mô hình hoá'':

\index{modeling}

\vspace{0.2in}
\centerline{\includegraphics[height=3in]{figs/modeling_framework.pdf}}

Bắt đầu từ góc trái phía dưới, {\bf hệ thống} là sự vật có ở thế giới thực, mà ta quan tâm. Thông thường, nó là thứ phức tạp, vì vậy mà ta phải quyết định xem cần phải bỏ qua những chi tiết gì. Việc bỏ qua chi tiết được gọi là {\bf trừu tượng hoá}.

\index{hệ thống}

Kết quả của việc trừu tượng hoá là một {\bf mô hình}, vốn là hình thức mô tả cho hệ thống, ở đó chỉ gồm những yếu tố mà ta coi là thiết yếu. Một mô hình có thể được biểu diễn đưới hình thức các sơ đồ và phương trình, mà ta có thể dùng cho {\bf phân tích} toán học. Song nó cũng có thể được thực thi dưới dạng một chương trình máy tính, vốn có thể chạy những {\bf mô phỏng}.

\index{mô hình}
\index{trừu tượng hoá}
\index{phân tích}

Kết quả của phân tích và mô phỏng có thể là một {\bf dự đoán} về những gì mà hệ thống sẽ diễn ra, {\bf giải thích} tại sao nó biểu hiện như vậy, hoặc một  {\bf thiết kế} nhằm đạt được mục đích cụ thể.

\index{dự đoán}
\index{giải thích}
\index{thiết kế}

Chúng ta có thể {\bf kiểm định} các dự đoán và kiểm tra các thiết kế bằng cách tiến hành {\bf đo đạc} từ thế giới thực và đem so sánh {\bf dữ liệu} thu được với các kết quả từ phân tích và mô phỏng.

\index{kiểm định}
\index{dữ liệu}

Với bất kì hệ thống vật lý nào, đều có thể đưa ra nhiều mô hình; mỗi mô hình đưa vào hoặc loại trừ các yếu tố riêng, hoặc có những mức chi tiết khác nhau. Mục tiêu của quá trình mô hình hoá là tìm mô hình phù hợp nhất cho mục đích của nó (dự đoán, giải thích hoặc thiết kế).

\index{mô hình hoá lặp}

Đôi khi mô hình tốt nhất là mô hình chi tiết nhất. Nếu ta bao gồm thêm các yếu tố, mô hình sẽ chân thực hơn, và chúng ta đều trông đợi những dự đoán từ mô hình sẽ chính xác hơn.

\index{chủ nghĩa hiện thực}

Nhưng thường thì mô hình đơn giản lại tốt hơn. Nếu chúng ta chỉ bao gồm những yếu tố thiết yếu nhất và bỏ qua những yếu tố khác, ta sẽ có mô hình dễ thao tác hơn, và những lời giải thích thu được từ mô hình có thể rõ ràng hơn và có tính thuyết phục hơn.

\index{tính đơn giản}

Lấy ví dụ, giả sử có người hỏi bạn tại sao quỹ đạo Trái đất lại có dạng gần như đường elip. Nếu bạn mô hình hóa Trái đất và Mặt trời như những chất điểm (bỏ qua kích thước thực của chúng) rồi tính lực hấp dẫn giữa chúng bằng định luật vạn vật hấp dẫn, sau đó tính kết quả quỹ đạo bằng định luật chuyển động của Newton, thì bạn sẽ có thể cho thấy được kết quả là một đường elip.

\index{quỹ đạo}
\index{elip}

Dĩ nhiên, quỹ đạo thực của Trái đất không phải là một đường elip hoàn hảo, vì có lực hấp dẫn của Mặt trăng, sao Mộc, cùng các thiên thể khác trong hệ mặt trời; và vì định luật Newton về chuyển động chỉ là gần đúng (không xét đến các hiệu ứng tương đối).

\index{Newton}
\index{thuyết tương đối}

Nhưng bổ sung các yếu tố trên đây vào mô hình chẳng thể cải thiện được lời giải thích; thêm các chi tiết chỉ gây nhiễu quanh nguyên nhân cơ bản. Tuy vậy, nếu mục đích là nhằm dự đoán vị trí Trái đất với độ chính xác cao, thì việc bổ sung thêm chi tiết có thể lại cần thiết. 

Việc chọn mô hình tốt nhất tuỳ thuộc vào mô hình để làm gì. Thường thì việc bắt đầu với mô hình đơn giản là một ý hay, ngay cả khi mô hình dường như quá đơn giản, và rồi thử xem mô hình có đủ tốt cho mục đích dự kiến chưa. Sau đó, bạn có thể dần bổ sung các yếu tố, bắt đầu từ yếu tố mà bạn nghĩ là thiết yếu nhất. Quy trình này được gọi là {\bf mô hình hoá lặp}.

Việc so sánh kết quả của các mô hình liên tiếp sẽ cho ta một dạng {\bf kiểm định bên trong}, nhờ vậy bạn có thể bắt các lỗi về khái niệm, toán học, và lập trình. Và qua việc bổ sung và lược bớt các yếu tố, bạn sẽ chỉ ra được yếu tố nào có ảnh hưởng lớn nhất đến kết quả, và yếu tố nào có thể bỏ qua được.

\index{kiểm định bên trong}
\index{kiểm định bên ngoài}

Việ có sánh kết quả với dữ liệu cung cấp từ hiện thực là hình thức {\bf kiểm định bên ngoài}, vốn thường là phép thử mạnh nhất.


\section{Chuyện hoang đường về đồng xu rơi}
\label{penny}

Hãy cùng xem một ví dụ về cách dùng mô hình như thế nào. Có thể bạn đã từng nghe về câu chuyện đồng xu được thả từ trên nóc nhà Empire State Building (Mỹ) sẽ rơi nhanh đến nỗi khi đập vào vỉa hè sẽ cắm sâu vào bê tông; hay nếu rơi trúng ai thì sẽ làm bể sọ.

\index{Empire State Building}
\index{đồng xu}
\index{chuyện hoang đường}

Ta có thể kiểm chứng câu chuyện này bằng cách thiết lập và phân tích một mô hình. Từ đầu, ta sẽ coi rằng ảnh hưởng của sức cản không khí là rất nhỏ. Sau này ta sẽ thấy giả thiết như vậy là rất dở, nhưng hãy kiên nhẫn đã.

Nếu như lực cản không khí là bỏ qua được thì lực cơ bản tác dụng lên đồng xu là trọng lực, vốn khiến cho đồng xu tăng tốc hướng xuống. 
\index{sức cản không khí}

Nếu như vận tốc ban đầu bằng 0, thì vận tốc sau $t$ giây là $a t$, và khoảng cách đồng xu đã rơi là:
%
\[ h = a t^2 / 2 \]
%
Ta có thể dùng đại số để giải ra $t$:
%
\[ t = \sqrt{ 2 h / a} \]
%
Lắp vào biểu thức gia tốc trọng trường, $a = \SI{9.8}{\meter\per\second\squared}$, và chiều cao toà nhà Empire State Building, $h=\SI{381}{\meter}$, ta có được $t = \SI{8.8}{\second}$.  Sau đó, tính $v = a t$ ta có vận tốc tiếp đất $\SI{86}{\meter\per\second}$, tức là 310 km/h.  Xem ra rơi trúng người sẽ nguy hiểm lắm đây.

Dĩ nhiên, những kết quả này đều không chính xác vì mô hình được lập nên dựa theo các sự giản hoá. Chẳng hạn, ta đã giả thiết rằng gia tốc trọng trường là một hằng số. Thực ra, trọng lực sẽ thay đổi ở những nơi khác nhau trên Trái đất, và trọng lực càng yếu hơn khi ta lên cao. Nhưng sự khác biệt này là quá nhỏ, bởi vậy bỏ qua điều đó có lẽ là lựa chọn hợp lý trong trường hợp này.
\index{trọng lực}

Mặt khác, việc bỏ qua sức cản không khí lại là một lựa chọn không hay. Một khi đồng xu đạt tốc độ khoảng \SI{18}{\meter\per\second}, lực cản không khí hướng lên trên sẽ cân bằng với trọng lực hướng xuống, vì vậy mà đồng xu sẽ không tiếp tục tăng tốc nữa. Từ đó trở đi, không phụ thuộc đồng xu sẽ rơi tiếp bao nhiêu nữa, nó sẽ đập vào vỉa hè (hay ai đó) với vận tốc khoảng \SI{18}{\meter\per\second}, nhỏ hơn nhiều so với trị số \SI{86}{\meter\per\second}, mà mô hình đơn giản đã ước tính ra.

Nhà thống kê học George Box có câu nói nổi tiếng ``Tất cả mô hình đều sai, nhưng một vài trong số đó lại hữu ích."  Dù ông đã nói về các mô hình thống kê, song câu nói đậm trí tuệ này áp dụng được cho mọi loại mô hình. Mô hình đầu tiên của chúng ta, vốn bỏ qua sức cản không khí, là rất sai, và có thể không hữu ích gì. Trong tập notebook của chương này, bạn sẽ thấy một mô hình khác, trong đó coi rằng gia tốc là một hằng số đến tận khi đồng xu đạt một vận tốc tới hạn. Mô hình này cũng vẫn sai, nhưng nó hay hơn, và đủ hợp lý để phản bác lại câu chuyện hoang đường kể trên.

\index{Box, George}

Chương trình TV {\it Mythbusters} đã kiểm tra câu chuyện hoang đường trên một cách cẩn thận hơn; bạn có thể xem kết quả tại \url{http://modsimpy.com/myth}.  Nghiên cứu của họ được dựa trên một mô hình toán học về chuyển động, các thí nghiệm đo đạc nhằm xác định lực cản của không khí lên đồng xu, và một mô hình vật lý mô phỏng đầu người.

\index{Mythbusters}


\section{Tính toán}
\label{computation}

Có (ít nhất là) hai cách làm việc với mô hình toán: {\bf phân tích} và {\bf mô phỏng}.  Phân tích thường gắn với phép tính đại số và biến đổi các biểu thức. Mô phỏng thường gắn với máy tính.
\index{phân tích}
\index{mô phỏng}

Trong cuốn sách này chúng ta phân tích một chút và mô phỏng rất nhiều; xuyên suốt nội dung tôi sẽ thảo luận cả ưu điểm lẫn nhược điểm của từng cách. Các công cụ cơ bản mà tôi dùng cho mô phỏng là ngôn ngữ lập trình Python và Jupyter, vốn là một môi trường để viết và chạy các chương trình.

Ví dụ đầu tiên, tôi sẽ cho bạn thấy tôi đã tính kết quả từ mục trước bằng Python như thế nào. 

Thứ nhất, tôi tạo ra một {\bf biến} để biểu diễn gia tốc.

\index{biến}
\index{giá trị}

\begin{python}
a = 9.8 * meter / second**2
\end{python}

Một biến là một tên tương ứng với một giá trị. Trong ví dụ này, cái tên đó là \py{a} và giá trị là con số \py{9.8} nhân với đơn vị \py{meter / second**2}.  Ví dụ này đã cho thấy một số kí hiệu mà Python sử dụng để thực hiện các phép toán:
\index{toán tử}

\begin{tabular}{l|c}
{\bf Phép toán} & {\bf Kí hiệu} \\ 
\hline 
Cộng & \py{+} \\ 
Trừ & \py{-} \\ 
Nhân & \py{*} \\ 
Chia & \py{/} \\ 
Luỹ thừa & \py{**}  \\ 
\end{tabular} 

Tiếp theo, ta có thể tính thời gian cần thiết để đồng xu rơi được  \SI{381}{\meter}, chiều cao của toà nhà Empire State Building.

\begin{python}
h = 381 * meter
t = sqrt(2 * h / a)
\end{python}

Các dòng này tạo ra thêm hai biến nữa: \py{h} nhận chiều cao của toàn nhà tính theo mét; \py{t} nhận thời gian, tính theo giây, để đồng xu rơi xuống vỉa hè.  \py{sqrt} là một {\bf hàm} để tính căn bậc hai. Python theo dõi đơn vị, và do đó, \py{t}, có đơn vị đúng, là giây.
\index{đơn vị}
\index{hàm}
\index{sqrt}

Cuối cùng, ta có thể tính vận tốc của đồng xu sau $t$ giây:

\begin{python}
v = a * t
\end{python}

Kết quả là khoảng \SI{86}{\meter\per\second}, một lần nữa với đơn vị đúng. 

Ví dụ này đã cho thấy các khâu phân tích và tính toán bằng Python.  Tiếp theo, ta sẽ thấy một ví dụ mô phỏng.

Trước khi bạn đọc tiếp, có thể bạn sẽ muốn xem tập notebook cho chương này, \py{chap01.ipynb}, và làm bài tập. Hướng dẫn tải về và chạy mã lệnh có ở Mục~\ref{code}.


\chapter{Dùng chung xe}
\label{chap02}

Chương này trình bày một mô hình đơn giản của hệ thống dùng chung xe đạp, đồng thời giới thiệu các đặc điểm Python mà ta sẽ dùng để phát triển các mô phỏng cho hệ thống ngoài đời thực.

Cũng trong quá trình đọc, bạn sẽ ra quyết định về cách mô phỏng hệ thống. Ở chương tiếp theo ta sẽ điểm lại những quyết định này và dần dần cải thiện mô hình.


\section{Mô hình hoá}
\label{modeling}

Hãy tưởng tượng một hệ thống dùng chung xe đạp cho các sinh viên đi lại giữa hai trường Olin College và Wellesley College; hai trường này cách nhau khoảng 3 dặm (5 km) trên miền Đông bang Massachusetts.

\index{Wellesley College}
\index{Olin College}

Coi rằng hệ thống có 12 xe đạp và hai dãy xe, một ở Olin và một ở Wellesley, mỗi dãy chứa được 12 xe.

\index{hệ thống dùng chung xe}

Khi các sinh viên tới nơi, để lấy xe và đạp đến trường kia, thì số xe ở mỗi nơi sẽ thay đổi. Trong mô phỏng này, chúng ta sẽ cần dõi theo các xe đang ở đâu. Để làm điều này, tôi sẽ tạo ra một đối tượng \py{State}, vốn được định nghĩa trong thư viện \py{modsim}.  

\index{State - đối tượng}

Trước khi ta có thể sử dụng thư viện này, ta phải nhập nó bằng lệnh \py{import}:

\begin{python}
from modsim import *
\end{python}

Dòng lệnh này là một {\bf câu lệnh import} để bảo Python đọc file {\tt modsim.py} và làm các hàm mà nó định nghĩa trở nên sẵn có để dùng.

\index{import - câu lệnh}

Các hàm trong thư viện \py{modsim.py} bao gồm \py{sqrt}, mà ta đã dùng ở mục trước, và \py{State}, mà ta sẽ dùng ngay đây.  \py{State} tạo nên một đối tượng \py{State}, vốn là một tập hợp các {\bf biến trạng thái}.  

\index{biến trạng thái}

\begin{python}
bikeshare = State(olin=10, wellesley=2)
\end{python}

Các biến trạng thái, \py{olin} và \py{wellesley}, biểu diễn số xe đạp ở mỗi nơi. Các giá trị ban đầu là 10 và 2, thể hiện rằng có 10 xe tại Olin và 2 tại Wellesley.  Đối tượng \py{State} tạo bởi \py{State} được gán cho một biến mới có tên là \py{bikeshare}.

\index{chấm - toán tử}
\index{toán tử!chấm}

Chúng ta có thể đọc các biến bên trong một đối tượng \py{State} bằng cách dùng một {\bf toán tử chấm}, kiểu như sau:

\begin{python}
bikeshare.olin
\end{python}

Kết quả là trị số 10.  Tương tự, với:

\begin{python}
bikeshare.wellesley
\end{python}

kết quả là 2.  Nếu bạn quên mất trong đối tượng trạng thái có những biến gì, thì bạn chỉ cần gõ mỗi tên:

\begin{python}
bikeshare
\end{python}

Kết quả trông giống như một cái bảng gồm tên các biến cùng giá trị của chúng:

\begin{tabular}{lr}
 & {\bf \sf value} \\ 
\hline 
{\bf \sf olin} & 10 \\ 
{\bf \sf wellesley} & 2 \\ 
\end{tabular} 

Các biến trạng thái và giá trị của chúng hợp thành {\bf trạng thái } của hệ thống. Ta có thể cập nhật hệ thống bằng cách gán những giá trị mới cho các biến. Chẳng hạn, nếu một sinh viên đưa một xe từ Olin đến Wellesley, ta có thể hình dung ra những giá trị mới và gán chúng:

\index{state}

\begin{python}
bikeshare.olin = 9
bikeshare.wellesley = 3
\end{python}

Hoặc ta có thể dùng các {\bf toán tử cập nhật}, \py{-=} và \py{+=}, để trừ 1 từ \py{olin} và cộng 1 vào \py{wellesley}:

\index{cập nhật - toán tử}
\index{toán tử!cập nhật}

\begin{python}
bikeshare.olin -= 1
bikeshare.wellesley += 1
\end{python}

Kết quả thì như nhau dù làm theo cách nào, song cách thứ hai thì linh hoạt hơn.


\section{Định nghĩa hàm}

Đến giờ ta đã dùng các hàm đã được định nghĩa trong \py{modsim} và các thư viện khác. Tiếp theo ta sẽ định nghĩa các hàm ta tự lập ra.

\index{hàm}
\index{định nghĩa hàm}

Khi bạn viết chương trình trong Jupyter, thường bạn chỉ viết vài 
dòng lệnh là được, rồi kiểm tra để chắc chúng hoạt động theo dự tính,
sau đó sẽ dùng chúng để định nghĩa một hàm mới. Chẳng hạn,
những dòng lệnh sau để di chuyển xe từ Olin đến Wellesley:

\begin{python}
bikeshare.olin -= 1
bikeshare.wellesley += 1
\end{python}

Thay vì việc lặp lại mỗi lần di chuyển một xe, ta có thể định nghĩa một
hàm mới:

\begin{python}
def bike_to_wellesley():
    bikeshare.olin -= 1
    bikeshare.wellesley += 1
\end{python}

\py{def} là một từ đặc biệt trong Python để chỉ rằng ta đang định nghĩa một hàm mới. Tên hàm này là \py{bike_to_wellesley}.  Cặp ngoặc tròn trong đó để trống thể hiện rằng hàm này không cần thêm thông tin nào khi nó chạy. Dấu hai chấm thể hiện sự bắt đầu một 
{\bf khối lệnh}.
\index{def}
\index{khối lệnh}
\index{thân}
\index{thụt đầu dòng}

Hai dòng tiếp theo là phầm {\bf thân} của hàm. Chúng phải được thụt đầu dòng, theo quy định là thụt dòng 4 dấu cách.

Khi bạn định nghĩa một hàm, nó không có hiệu ứng tức thì nào. Phần thân của hàm không được chạy đến khi bạn {\bf gọi} hàm đó. Sau đây là cách gọi hàm này:
\index{gọi}

\begin{python}
bike_to_wellesley()
\end{python}

Khi bạn gọi hàm, nó chạy các câu lệnh trong phần thân, vốn cập nhật các biến của đối tượng {\tt bikeshare}; bạn có thể kiểm tra bằng cách hiển thị hoặc vẽ trạng thái mới.

Khi bạn gọi một hàm, bạn phải kèm theo cặp ngoặc tròn. Nếu bạn bỏ quên chúng, kiểu như sau:
\index{đối số}
\index{cặp ngoặc tròn}

\begin{python}
bike_to_wellesley
\end{python}

thì Python sẽ tra tìm tên của hàm và hiển thị:

\begin{python}
<function __main__.bike_to_wellesley>
\end{python}

Kết quả cho thấy rằng \py{bike_to_wellesley} là một hàm. Bạn không cần phải biết \py{__main__} nghĩa là gì, nhưng nếu bạn đọc thấy chữ gì kiểu như thế này, thì có thể bạn đã chiếu đến một hàm nhưng chưa thực sự gọi nó. Bởi vậy đừng quên cặp ngoặc tròn.

Cũng như \py{bike_to_wellesley}, ta có thể định nghĩa một hàm để di chuyển một xe đạp từ Wellesley đến Olin:

\begin{python}
def bike_to_olin():
    bikeshare.wellesley -= 1
    bikeshare.olin += 1
\end{python}

Và gọi nó như sau:

\begin{python}
bike_to_olin()
\end{python}

Một lợi ích của việc định nghĩa hàm là bạn có thể tránh việc gọi một cụm câu lệnh, và nhờ đó làm chương trình nhỏ gọn hơn. Một lợi ích khác là tên của ạn đặt cho hàm thì mô tả công dụng của nó, điều này khiến cho chương trình dễ đọc hơn.


\section{Câu lệnh print}

Khi bạn viết các chương trình phức tạp hơn, rất dễ mất dấu việc ban đang làm. Một trong những công cụ quan trọng nhất để gỡ lỗi là {\bf câu lệnh print}, vốn để hiển thị chữ trong quyển Jupyter.
\index{print - câu lệnh}
\index{câu lệnh!print}

Thông thường khi Jupyter chạy mã lệnh trong một ô (cell), nó hiển thị giá trị của dòng lệnh cuối cùng. Chẳng hạn, nếu bạn chạy:

\begin{python}
bikeshare.olin
bikeshare.wellesley
\end{python}

thì Jupyter chạy cả hai dòng lệnh, nhưng nó chỉ hiển thị giá trị của dòng thứ hai. Nếu bạn muốn hiển thị nhiều hơn một dòng, bạn có thể dùng câu lệnh print:

\begin{python}
print(bikeshare.olin)
print(bikeshare.wellesley)
\end{python}

\py{print} là một hàm, vì vậy nó nhận một đối số trong cặp ngoặc tròn. Nó cũng có thể nhận một dãy các  đối số phân tách bởi dấu phẩy, như sau:

\begin{python}
print(bikeshare.olin, bikeshare.wellesley)
\end{python}

Ở ví dụ này, hai giá trị sẽ xuất hiện trên một dòng, giữa chúng là một dấu cách.

Các lệnh print cũng hữu ích với chức năng gỡ lỗi. Chẳng hạn, ta có thể bổ sung một lệnh print vào \py{move_bike}, như sau:

\begin{python}
def bike_to_wellesley():
	print('Moving a bike to Wellesley')
    bikeshare.olin -= 1
    bikeshare.wellesley += 1
\end{python}

Mỗi lần ta gọi hàm này, nó sẽ hiển thị một dòng thông báo, vốn có thể giúp ta theo dõi được chương trình đang làm gì.

\index{chuỗi}

Đối số của lệnh \py{print} này là một {\bf chuỗi}, vốn là một dãy các chữ cái và kí hiệu đặt trong cặp dấu nháy.



\section{Câu lệnh if}

Thư viện \py{modsim} cung cấp một hàm có tên \py{flip}; nó nhận vào một đối số là một giá trị xác suất từ 0 đến 1:

\begin{python}
flip(0.7)
\end{python}

Kết quả là một trong hai giá trị: \py{True} với xác suất 0.7 hoặc \py{False} với xác suất 0.3.  Nếu bạn chạy hàm này 100 lần, bạn sẽ nhận được \py{True} khoảng 70 lần và \py{False} khoảng 30 lần. Nhưng kết quả đều là ngẫu nhiên và do vậy có thể khác với hai con số được trông đợi nêu trên.
\index{flip}
\index{True}
\index{False}

\py{True} và \py{False} là các giá trị đặc biệt được định nghĩa bởi Python. Chú ý rằng chúng không phải các chuỗi. Có sự khác nhau giữa \py{True}, vốn là giá trị đặc biệt, với \py{'True'}, vốn là một chuỗi.
\index{chuỗi}
\index{kiểu boole}

\py{True} và \py{False} được gọi là các giá trị {\bf kiểu boole} vì chúng có liên hệ với môn đại số Boole (\url{http://modsimpy.com/boolean}).

Ta có thể dùng các giá trị boole để kiểm soát hành vi của chương trình, bằng một {\bf câu lệnh if}:
\index{if - câu lệnh}
\index{câu lệnh!if}

\begin{python}
if flip(0.5):
    print('heads')
\end{python}

Nếu kết quả từ \py{flip} là \py{True}, chương trình sẽ hiển thị chuỗi \py{'heads'}.  Ngược lại, nó sẽ không làm gì cả.

Cách chấm câu lệnh if cũng giống như ở lời định nghĩa hàm: dòng đầu tiên phải được kết thúc bởi dấu hai chấm, còn các dòng bên trong lệnh if phải được thụt đầu dòng. 
\index{thụt đầu dòng}
\index{else - vế câu lệnh}

Bạn có quyền lựa chọn bổ sung một {\bf vế lệnh else} để quy định điều gì sẽ xảy ra nếu kết quả là \py{False}:

\begin{python}
if flip(0.5):
    print('heads')
else:
    print('tails')    
\end{python}

Bây giờ ta có thể dùng \py{flip} để mô phỏng sự xuất hiện của những sinh viên muốn mượn xe đạp. Coi rằng sinh viên đến trạm Olin trung bình 2 phút một lượt. Trong trường hợp này, xác suất để có sinh viên đến trong mỗi thời đoạn từng phút là 50\%, và ta có thể mô phỏng như sau:

\begin{python}
if flip(0.5):
    bike_to_wellesley()
\end{python}

Nếu các sinh viên đến trạm Wellesley trung bình là 3 phút một lượt, thì xác suất để có sinh viên đến trong mỗi thời đoạn từng phút là 33\%, và ta có thể mô phỏng như sau:

\begin{python}
if flip(0.33):
    bike_to_olin()
\end{python}

Ta có thể kết hợp những đoạn lệnh này vào một hàm để mô phỏng một {\bf bước thời gian}, hay là một thời khoảng, ở đây là một phút:

\index{bước thời gian}

\begin{python}
def step():
    if flip(0.5):
        bike_to_wellesley()
    
    if flip(0.33):
        bike_to_olin()
\end{python}

Khi đó ta có thể mô phỏng một bước thời gian như sau:

\begin{python}
step()
\end{python}



\section{Tham số}

Phiên bản trước của hàm \py{step} là phù hợp nếu như xác suất sinh viên đến là không đổi, nhưng trong thực tế, những xác suất này có thay đổi theo thời gian.

Bởi vậy thay vì đặt các hằng số 0.5 và 0.33 vào \py{step}, ta có thể thay chúng bằng các {\bf tham số}.  Tham số là các biến số mà giá trị của chúng được gán khi một hàm được gọi.

Sau đây là một phiên bản của \py{step} nhận vào hai tham số, \py{p1} và \py{p2}:

\index{xác suất}

\begin{python}
def step(p1, p2):
    if flip(p1):
        bike_to_wellesley()
    
    if flip(p2):
        bike_to_olin()
\end{python}

Các giá trị \py{p1} và \py{p2} không được đặt trong hàm này; mà sẽ được cung cấp khi hàm được gọi, như sau:

\begin{python}
step(0.5, 0.33)
\end{python}

Các giá trị mà bạn cung cấp khi gọi hàm thì là các {\bf đối số}.
Các đối số, \py{0.5} và \py{0.33}, được gán cho các tham số, lần lượt là \py{p1} và \py{p2}. Bởi vậy việc chạy hàm này sẽ có hiệu quả tương tự như:

\begin{python}
p1 = 0.5
p2 = 0.33

if flip(p1):
    bike_to_wellesley()
    
if flip(p2):
    bike_to_olin()
\end{python}

Lợi ích của việc dùng tham số là bạn có thể gọi cùng một hàm nhiều lần, mỗi lần lại cung cấp các đối số khác nhau. Việc bổ sung các tham số vào cho một hàm được gọi là sự {\bf khái quát hóa}, vì nó làm cho hàm tổng quát hơn, hay bớt cụ thể đi.

\index{khái quát hóa}


\section{Vòng lặp for}
\label{forloop}

Đến một lúc nào đó bạn sẽ chán ngấy việc chạy đi chạy lại một ô nhiều lần. Thật may là có một cách đơn giản để lặp lại một đoạn lệnh, đó là dùng {\bf vòng lặp for}.  Sau đây là một ví dụ:
\index{for - vòng lặp}
\index{vòng lặp}

\begin{python}
for i in range(4):
    bike_to_wellesley()
\end{python}

Cách chấm câu lệnh ở đây cũng quen thuộc: dòng đầu tiên kết thúc bởi dấu hai chấm, và các dòng bên trong vòng lặp for thì được thụt đầu dòng. Các đặc điểm khác của vòng lặp for này bao gồm:
\index{range}

\begin{itemize}

\item \py{for} và \py{in} là những từ đặc biệt mà ta phải dùng trong một vòng lặp for.

\item \py{range} là một hàm Python mà ta dùng ở đây để ta kiểm soát số lần mà vòng lặp chạy.
\index{range}

\item \py{i} là một {\bf biến lặp} được tạo ra khi vòng lặp for chạy.
\index{biến lặp}

\end{itemize}

Trong ví dụ này, thực ra ta không dùng đến \py{i}; sau này ta sẽ thấy các ví dụ dùng đến biến lặp bên trong vòng lặp.

Khi vòng lặp này chạy, nó chạy những câu lệnh bên trong vòng lặp 4 lần, mỗi lần thực hiện chuyển một xe đạp từ Olin đến Wellesley.


\section{TimeSeries: chuỗi thời gian}
\label{timeseries}

Khi chạy một mô phỏng, ta thường muốn lưu kết quả để về sau phân tích. Thư viện \py{modsim} cung cấp một đối tượng \py{TimeSeries} (tạm gọi `chuỗi thời gian') nhằm mục đích này. \py{TimeSeries} chứa một dãy các mốc thời gian cùng một dãy các giá trị tương ứng. Trong ví dụ này, các mốc thời gian là những số nguyên biểu thị các phút, còn những giá trị là số xe đạp tại một địa điểm.

%TODO: index modsim library functions
\index{modsim - thư viện}
\index{TimeSeries}
\index{chuỗi thời gian}

Ta có thể tạo ra một \py{TimeSeries} trống, mới như sau:

\begin{python}
results = TimeSeries()
\end{python}

Và ta có thể thêm một giá trị vào \py{TimeSeries} như sau:

\begin{python}
results[0] = bikeshare.olin
\end{python}

Con số đặt giữa cặp ngoặc vuông là mốc thời gian, còn được gọi là một {\bf nhãn}.
\index{nhãn}

Ta có thể dùng một \py{TimeSeries} bên trong một vòng lặp for để lưu kết quả của mô phỏng:

\begin{python}
for i in range(10):
    step(0.3, 0.2)
    results[i] = bikeshare.olin
\end{python}

Mỗi lần duyệt qua vòng lặp, ta gọi \py{step}, vốn sẽ cập nhật \py{bikeshare}.  Sau đó, ta lưu số xe đạp ở Olin vào \py{results}.  Ta dùng biến lặp, \py{i}, làm mốc thời gian.

\index{lặp}
\index{biến lặp}
\index{mốc thời gian}

Khi vòng lặp thoát ra, \py{results} có chứa 10 bước thời gian, từ 0 đén 9, cùng số xe đạp ở Olin tại thời điểm cuối mỗi bước thời gian.
\index{biến lặp}

\py{TimeSeries} là một phiên bản riêng của \py{Series}, vốn được định nghĩa bởi Pandas, một trong những thư viện mà ta sẽ dùng đến rất nhiều. Đối tượng \py{Series} cung cấp nhiều hàm; một trong số đó là \py{mean}, mà ta sẽ gọi như sau đây:

\begin{python}
results.mean()
\end{python}

Bạn có thể đọc tài liệu hướng dẫn về \py{Series} tại \url{http://modsimpy.com/series}.

\index{Pandas}
\index{Series}
\index{TimeSeries}
\index{chuỗi thời gian}
\index{mean}
\index{trung bình}


\section{Vẽ đồ thị}
\label{plotting}

Thư viện \py{modsim} cung cấp một hàm có tên \py{plot} dùng để vẽ đồ thị kết quả (\py{results}):

\begin{python}
plot(results)
\end{python}

\py{plot} có thể nhận vào thêm một đối số nữa chứa nhãn hiệu cho đường đồ thị; nhãn hiệu này sẽ được ghi ở ô chú giải (Legend) của biểu đồ, nếu ta cho phép tạo ô chú giải.

\begin{python}
plot(results, label='Olin')
\end{python}

\py{label} là một ví dụ về {\bf đối số từ khóa}, so called because we provide a ``keyword'', which is \py{label} in this case, along with its value.  Arguments without keywords are called {\bf positional arguments} because they are assigned to parameters according to their position.  It is good to know these terms because they appear in Python error messages.

\index{đối số từ khóa}
\index{đối số vị trí}
\index{đối số}

Mỗi khi bạn tạo một hình biểu đồ, bạn nên đề tên các trục.  Thư viện \py{modsim} cung cấp \py{decorate}, có chức năng đề tên các trục và cho biểu đồ một tiêu đề cũng như dành ra một ô chú giải:

\begin{python}
decorate(title='Olin-Wellesley Bikeshare',
         xlabel='Time step (min)', 
         ylabel='Number of bikes')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap01-fig01.pdf}}
\caption{Kết quả mô phỏng một hệ thống dùng chung xe tại Olin theo thời gian.}
\label{chap01-fig01}
\end{figure}

Hình~\ref{chap01-fig01} cho thấy kết quả.

\py{plot} và \py{decorate} đều được dựa trên Pyplot, vốn là một thư viện Python để tạo ra các hình biểu đồ. Bạn có thể đọc thêm về \py{plot} cùng các đối số mà nó nhận tại \url{http://modsimpy.com/plot}.

\index{Pyplot}
\index{plot}
\index{đồ thị}
\index{decorate}

Trước khi đọc tiếp, bạn có thể muốn xem các quyển tập lệnh trong chương này, \py{chap02.ipynb}, và làm các bài tập. Hãy xem hướng dẫn tải về và chạy mã lệnh ở Mục~\ref{code}.



\chapter{Mô hình hóa lặp}
\label{chap03}

Để nhắc lại lời của George Box và George Orwell, ``Mọi mô hình đều sai, nhưng một số mô hình thì sai nhiều hơn số khác."  Trong chương này, tôi cho thấy quá trình chúng tôi thực hiện để mô hình bớt sai đi.

\index{Box, George}
\index{Orwell, George}

Lấy một ví dụ, ta xem lại mô hình dùng chung xe từ chương trước, đánh giá ưu nhược điểm của nó, rồi dần dần cải thiện nó. Chúng tôi cũng sẽ xem các cách sử dụng mô hình và hiểu ứng xử của hệ thống cũng như đánh giá các thiết kế dự kiến để mô hình làm việc tốt hơn.

\index{dùng chung xe}


\section{Mô hình hóa lặp}

Mô hình hiện nay thật đơn giản, nhưng nó dựa trên các giả thiết phi thực tế. Trước khi đọc tiếp, bạn hãy dành một phút để điểm lại mô hình từ những chương trước. Mô hình được dựa trên các giả thiết gì? Hãy lập danh sách các điểm khiến cho mô hình trở nên phi thực tế, hay là giữa mô hình và thực tế có những khác biệt gì?

Sau đây là một số điểm khác biệt mà tôi đã lập trong danh sách của mình:

\begin{itemize}

\item Trong mô hình, mỗi sinh viên có thể đến vào một phút bất kì. Còn trong thực tế, xác suất này phụ thuộc vào thời gian trong ngày, ngày trong tuần, v.v.

\index{xác suất}

\item Mô hình không xét đến thời gian di chuyển giữa các trạm.

\item Mô hình không kiểm tra liệu xe đạp có sẵn hay không, bởi vậy nên có khả năng xảy ra số xe âm (như bạn có thể nhận thấy khi thực hiện mô phỏng).

\end{itemize}

Một vài quyết định mô hình hóa trong số này thì hay hơn cái khác. Chẳng hạn, giả thiết thứ nhất có thể hợp lý nếu như ta mô phỏng hệ thống trong khoảng thời gian ngắn như 1 giờ chẳng hạn.

Giả thiết thứ hai thì không thực tế cho lắm, nhưng có thể nó cũng không ảnh hưởng nhiều đến kết quả, tùy theo việc ta dùng mô hình cho mục đích gì.

\index{realism}

Mặt khác, giả thiết thứ ba có vẻ rắc rối, song có thể sửa được khá dễ dàng. Chúng ta sẽ giải quyết vấn đề trong mục ~\ref{negativebikes}.

Quá trình này, bắt đầu từ một mô hình đơn giản, nhận diện những vấn đề quan trọng nhất, rồi cải tiến dần dần, được gọi là {\bf mô hình hóa lặp}.

\index{mô hình hóa lặp}

Với bất kì một hệ thống thực nào, có rất nhiều mô hình khả dĩ, dựa trên các giả thiết và phép giản hóa khác nhau. Thường sẽ phải mất vài lần lặp mới thiết lập được một mô hình đủ tốt cho mục đích đề ra mà không phức tạp quá mức cần thiết.


\section{Nhiều hơn một đối tượng State}

Trước khi ta tiếp tục, tôi muốn sửa đổi vài chỗ mã lệnh từ chương trước. Đầu tiên, tôi sẽ khái quát hóa các hàm đã viêt ra, để chúng nhận một đối tượng \py{State} làm tham số. Sau đó, tôi sẽ làm mã lệnh dễ đọc hơn bằng việc bổ sung đoạn tài liệu chú thích.

\index{tham số}

Sau đây là một trong các hàm từ chương trước, hàm \py{bike_to_wellesley}:

\begin{python}
def bike_to_wellesley():
    bikeshare.olin -= 1
    bikeshare.wellesley += 1
\end{python}

Khi ta gọi hàm này, nó làm thay đổi \py{bikeshare}.  Miễn là khi chỉ có một đối tượng \py{State} duy nhất, mọi việc đều ổn. Nhưng nếu có nhiều hơn một hệ thống đi chung xe thì sao? Hoặc nếu ta muốn chạy mô phỏng thì sao?

Hàm này sẽ trở nên linh hoạt hơn nếu nó nhận một đối tượng \py{State} làm tham số. Sau đây là hàm đó khi có tham số:

\index{State - đối tượng}

\begin{python}
def bike_to_wellesley(state):
    state.olin -= 1
    state.wellesley += 1
\end{python}

Tên của tham số là \py{state} thay vì \py{bikeshare} như để ghi nhớ rằng giá trị của \py{state} có thể là bất kì đối tượng \py{State} nào, chứ không riêng gì \py{bikeshare}.

Phiên bản \py{bike_to_wellesley} này yêu cầu một tham số là đối tượng \py{State}, vì vậy ta phải cung cấp một tham số khi gọi đến hàm:

\begin{python}
bike_to_wellesley(bikeshare)
\end{python}

Một lần nữa, đối số mà ta cung cấp được gán cho tham số, vì vậy lời gọi hàm này có tác dụng giống như:

\begin{code}
state = bikeshare
state.olin -= 1
state.wellesley += 1
\end{code}

Bây giờ ta có thể tạo bao nhiêu đối tượng \py{State} tùy ý:

\begin{python}
bikeshare1 = State(olin=10, wellesley=2)
bikeshare2 = State(olin=2, wellesley=10)
\end{python}

Và rồi cập nhật chúng một cách độc lập:

\begin{python}
bike_to_wellesley(bikeshare1)
bike_to_wellesley(bikeshare2)
\end{python}

Sự thay đổi về \py{bikeshare1} không ảnh hưởng tới \py{bikeshare2}, và ngược lại. Bởi vậy, ta có thể mô phỏng các hệ thống dùng chung xe khác nhau, hoặc chạy nhiều mô phỏng cho cùng một hệ thống.


\section{Tài liệu chú thích mã lệnh}
\label{documentation}

Một vấn đề khác đối với mã lệnh mà ta viết đến giờ là ở chỗ nó không có {\bf tài liệu chú thích mã lệnh} (documentation).  Tài liệu chú thích là phần văn bản mà ta bổ sung vào chương trình để giúp các lập trình viên khác đọc và hiểu được. Nó không có ảnh hưởng gì đến chương trình khi chạy.

\index{tài liệu chú thích mã lệnh}
\index{documentation}
\index{docstring}
\index{chú thích}

Có hai hình thức tài liệu chú thích, đó là các {\bf docstring} và {\bf lời chú thích}.
Một docstring (= doc [tài liệu] + string [chuỗi]) là một chuỗi đặt trong cặp nháy 3 lần và xuất hiện ở đầu một hàm, như sau:

\begin{python}
def run_simulation(state, p1, p2, num_steps):
    """Mô phỏng theo số bước thời gian cho trước.
    
    state: đối tượng State 
    p1: xác suất một người từ Olin đến Wellesley
    p2: xác suất một người từ Wellesley đến Olin 
    num_steps: số các bước thời gian.
    """
    results = TimeSeries()    
    for i in range(num_steps):
        step(state, p1, p2)
        results[i] = state.olin
        
    plot(results, label='Olin')
\end{python}

Docstring thì tuân theo định dạng quy ước sau:

\begin{itemize}

\item Dòng đầu tiên là một câu đơn mô tả công dụng của hàm.

\item Các dòng tiếp theo giải thích mõi tham số là gì.

\end{itemize}

Một docstring của hàm thì cần bao gồm những thông tin mà người ta cần biết để {\em sử dụng} hàm này; nó không nên bao gồm những chi tiết về cách vận hành của hàm. Chuyện đó đã có những dòng chú thích lo liệu.

Một dòng chú thích là dòng chữ bắt đầu bởi dấu thăng, \py{#}. Nó thường xuất hiện bên trong một hàm để giải thích về điều mà không hiển nhiên rõ ràng khi người đọc xem mã lệnh chương trình.

\index{chú thích}
\index{dấu thăng}

Chẳng hạn, sau đây là một phiên bản của \py{bike_to_olin} với một docstring và một chú thích.

\begin{python}
def bike_to_olin(state):
	"""Chuyển một xe từ Wellesley tới Olin.
	
	state: đối tượng State 
	"""
	# Ta giảm một biến trạng thái và tăng biến còn lại,
	# vì vậy tổng số xe đạp là không đổi.
    state.wellesley -= 1
    state.olin += 1
\end{python}

Đến đây ta có nhiều tài liệu chú thích hơn cả mã lệnh, song điều này không hiếm gặp ở những hàm ngắn.

\section{Số xe đạp âm}
\label{negativebikes}

Những thay đổi mà ta thực hiện đến giờ đã cải thiện chất lượng mã lệnh, nhưng ta chưa hề làm gì để cải thiện chất lượng của mô hình. Bây giờ ta hãy làm điều này.

\index{chất lượng mã lệnh}

Hiện giờ mô phỏng không kiểm tra liệu khi có người đến thì còn xe hay không, bởi vậy mà tại một địa điểm số xe có thể âm. Điều này phi thực tế. Sau đây là một phiên bản cập nhật của hàm \py{bike_to_olin} đẻ khắc phục vấn đề:

\begin{python}
def bike_to_olin(state):
    if state.wellesley == 0:
        return
    state.wellesley -= 1
    state.olin += 1
\end{python}

Dòng đầu tiên kiểm tra xem liệu số xe đạp ở Wellesley liệu có bằng không.  Nếu vậy, nó sẽ dùng một {\bf câu lệnh return} (`trả lại'), khiến cho hàm kết thúc lập tức, mà không chạy các câu lệnh còn lại. Bởi vậy nếu không có xe ở Wellesley, ta sẽ ``trở lại" từ \py{bike_to_olin} mà không làm thay đổi trạng thái.

\index{return - câu lệnh}
\index{câu lệnh!return}

Ta có thể cập nhật \py{bike_to_wellesley} theo cách tương tự.


\section{Các toán tử so sánh}

Phiên bản của hàm \py{bike_to_olin} ở mục trước có dùng toán tử bằng, \py{==}, để so sánh hai giá trị và trả lại \py{True} nếu chúng bằng nhau, và \py{False} nếu không phải.

Rất dẽ nhầm lẫn toán tử bằng với toán tử gán, \py{=}, vốn để gán một giá trị vào một biến. Chẳng hạn, câu lệnh sau tạo ra một biến \py{x}, nếu nó chưa tồn tại, và cho nó giá trị là \py{5}.

\index{cân bằng}
\index{gán - toán tử}
\index{toán tử!gán}

\begin{python}
x = 5
\end{python}

Mặt khác, câu lệnh sau đây kiểm tra xem liệu \py{x} có bằng \py{5} và trả lại \py{True} hoặc \py{False}.  Nó không tạo ra \py{x} hoặc thay đổi giá trị biến này.

\begin{python}
x == 5
\end{python}

Bạn có thể sử dụng toán tử bằng trong một câu lệnh \py{if}, như sau:

\index{if - câu lệnh}
\index{câu lệnh!if}

\begin{python}
if x == 5:
    print('yes, x is 5')
\end{python}

Nếu bạn mắc lỗi và dùng dấu \py{=} trong một câu lệnh \py{if}, như thế này:

\begin{python}
if x = 5:
    print('yes, x is 5')
\end{python}

Đó là một {\bf lỗi cú pháp}, nghĩa là cấu trúc của chương trình không hợp lệ. Python sẽ in ra một dòng thông báo lỗi và chương trình sẽ không chạy.

\index{cú pháp - lỗi}
\index{lỗi!cú pháp}

Toán tử bằng là một trong số các {\bf toán tử so sánh}. Các toán tử khác bao gồm:

\index{so sánh - toán tử}
\index{toán tử!so sánh}

\begin{tabular}{l|c}
{\bf Toán tử} & {\bf Kí hiệu} \\ 
\hline 
Nhỏ hơn & \py{<} \\ 
Lớn hơn & \py{>} \\
Nhỏ hơn hoặc bằng & \py{<=}  \\ 
Lớn hơn hoặc bằng & \py{>=} \\ 
Bằng & \py{==} \\ 
Khác & \py{!=} \\ 
\end{tabular} 


\section{Metric: chỉ số đo lường}
\label{metrics}

Trở lại hệ thống dùng chung xe, đến giờ ta có thể mô phỏng ứng xử của hệ thống. Bởi vì việc có người đến lấy xe là chuyện ngẫu nhiên, nên trạng thái của hệ thống là khác nhau mỗi khi ta chạy một mô phỏng. Các mô hình kiểu này được gọi là {\bf ngẫu nhiên}. Còn các mô hình thực hiện cùng một điều mỗi khi chạy mô phỏng thì được gọi là {\bf tất định}.

\index{ngẫu nhiên}
\index{tất định}

Giả sử ta muốn dùng mô hình để dự đoán xem hệ thống dùng chung xe hoạt động tốt ra sao, hoặc để thiết kế một hệ thống làm việc tốt hơn. Trước hết, ta phải quyết định xem ``tốt ra sao" và ``tốt hơn" là như thế nào.

Từ quan điểm của người dùng, có thể ta muốn biết được xác suất để lấy được xe có sẵn. Từ quan điểm của người chủ sở hữu hệ thống, có thể ta muốn giảm thiểu số khách hàng không tìm được xe khi muốn dùng, hoặc muốn tối đa số xe được dùng đến. Những con số thống kê như vậy sẽ lượng hóa việc hệ thống vận hành tốt ra sao, và được gọi là các {\bf metric}.

\index{metric}

Một ví dụ đơn giản, hãy tính số người dùng không hài lòng. Sau đây là một phiên bản của hàm \py{bike_to_olin} để theo dõi số khách hàng đến một trạm mà không có xe:

\begin{python}
def bike_to_olin(state):
    if state.wellesley == 0:
        state.wellesley_empty += 1
        return
    state.wellesley -= 1
    state.olin += 1
\end{python}

Nếu khách hàng đến trạm Wellesley mà ở đó không có xe, thì hàm \py{bike_to_olin} sẽ cập nhật biến \py{wellesley_empty} vốn dùng để đếm số khách hàng không hài lòng.

Hàm này chỉ có tác dụng nếu ta khởi tạo \py{wellesley_empty} khi ta tạo ra đối tượng \py{State}, như sau:

\begin{python}
bikeshare = State(olin=10, wellesley=2, 
                  olin_empty=0, wellesley_empty=0)
\end{python}

Giả thiết rằng ta cập nhật \py{move_to_wellesley} theo cách tương tự, ta có thể chạy mô phỏng như sau (xem Mục~\ref{documentation}):

\begin{python}
run_simulation(bikeshare, 0.4, 0.2, 60)
\end{python}

Sau đó ta có thể kiểm tra các metric:

\begin{python}
print(bikeshare.olin_empty, bikeshare.wellesley_empty)
\end{python}

Bởi vì mô phỏng mang tính ngẫu nhiên, nên kết quả sẽ khác nhau giữa các lần chạy.

Trước khi đọc tiếp, tôi muốn bạn đọc qua những quyển mã lệnh cho chương này, \py{chap03.ipynb}, và làm các bài tập. Để biết cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


%%%%
\chapter{Quét tham số}
\label{chap04}

Ở chương trước ta đã định nghĩa các metric để lượng hoá hiệu năng của hệ thống dùng chung xe đạp. Ở chương này ta xem các metric đó phụ thuộc vào các tham số hệ thống, chẳng hạn mức độ khách đến trạm, là như thế nào.

Ta cũng sẽ thảo luận một chiến lược phát triển chương trình, gọi là phát triển tăng dần, để giúp bạn viết chương trình nhanh hơn và ít tốn thời gian gỡ lỗi.


\section{Các hàm trả lại giá trị}

Ta đã thấy vài hàm trả lại giá trị; chẳng hạn, khi bạn chạy \py{sqrt}, nó trả lại một số để bạn có thể gán vào biến.

\index{giá trị trả lại}

\begin{python}
t = sqrt(2 * h / a)
\end{python}

Khi bạn chạy \py{State}, nó trả lại một đối tượng \py{State} mới:
 
\begin{python}
bikeshare = State(olin=10, wellesley=2)
\end{python}

Không phải mọi hàm đều có giá trị trả lại. Chẳng hạn, khi bạn chạy \py{step}, nó cập nhật một đối tượng \py{State}, nhưng lại không trả lại giá trị nào.

Để viết một hàm trả lại giá trị, ta có thể dùng một dạng thứ hai của câu lệnh \py{return}, như sau:

\index{return - câu lệnh}
\index{câu lệnh!return}

\begin{python}
def add_five(x):
    return x + 5
\end{python}

\py{add_five} nhận vào một tham số, \py{x}, vốn có thể là bất kì số nào. Nó tính ra \py{x + 5} rồi trả lại kết quả. Như vậy, nếu ta chạy như dưới đây, kết quả sẽ là \py{8}:

\begin{python}
add_five(3)
\end{python}

Tiếp theo là ví dụ hữu ích hơn; đây là một phiên bản của hàm \py{run_simulation} có tạo nên một đối tượng \py{State}, chạy một mô phỏng, và sau đó trả lại kết quả là một đối tượng \py{State}:

\begin{python}
def run_simulation():
    p1 = 0.4
    p2 = 0.2
    num_steps = 60
    
    state = State(olin=10, wellesley=2, 
                    olin_empty=0, wellesley_empty=0)
                    
    for i in range(num_steps):
        step(state, p1, p2)
        
    return state
\end{python}

Nếu ta gọi \py{run_simulation} như sau:

\begin{python}
state = run_simulation()
\end{python}

Nó gán đối tượng \py{State} từ \py{run_simulation} đến \py{state}, vốn chứa các metric mà ta quan tâm:

\begin{python}
print(state.olin_empty, state.wellesley_empty)
\end{python}


\section{Hai loại tham số}

Phiên bản này của hàm \py{run_simulation} luôn khởi động với cùng một điều kiện ban đầu: đó là 10 xe đạp tại Olin và 2 xe tại Wellesley, và các giá trị bằng nhau của \py{p1}, \py{p2}, và \py{num_steps}.  Gộp lại, có 5 giá trị {\bf tham số của mô hình}; đó là những giá trị quy định nên động thái của hệ thống.

\index{tham số!của mô hình}
\index{tham số!của hàm}

Rất dễ nhầm các tham số của mô hình với tham số của một hàm. Chúng có khái niệm liên quan mật thiết với nhau. Thực ra, thường thì các tham số mô hình cũng xuất hiện như các tham số của hàm. Chẳng hạn, ta có thể viết một phiên bản khác, tổng quát hơn cho \py{run_simulation} mà nhận vào \py{p1} và \py{p2} như các tham số hàm:

\begin{python}
def run_simulation(p1, p2, num_steps):
    state = State(olin=10, wellesley=2, 
                    olin_empty=0, wellesley_empty=0)
                    
    for i in range(num_steps):
        step(state, p1, p2)
        
    return state
\end{python}

Bây giờ ta có thể chạy nó với các mức độ người đến khác nhau, như thế này:

\begin{python}
state = run_simulation(0.6, 0.3, 60)
\end{python}

Ở ví dụ này, \py{0.6} được gán cho \py{p1}, \py{0.3} gán cho \py{p2}, và \py{60} gán cho \py{num_steps}.

Bây giờ ta có thể gọi \py{run_simulation} với các tham số khác nhau và xem các metric, như số khách không vui, sẽ phụ thuộc vào tham số ra sao. Song trước khi làm vậy, ta cần một phiên bản mới với vòng lặp \py{for}.

\index{metric}


\section{Vòng lặp và mảng}
\label{array}

Ở Mục~\ref{forloop}, ta đã thấy một vòng lặp như thế này:

\begin{python}
for i in range(4):
    bike_to_wellesley()
\end{python}

\py{range(4)} tạo ra một dãy số từ 0 đến 3. Mỗi khi qua vòng lặp, số tiếp theo trong dãy được gán cho biến vòng lặp, \py{i}.

\index{vòng lặp}
\index{vòng lặp!biến}
\index{biến!vòng lặp}

\py{range} chỉ làm việc với số nguyên; để thu được các giá trị số không nguyên, ta có thể dùng \py{linspace}, vốn được định nghĩa trong thư viện \py{modsim}: 

\begin{python}
p1_array = linspace(0, 1, 5)
\end{python}

Các đối số chỉ định dãy sẽ bắt đầu từ đâu và kêết thúc ở đâu, đồng thời nó có bao nhiêu phần tử. Trong ví dụ này, chuỗi có chứa \py{5} số cách đều nhau, bắt đầu từ \py{0} và  kết thúc ở \py{1}. 

\index{linspace}
\index{NumPy}
\index{mảng}

Kết quả là một {\bf mảng} Numpy, vốn là một kiểu đối tượng mới mà ta chưa từng thấy. Một  mảng là thứ dùng để chứa một dãy số.

Ta có thể dùng mảng trong một vòng lặp  \py{for}  như sau:

\begin{python}
for p1 in p1_array:
    print(p1)
\end{python}

Khi vòng lặp này chạy, nó 

\begin{enumerate}

\item Lấy phần tử đầu trong mảng và  gán nó với \py{p1}.

\item Chạy vòng thân vòng lặp, vốn là để in ra \py{p1}.

\item Lấy phần tử tiếp theo từ mảng và gán nó cho \py{p1}.

\item Chạy vòng thân vòng lặp, vốn là để in ra \py{p1}.

\end{enumerate}

Và cứ như vậy cho đến hết mảng. Kết quả là: 

\begin{result}
0.0
0.25
0.5
0.75
1.0
\end{result}

Cách này sẽ trở nên tiện dụng trong mục kế tiếp đây.


\section{Quét tham số}

Nếu ta biết các giá trị thực của tham số kiểu như \py{p1} và \py{p2}, ta có thể dùng chúng để dự đoán cụ thể, chẳng hạn như bao nhiêu chiếc xe đạp sẽ có ở Olin sau một giờ nữa.

\index{dự đoán}
\index{giải thích}

Nhưng dự đoán không phải là mục tiêu duy nhất; những mô hình như thế này cũng được dùng để giải thích tại sao các hệ thống lại vận hành như vậy và để đánh giá những phương án thiết kế khác. Chẳng hạn, nếu ta quan sát hệ thống và nhận thấy rằng ta thường bị hết xe đạp sau một thời gian nhất định, thì ta có thể dùng mô hình để hình dung ra lý do nào dẫn tới điều đó. Và nếu ta đang cân nhắc bổ sung thêm xe đạp, hay thêm một 
trạm nữa, thì ta có thể đánh giá hiệu ứng của những kịch bản ``nếu-thì" khác nhau.
\index{kịch bản nếu-thì}

Một ví dụ, giả sử ta có đủ số liệu để ước tính rằng \py{p2} bằng khoảng \py{0.2}, nhưng ta không có thông tin gì về \py{p1}.  Ta có thể chạy mô phỏng với một khoảng rộng các trị số của \py{p1} và xem kết quả biến đổi như thế nào. Quá trình này được gọi là {\bf quét} tham số, hiểu theo nghĩa là giá trị của tham số được ``quét" qua một khoảng những giá trị khả dĩ.

\index{quét}
\index{tham số ! quét}

Bây giờ khi đã biết về vòng lặp và mảng, ta có thể dùng chúng như sau:

\begin{python}
p1_array = linspace(0, 1, 11)
p2 = 0.2
num_steps = 60

for p1 in p1_array:
    state = run_simulation(p1, p2, num_steps)
    print(p1, state.olin_empty)
\end{python}

Mỗi lần duyệt qua vòng lặp, ta lại chạy mô phỏng với giá trị khác cho \py{p1} và giữ nguyên giá trị \py{p2} bằng \py{0.2}.  Sau đó, ta in ra \py{p1} số khách hàng không hài lòng tại Olin.

Để lưu kết quả và vẽ đồ thị, ta có thể dùng  một đối tượng \py{SweepSeries}, vốn tương tự như \py{TimeSeries}; nhưng khác ở chỗ là các nhãn trong \py{SweepSeries} là các giá trị tham số thay vì thời gian.

Ta có thể tạo ra một \py{SweepSeries} trống như thế này:

\begin{code}
sweep = SweepSeries()
\end{code}

Và thêm vào các giá trị như thế này:

\begin{python}
for p1 in p1_array:
    state = run_simulation(p1, p2, num_steps)
    sweep[p1] = state.olin_empty
\end{python}

Kết quả là một \py{SweepSeries} trong đó gắn từng giá trị của \py{p1} với số khách hàng không hài lòng tương ứng. Sau đó, ta có thể vẽ đồ thị cho kết quả:

\begin{code}
plot(sweep, label='Olin')
\end{code}




\section{Phát triển tăng dần}

Khi bạn bắt đầu viết chương trình kéo dài hơn một số ít dòng, bạn có thể nhận thấy mình phải dành nhiều thời gian hơn để gỡ lỗi. Càng viết nhiều mã lệnh trước khi bắt đầu gỡ lỗi, bạn càng khó tìm ra trục trặc hơn. 

\index{gỡ lỗi}
\index{phát triển tăng dần}

{\bf Phát triển tăng dần} là một cách lập trình cố gắng giảm thiểu khó khăn khi phải gỡ lỗi. Các bước cơ bản bao gồm:

\begin{enumerate}

\item Luôn bắt đầu từ một chương trình chạy được. Nếu bạn có một ví dụ trích từ cuốn sách, hay một chương trình mà bạn đã viết tương tự với bài toán cần giải quyết, thì hãy bắt đầu từ đó. Nếu không, hãy bắt đầu bằng mã lệnh mà bạn {\em biết} là nó đúng, chẳng hạn như {\tt x=5}.  Chạy chương trình và khẳng định rằng nó cho ra kết quả như mong đợi.

\item Mỗi lần chỉ thực hiện một điều chỉnh nhỏ mà có thể kiểm tra được. Một điều chỉnh ``kiểm tra được'' phải hiển thị nội dung gì đó hoặc có thứ hiệu ứng mà bạn nhận biết được. Tốt nhất là bạn biết rõ kết quả đúng là gì, hoặc có thể kiểm tra kết quả bằng việc thực hiện một phép tính khác. 

\index{điều chỉnh kiểm tra được}

\item Chạy chương trình xem điều chỉnh vừa rồi đã phát huy tác dụng chưa. Nếu được, làm tiếp bước 2. Nếu không, bạn phải gỡ lỗi một chút, nhưng nếu sửa đổi nhỏ thì chắc hạn bạn sẽ chẳng mất nhiều thời gian để tìm ra trục trặc. 

\end{enumerate}

Khi quá trình này phát huy tác dụng, những điều chỉnh của bạn thường sẽ chạy được ngay lần đầu tiên, hoặc dù không chạy được thì bạn phát hiện ngay ra vấn đề. Trên thực tế, có hai vấn đề gắn với phát triển tăng dần:

\begin{itemize}

\item Đôi khi bạn phải viết thêm mã lệnh để tạo nên kết quả đầu ra thấy được mà bạn có thể kiểm tra. Việc viết thêm mã lệnh này được goi là {\bf quây dàn giáo} vì bạn dùng nó để xây dựng chương trình và rồi gỡ bỏ nó đi một khi làm xong. Điều này nghe chừng lãng phí, song thời gian bạn dành ra để quây dàn giáo thì gần như sẽ là thời gian bạn tiết kiệm được để gỡ lỗi.

\index{quây dàn giáo}

\item Khi bạn bắt đầu, có thể sẽ không rõ bằng cách nào để đi từ {\tt x=5} đến chương trình mà bạn cố gắn viết. Bạn sẽ thấy thêm những ví dụ về quá trình này khi đọc sách, và bạn sẽ thạo hơn cùng những kinh nghiệm tích lũy được.

\end{itemize}

Nếu bạn thấy mình đang viết nhiều dòng lệnh trước khi bắt đầu kiểm tra, và bạn phải dành nhiều thời gian để gỡ lỗi, thì hãy thử phát triển theo cách tăng dần.

Trước khi tiếp tục, bạn có thể sẽ muốn đọc tập lệnh cho chương này, \py{chap04.ipynb}, và làm các bài tập. Để biết hướng dẫn tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


%\part{Modeling population growth}

\chapter{Dân số thế giới}
\label{chap05}

Vào năm 1968, Paul Erlich đã công bố bài viết {\it The Population Bomb} (Quả bom dân số), trong đó ông dự tính rằng dân số thế giới sẽ tăng trưởng nhanh trong thập niên 1970, rằng nông nghiệp không thể theo kịp được, và nạn đói hàng loạt xảy ra ở hai thập niên tiếp theo là điều không thể tránh khỏi (xem \url{http://modsimpy.com/popbomb}).  Là người lớn lên qua những thập niên đó, tôi thấy hạnh phúc phải nói rằng những dự đoán đó là sai.
  
\index{Erlich, Paul}
\index{Quả bom dân số}

Nhưng tăng trưởng dân số thế giới vẫn là một chủ đề được quan tâm, và nó là một câu hỏi mở, rằng trái đất cưu mang được dân số là bao nhiêu với điều kiện phải duy trì và cải thiện chất lượng cuộc sống.

\index{thế giới - dân số}
\index{dân số}

Ở chương này và chương tiếp theo, chúng ta dùng các công cụ từ các chương trước để giải thích sự tăng trưởng dân số thế giới từ năm 1950 và dự đoán cho 50--100 năm tới.

\index{dự đoán}

Để biết thông tin cơ bản về tăng trưởng dân số, hãy xem video này từ Bảo tàng lịch sử quốc gia Mỹ \url{http://modsimpy.com/human}.

\index{Bảo tàng lịch sử quốc gia Mỹ}


\section{Dữ liệu dân số thế giới}
\label{worldpopdata}

Bài viết trên trang Wikipedia về dân số thế giới bao gồm các bảng chứa con số ước tính số dân trên thế giới từ thời tiền sử đến giờ, cũng như dự báo trong tương lai  (\url{http://modsimpy.com/worldpop}).

\index{Wikipedia}
\index{Pandas}

Để đọc số liệu này, ta sẽ dùng Pandas, vốn cung cấp cá hàm giúp thao tác với số liệu. Hàm mà ta sẽ dùng là \py{read_html}, vốn để đọc một trang web và trích xuất thông tin từ bất kì bảng nào trong trang web đó. Trước khi dùng được hàm này, ta phải nhập nó. Bạn đã thấy câu lệnh import này rồi:

\index{\py{read_html}}
\index{import (câu lệnh)}
\index{câu lệnh!import}

\begin{python}
from modsim import *
\end{python}

vốn để nhập vào tất cả các hàm từ thư viện \py{modsim}. Để nhập \py{read_html}, câu lệnh mà ta cần viết là:

\begin{python}
from pandas import read_html
\end{python}

Bây giờ ta có thể dùng nó như sau:

\begin{python}
filename = 'data/World_population_estimates.html'
tables = read_html(filename,
                   header=0, 
                   index_col=0,
                   decimal='M')
\end{python}

Các tham biến gồm có:
\index{argument}

\begin{itemize}

\item \py{filename}: Tên của file (bao gồm cả thư mục chứa nó) dưới dạng chuỗi. Tham biến cũng có thể là một chuỗi URL bắt đầu bằng \py{http}.

\item \py{header}: Chỉ ra hàng nào của từng bảng được coi là dòng tiêu đề, tức là dòng chứa một tập hợp các nhãn định danh cho các cột. Trong trường hợp này nó là dòng đầu tiên (đánh số 0).

\item \py{index_col}: Chỉ ra cột nào trong từng bảng được coi là cột chỉ số (``{\bf index}''), nghĩa là tập hợp các nhãn dùng để xác định các hàng. Trong trường hợp này đó là cột thứ nhất, vốn chứa các năm.

\item \py{decimal}: Thường thì đây là tham biến dùng để chỉ định kí tự nào sẽ dùng làm ``dấu phẩy'' để phân tác phần thập phân của con số, vì mỗi nước lại quy định riêng (dấu ``chấm'' hoặc ``phẩy''). Ở đây tôi sẽ lạm dụng tính năng này để đặt \py{M} làm ``dấu phẩy'', vì M là kí hiệu cho ``triệu người''.

\end{itemize}

Kết quả, vốn được gán vào \py{tables}, là một dãy có chứa một \py{DataFrame} cho từng bảng. Một \py{DataFrame} là một đối tượng, được Pandas định nghĩa, để biểu thị cho số liệu dạng bảng.

\index{DataFrame}
\index{dãy}

Để chọn một \py{DataFrame} từ \py{tables}, ta có thể dùng toán tử ngoặc vuông như sau:

\begin{python}
table2 = tables[2]
\end{python}

Dòng này thực hiện chọn bảng thứ ba (đánh số 2), vốn có chứa con số ước tính dân cư từ năm 1950 đến 2016.

\index{dấu ngoặc vuông (toán tử)}
\index{toán tử!dấu ngoặc vuông}

Bây giờ ta có thể hiển thị vài dòng đầu tiên như sau:

\begin{python}
table2.head()
\end{python}

Các nhãn hiệu cột đều là những chuỗi dài, vì vậy thật khó thao tác với chúng. Ta có thể thay thế chúng bằng những chuỗi ngắn hơn như sau:

\index{chuỗi}
\index{cột}

\begin{python}
table2.columns = ['census', 'prb', 'un', 'maddison', 
                  'hyde', 'tanton', 'biraben', 'mj', 
                  'thomlinson', 'durand', 'clark']
\end{python}

Bây giờ ta có thể lựa chọn một cột từ \py{DataFrame} bằng cách dùng toán tử dấu chấm, giống như lựa chọn một biến trạng thái từ một đối tượng \py{State}:

\index{dấu chấm (toán tử)}
\index{toán tử!dấu chấm}

\begin{python}
census = table2.census / 1e9
un = table2.un / 1e9
\end{python}

Các dòng này thực hiện lựa chọn các con số ước tính bởi Ban Kinh tế Xã hội Liên hợp quốc (United Nations Department of Economic and Social Affairs, UN DESA) và Cục Thống kê Dân số Hoa Kỳ (the United States Census Bureau).

\index{Liên hợp quốc}
\index{Cục Thống kê Dân số Hoa Kỳ}

Mỗi kế quả là một dãy (\py{Series}) trong Pandas, dãy cũng giống như một \py{DataFrame} nhưng chỉ có một cột.

\index{dãy (Series)}

Số một tỉ viết như là \py{1e9} thì ngắn hơn và cũng đỡ bị mắc lỗi hơn là viết \py{1000000000}.  Khi ta chia một \py{Series} cho một số, nó đem chia tất cả phần tử trong \py{Series} cho số đó. Từ đây trở đi, ta sẽ biểu diễn các ước tính dân số theo tỉ dân.


\section{Vẽ đồ thị}

Bây giờ ta có thể vẽ đồ thị các con số ước tính như sau:

\index{plot}

\begin{python}
plot(census, ':', label='US Census')
plot(un, '--', label='UN DESA')
\end{python}


Hai dòng tiếp theo là để vẽ các đối tượng \py{Series}.  Các {\bf chuỗi định dạng} (format string) gồm \py{':'} và \py{'--'} là để chỉ các đường chấm và đường nét đứt. Để biết thêm về những chuỗi định dạng trong Pyplot, hãy xem \url{http://modsimpy.com/plot}.

\index{chuỗi định dạng}
\index{Pyplot}

Tham biến \py{label} cung cấp chuỗi mà ta muốn nó xuất hiện trên phần chú giải biểu đồ.

\index{label}
\index{chú giải}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig01.pdf}}
\caption{Ước tính dân số thế giới, 1950--2016.}
\label{chap03-fig01}
\end{figure}

Hình~\ref{chap03-fig01} cho thấy kết quả. Hai đường gần như trùng khớip nhau; tại gần như mọi thời điểm, khác biệt giữa hai trị số ước tính này chỉ không đến 1\%.


\section{Mô hình tăng trưởng hằng số}

Giả dụ ta muốn dự tính mức tăng trưởng dân số thế giới trong 50 hay 100 năm tới. Ta có thể làm điều đó bằng cách phát triển một mô hình để miêu tả dân số sẽ tăng thế nào, khớp mô hình này với các số liệu đã có tới hiện nay, rồi sử dụng mô hình để ước tính.

\index{tăng trưởng hằng số}

Trong vài mục tiếp theo, tôi sẽ biểu diễn quá trình này bắt đầu bằng những mô hình đơn giản và rồi dần cải thiện chúng.

\index{mô hình hoá lặp}

Mặc dù vẫn tồn tại độ cong trên đường đồ thị biểu diễn các ước tính nhưng trông như sự tăng trưởng dân số thế giới đã gần như tuyến tính từ khoảng năm 1960. Do vậy, ta sẽ bắt đầu bằng một mô hình có mức tăng trưởng là hằng số.

Để khớp mô hình này với số liệu, ta sẽ tính mức tăng trưởng trung bình hằng năm từ 1950 đến 2016. Vì các số liệu UN và điều tra là gần như nhau, nên ta sẽ sử dụng số liệu điều tra.

Ta có thể lựa chọn một giá trị từ một dãy (\py{Series}) bằng cách dùng toán tử ngoặc vuông:
\index{ngoặc vuông (toán tử)}
\index{toán tử!ngoặc vuông}

\begin{python}
census[1950]
\end{python}

Vậy là ta có thể thu được mức tăng trưởng tổng cộng trong thời đoạn như sau:

\begin{python}
total_growth = census[2016] - census[1950]
\end{python}

Các con số đặt trong cặp ngoặc vuông được gọi là các {\bf nhãn}, vì chúng như các nhãn hiệu gắn với các hàng của dãy (\py{Series}) (đừng nhầm với nhãn ở mục trước; nhãn đó là để gắn cho các đường trong một biểu đồ).

\index{nhãn}

Ở ví dụ này, các nhãn 2016 và 1950 là một phần của số liệu, bởi vậy tốt nhất là ta không viết nó vào chương trình. Việc áp đặt các giá trị như thế vào chương trình được gọi là {\bf viết mã cứng}; và được coi là quy tắc xấu vì nếu số liệu có thay đổi trong tương lai thì ta sẽ phải thay đổi chương trình (xem  \url{http://modsimpy.com/hardcode}).

\index{viết mã cứng}

Tốt hơn là ta lấy các nhãn đầu tiên và nhãn cuối cùng từ  \py{Series} như sau:

\begin{python}
t_0 = get_first_label(census)
t_end = get_last_label(census)
elapsed_time = t_end - t_0
\end{python}

\py{get_first_label} và \py{get_last_label} được định nghĩa trong \py{modsim.py}. Chắc bạn cũng đoán được, chúng có tác dụng lựa chọn các nhãn đầu và cuối từ \py{census}.
Hiệu số giữa chúng là khoảng thời gian.

Thư viện \py{modsim} cũng định nghĩa \py{get_first_value} và \py{get_last_value}, mà ta có thể dùng để tính \py{total_growth}:

\begin{python}
p_0 = get_first_value(census)
p_end = get_last_value(census)
total_growth = p_end - p_0
\end{python}

Sau cùng, ta có thể tính mức tăng trưởng trung bình hằng năm.

\begin{python}
annual_growth = total_growth / elapsed_time
\end{python}

Bước tiếp theo là dùng ước tính này để mô phỏng mức tăng trưởng dân số từ năm 1950.


\section{Mô phỏng}

Mô phỏng của ta sẽ bắt đầu với dân số khảo sát được vào năm 1950, \py{p0}, và bổ sung thêm \py{annual_growth} hằng năm. Để lưu kết quả, ta sẽ dùng một đối tượng \py{TimeSeries}:

\index{TimeSeries}

\begin{python}
results = TimeSeries()
\end{python}

Ta có thể đặt giá trị thứ nhất trong \py{TimeSeries} mới bằng cách sao chép giá trị thứ nhất từ \py{census}:

\begin{python}
results[t_0] = census[p_0]
\end{python}

Sau đó ta đặt phần còn lại của các giá trị bằng cách mô phỏng mức tăng trưởng hằng năm:

\begin{python}
for t in linrange(t_0, t_end):
    results[t+1] = results[t] + annual_growth
\end{python}

\py{linrange} được định nghĩa trong thư viện \py{modsim}. Ở ví dụ này, nó trả lại một mảng NumPy gồm các số nguyên từ \py{t_0} đến \py{t_end}, bao gồm số đầu nhưng loại trừ số cuối.

\index{linrange}
\index{NumPy}
\index{array}

Mỗi lần chạy qua vòng lặp, biến lặp \py{t} lấy giá trị tiếp theo từ mảng. Bên trong vòng lặp, ta tính dân số cho từng năm bằng cách đem dân số năm trước cộng với \py{annual_growth}.  Lần cuối cùng qua vòng lặp, giá trị của \py{t} là 2015, bởi vậy nhãn cuối cùng của \py{results} là 2016, chính là giá trị ta cần.

\index{vòng lặp}
\index{biến vòng lặp}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig02.pdf}}
\caption{Ước tính dân số thế giới, 1950--2016, và một mô hình tăng trưởng hằng số.}
\label{chap03-fig02}
\end{figure}

Hình~\ref{chap03-fig02} cho thấy kết quả. Mô hình không khớp với số liệu lắm trong giai đoạn từ 1950 đến 1990, nhưng sau đó thì khá tốt. Dù vậy, vẫn còn những vấn đề sau:

\begin{itemize}

\item Không có cơ chế hiển nhiên nào khiến cho tăng trưởng dân cư phải là hằng số từ năm này qua năm khác. Sự thay đổi dân số được quyết định bởi tỉ lệ người chết và tỉ lệ người sinh đẻ, bởi vậy ta sẽ lường được các tỉ lệ này phụ thuộc vào số dân hiện tại.

\item Theo mô hình này, ta lường được rằng mô hình sẽ tiếp tục tăng trưởng với cùng tốc độ mãi mãi, mà điều này dường như không hợp lý.

\end{itemize}

Chúng ta sẽ thử vài mô hình khác trong vài mục tiếp theo, song trước hết ta hãy dọn dẹp lại mã lệnh đã.

Trước khi tiếp tục, bạn có thể muốn đọc tập mã lệnh chương này, \py{chap05.ipynb}, và làm bài tập. Để biết hướng dẫn tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Mô hình hoá tăng trưởng}
\label{chap06}
Ở chương trước ta đã mô phỏng một mô hình dân số thế giới với mức tăng trưởng hằng số. Trong chương này ta sẽ xem rằng liệu có thể lập một mô hình tốt hơn với mức tăng trưởng tỉ lệ thuận với dân số.

Nhưng trước hết, ta có thể cải thiện mã lệnh ở chương trước bằng cách gói nói vào một hàm và sử dụng các đối tượng \py{System}.

\section{Các đối tượng System}
\label{nowwithsystem}

Giống như một đối tượng \py{State}, một đối tượng \py{System} có chứa các biến cùng giá trị của chúng. Khác biệt là ở chỗ:

\begin{itemize}

\item Các đối tượng \py{State} chứa những biến trạng thái, vốn biểu diễn trạng thái của hệ thống, được cập nhật trong quá trình mô phỏng.

\item Các đối tượng \py{System} chứa các {\bf biến hệ thống}, vốn biểu diễn cho các tham số của hệ thống và thường không được cập nhật trong quá trình mô phỏng.

\end{itemize}  

Chẳng hạn, trong mô hình dùng chung xe đạp, các biến trạng thái bao gồm số xem đạp tại từng địa điểm, vốn đợc cập nhật mỗi khi người dùng di chuyển một xe. Các biến hệ thống bao gồm số địa điểm, tổng số xe và lưu lượng xe tới từng địa điểm.

Trong mô hình dân số, biến trạng thái duy nhất là số dân. Các biến hệ thống bao gồm tốc độ tăng trưởng hằng năm, thời điểm đầu và dân cư ban đầu, cùng thời điểm cuối. 

Chẳng hạn ta có các biến sau, như đã tính ở chương trước (coi rằng \py{census} là một đối tượng \py{Series}):

\begin{python}
t_0 = get_first_label(census)
t_end = get_last_label(census)
elapsed_time = t_end - t_0

p_0 = get_first_value(census)
p_end = get_last_value(census)
total_growth = p_end - p_0

annual_growth = total_growth / elapsed_time
\end{python}

Trong các biến trên, một vài là tham số mà ta cần để mô phỏng hệ thống; số còn lại chỉ là giá trị tạm thời có thể bỏ đi được. Ta có thể đặt các tham số 
mình cần vào một đối tượng \py{System} như sau:

\index{System object}

\begin{python}
system = System(t_0=t_0, 
                t_end=t_end,
                p_0=p_0,
                annual_growth=annual_growth)
\end{python}

\py{t0} và \py{t_end} là năm đầu và năm cuối; \py{p_0} là dân số ban đầu, còn \py{annual_growth} là tốc độ tăng trưởng ước tính hằng năm.

Tiếp theo ta sẽ gói mã lệnh từ chương trước vào trong một hàm:

\begin{python}
def run_simulation1(system):
    results = TimeSeries()
    results[system.t_0] = system.p_0
    
    for t in linrange(system.t_0, system.t_end):
        results[t+1] = results[t] + system.annual_growth
    
    return results
\end{python}

Khi \py{run_simulation1} chạy, chương trình sẽ lưu kết quả vào một \py{TimeSeries} và trả lại nó.
 
\index{TimeSeries (đối tượng)}

Hàm sau sẽ vẽ đồ thị kết quả cùng với các ước lượng \py{census} và \py{un}:

\begin{python}
def plot_results(census, un, timeseries, title):
    plot(census, ':', label='US Census')
    plot(un, '--', label='UN DESA')
    plot(timeseries, color='gray', label='model')
    
    decorate(xlabel='Year', 
             ylabel='World population (billion)',
             title=title)
\end{python}

\index{vẽ đồ thị}
\index{trang trí}

Đối số \py{color} quy định màu của nét vẽ. Để biết chi tiết về quy định màu trong Pyplot, hãy xem \url{http://modsimpy.com/color}.

\index{Pyplot}
\index{màu}

Sau cùng, ta có thể chạy mô phỏng như sau:

\begin{python}
results = run_simulation1(system)
plot_results(census, un, results, 'Constant growth model')
\end{python}

Kết quả giống hệt như Hình~\ref{chap03-fig02}.

Dường như không dễ thấy rằng việc dùng các hàm và đối tượng \py{System} đã cải thiện được gì đáng kể, và với một mô hình đơn giản mà ta chỉ chạy một lần thì chắc là không. Nhưng khi ta làm việc với những mô hình phức tạp hơn, và khi ta chạy nhiều mô phỏng với các tham số khác nhau thì ta sẽ thấy rằng việc tổ chức mã lệnh sẽ tạo nên khác biệt lớn.

Bây giờ, hãy xem liệu ta có thể cải thiện mô hình không nhé.


\section{Mô hình tăng trưởng tỉ lệ thuận}

Vấn đề lớn nhất đối với mô hình tăng trưởng hằng số là ở chỗ nó không có ý nghĩa gì cả. Thật khó tưởng tượng bằng cách nào mà mọi người trên toàn thế giới có thể kiềm chế để giữ cho dân số có mức tăng trưởng không đổi năm này qua năm khác.

\index{tăng trưởng dân số}

Mặt khác, nếu một phần của dân số chết đi hằng năm, và một phần khác sinh đẻ, thì ta có thể tính được mức thay đổi ròng của dân số như sau:

\begin{python}
def run_simulation2(system):
    results = TimeSeries()
    results[system.t_0] = system.p_0
    
    for t in linrange(system.t_0, system.t_end):
        births = system.birth_rate * results[t]
        deaths = system.death_rate * results[t]
        results[t+1] = results[t] + births - deaths
        
    return results
\end{python}

Bây giờ ta có thể chọn các giá trị cho \py{birth_rate} và \py{death_rate} để cho khớp với số liệu nhất. Không cần phải cố gắng nhiều, tôi đã chọn:

\begin{python}
system.death_rate = 0.01
system.birth_rate = 0.027
\end{python}

Sau đó tôi chạy mô phỏng và vẽ đồ thị kết quả:

\begin{python}
results = run_simulation2(system)
plot_results(census, un, results, 'Proportional model')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig03.pdf}}
\caption{Ước tính dân số thế giới, 1950--2016, và một mô hình tỉ lệ thuận.}
\label{chap03-fig03}
\end{figure}

Hình~\ref{chap03-fig03} thể hiện kết quả. Mô hình tỉ lệ thuận khớp số liệu khá tốt từ năm 1950 đến 1965, nhưng sau đó thì không tốt lắm. Xét tổng thể, {\bf chất lượng khớp} không tốt bằng mô hình tăng trưởng hằng số. Điều này thật ngạc nhiên, vì dường như mô hình tỉ lệ thuận thì đúng thực tế hơn.

Ở chương tiếp theo ta sẽ cố thử một lần nữa để tìm ra mô hình vừa hợp lý lại vừa khớp với số liệu. Song trước hết, tôi muốn cải thiện mã lệnh ở đôi chỗ đã.


\section{Chỉnh sửa hàm cập nhật}

\py{run_simulation1} và \py{run_simulation2} gần giống hệt chỉ trừ phần thân của vòng lặp \py{for}, nơi ta tính dân số cho năm tới. 

\index{cập nhật (hàm)}
\index{hàm!cập nhật}

Thay vì lặp lại mã lệnh giống hệt, ta có thể phân tách các thứ thay đổi riêng ra các thứ không thay đổi. Đầu tiên, tôi sẽ kéo đoạn mã lệnh cập nhật khỏi \py{run_simulation2} và biến nó thành một hàm:

\begin{python}
def update_func1(pop, t, system):
    births = system.birth_rate * pop
    deaths = system.death_rate * pop
    return pop + births - deaths
\end{python}

Hàm này nhận vào các đối số là dân số hiện tại, năm hiện tại, và một đối tượng  \py{System}; nó trả lại dân số tính toán cho năm tiếp theo.

Hàm cập nhật này không dùng \py{t}, bởi vậy ta có thể bỏ nó đi. Nhưng ta sẽ thấy rằng các hàm khác dùng đến nó, vì vậy sẽ tiện hơn nếu quy định các hàm nhận vào những tham số giống nhau, bất kể tham số đó được dùng đến không.

Bây giờ ta có thể viết một hàm có thể chạy bất kì mô hình nào:

\begin{python}
def run_simulation(system, update_func):
    results = TimeSeries()
    results[system.t_0] = system.p_0
    
    for t in linrange(system.t_0, system.t_end):
        results[t+1] = update_func(results[t], t, system)
        
    return results
\end{python}

Hàm này biểu diễn một đặc điểm mà ta chưa thấy trước đây: nó nhận vào một hàm như là một ham số! Khi ta gọi \py{run_simulation}, tham số thứ hai là một hàm, như \py{update_func1}, để tính dân số cho năm tới. 

\index{hàm!như tham số}

Sau đây là cách mà ta gọi nó:

\begin{python}
results = run_simulation(system, update_func1)
\end{python}

Truyền một hàm vào như một đối số cũng giống như truyền bất kì giá trị nào khác. Đối số, vốn là \py{update_func1} ở ví dụ này, được gán vào tham số, vốn có tên \py{update_func}.  Trong \py{run_simulation}, chúng ta có thể chạy  \py{update_func} cũng như bất kì hàm nào khác.

Vòng lặp trong \py{run_simulation} gọi \py{update_func1} một lần cho từng năm giữa \py{t_0} và \py{t_end-1}.  Kết quả cũng giống như Hình~\ref{chap03-fig03}.


\section{Kết hợp sinh trưởng và chết}

Khi đi sâu vào việc, ta cũng có thể đơn giản hoá mã lệnh bằng cách kết hợp sự  sinh trưởng và chết đi, để tính tốc độ tăng trưởng ròng. Thay vì hai tham số, \py{birth_rate} và \py{death_rate}, ta có thể viết hàm cập nhật dưới dạng một tham số duy nhất để biểu diễn hiệu số:

\begin{python}
system.alpha = system.birth_rate - system.death_rate
\end{python}

Tên của tham số này, \py{alpha}, là tên thông dụng đặt cho tốc độ tăng trưởng tỉ lệ thuận.

Sau đây là một phiên bản chỉnh sửa của \py{update_func1}:

\begin{python}
def update_func2(pop, t, system):
    net_growth = system.alpha  * pop
    return pop + net_growth
\end{python}

Và sau đây là cách mà ta chạy nó:

\begin{python}
results = run_simulation(system, update_func2)
\end{python}

Một lần nữa, kết quả cũng giống như Hình~\ref{chap03-fig03}.

Trước khi tiếp tục, bạn có thể muốn đọc tập notebook cho chương này, \py{chap06.ipynb}, và làm các bài tập. Để biết hướng dẫn việc tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.



\chapter{Tăng trưởng bậc hai}
\label{chap07}

Ở chương trước, ta đã phát triển một mô hình dân số trong đó mức tăng trưởng ròng thì tỉ lệ thuận với số dân hiện tại. Mô hình này dường như thực tế hơn mô hình tăng trưởng hằng số, nhưng nó cũng không khớp với số liệu.

Có một vài chỗ mà ta có thể thử cải thiện mô hình này:

\begin{itemize}

\item Có lẽ tốc độ tăng trưởng ròng thay đổi theo thời gian.

\item Có lẽ tốc độ tăng trưởng ròng phụ thuộc vào số dân hiện tại, nhưng mối quan hệ là hàm bậc hai chứ không phải tuyến tính.

\end{itemize}

Trong quyển tập lệnh cho chương này, bạn sẽ có cơ hội thử lựa chọn thứ nhất. Còn trong chương này ta sẽ khám phá lựa chọn thứ hai.


\section{Tăng trưởng bậc hai}
\label{quadratic}

Sẽ có ý nghĩa nếu cho rằng mức tăng trưởng ròng phụ thuộc vào dân số hiện tại, nhưng có thể đó không phải là liên hệ tuyến tính như sau:

\begin{python}
    net_growth = system.alpha * pop
\end{python}

Có lẽ đó là mối quan hệ bậc hai như sau:

\index{tăng trưởng bậc hai}

\begin{python}
    net_growth = system.alpha * pop + system.beta * pop**2
\end{python}

Ta có thể kiểm tra giả thiết đó với một hàm cập nhật mới:

\begin{python}
def update_func_quad(pop, t, system):
    net_growth = system.alpha * pop + system.beta * pop**2
    return pop + net_growth
\end{python}

Bây giờ ta có hai tham số. Tôi chọn các giá trị sau bằng cách thử sai; sau này ta sẽ xem những cách làm tốt hơn.

\index{tham số}

\begin{python}
system.alpha = 0.025
system.beta = -0.0018
\end{python}

Và sau đây là cách ta chạy nó:

\begin{python}
results = run_simulation(system, update_func_quad)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig04.pdf}}
\caption{Ước tính dân số thế giới, 1950--2016, và một mô hình bậc hai.}
\label{chap03-fig04}
\end{figure}

Hình~\ref{chap03-fig04} cho thấy kết quả. Mô hình khớp tốt với các số liệu trong toàn bộ khoảng, chỉ chênh lệnh một chút vào những năm thập kỉ 1960.

Dĩ nhiên, ta lường trước rằng mô hình bậc hai sẽ khớp tốt hơn là các mô hình hằng số và mô hình tỉ lệ thuận vì nó có hai tham số mà ta có thể chọn, trong khi các mô hình kia chỉ có một. Nói chung, khi càng có nhiều tham số để thử nghiệm thì bạn càng trông đợi là mô hình sẽ khớp tốt hơn.

\index{mức độ khớp}
\index{số liệu}
\index{khớp số liệu}

Nhưng khớp số liệu không chỉ là lý do duy nhất để nghĩ rằng mô hình bậc hai có thể là lựa chọn tốt. Nó cũng hợp lý hơn nữa; theo nghĩa là có một lý do hợp lệ để lường được rằng mối liên hệ giữa mức tăng trưởng và dân số có được dạng đó.

Để hiểu được điều này, ta sẽ nhìn vào mức tăng trưởng ròng như một hàm phụ thuộc vào dân số. Sau đây là cách mà ta tính toán nó:

\begin{python}
pop_array = linspace(0, 15, 100)
net_growth_array = (system.alpha * pop_array + 
                    system.beta * pop_array**2)
\end{python}

\py{pop_array} có chứa 100 trị số được giãn cách đều từ 0 đến 15.  \py{net_growth_array} chứa 100 giá trị tương ứng của mức tăng trưởng ròng. Ta có thể vẽ đồ thị kết quả như sau:

\begin{python}
plot(pop_array, net_growth_array)
\end{python}

Trước đây ta đã dùng \py{plot} với các đối tượng \py{Series}.  Ở ví dụ này, ta dùng hai mảng NumPy, tương ứng với các trục x và y.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig05.pdf}}
\caption{Mức tăng trưởng ròng như một hàm số theo số dân.}
\label{chap03-fig05}
\end{figure}

Hình~\ref{chap03-fig05} cho thấy kết quả. Lưu ý rằng trục x bây giờ không phải thời gian, như với các hình trước, mà là dân số. Ta có thể chia đường cong này thành bốn miền với xu thế riêng:
\index{miền}

\begin{itemize}

\item Khi dân số dưới 3-4 tỉ người, mức tăng trưởng ròng tỉ lệ thuận với dân số, như ở mô hình tỉ lệ thuận. Ở miền này, dân số chỉ tăng chậm vì số dân còn ít.

\item Từ 4 đến 10 tỉ, dân số tăng trưởng nhanh vì có nhiều người.

\item Trên 10 tỉ, dân số tăng chậm hơn; xu thế này mô hình hóa cho hiệu ứng của hạn chế tài nguyên khiến sinh suất giảm hoặc tử suất tăng lên.

\item Trên 14 tỉ, các nguồn tài nguyên bị hạn chế đến nỗi tử suất vượt sinh suất và mức tăng trưởng ròng trở nên âm.

\end{itemize}

Ngay dưới mức 14 tỉ, có một điểm mà tại đó mức tăng trưởng ròng bằng 0, nghĩa là dân số không thay đổi. Tại điểm này, sinh suất và tử suất bằng nhau, vì vậy dân số ở trạng thái {\bf cân bằng}.

\index{cân bằng}


\section{Cân bằng}
\label{equilibrium}

Để tìm điểm cân bằng, ta có thể tìm các nghiệm của phương trình sau:
%
\[ \Delta p = \alpha p + \beta p^2 \]
%
trong đó $\Delta p$ là mức tăng trưởng ròng của dân số, $p$ là đân số hiện tại, còn $\alpha$ và $\beta$ là các tham số của mô hình. Ta có thể viết lại vế phải như sau:
%
\[ \Delta p = p (\alpha + \beta p) \]
%
vốn bằng $0$ khi $p=0$ hay $p=-\alpha/\beta$.  Ở ví dụ này, $\alpha = 0.025$ và $\beta = -0.0018$, bởi vậy $-\alpha/\beta = 13.9$.

Đối với mô hình hóa dân số, mô hình bậc hai được viết lại theo cách tiện lợi như sau:
%
\[ \Delta p = r p (1 - p / K) \]
%
Cũng vẫn là mô hình đó, chỉ là một cách khác để {\bf tham số hóa} nó. Cho trước $\alpha$ và $\beta$, ta có thể tính $r=\alpha$ và $K=-\alpha/\beta$.

\index{tham số hóa}

Trong phiên bản này, ta dễ diễn giải các tham số hơn: $r$ là sinh suất tối đa, quan sát được khi $p$ nhỏ, còn $K$ là điểm cân bằng. $K$ cũng được gọi là {\bf sức chứa}, vì nó thể hiện dân số lớn nhất mà môi trường có thể dung nạp được.

\index{sức chứa}

Ở chương kế tiếp, ta sẽ dùng các mô hình vừa xây dựng để tạo ra kết quả dự đoán.

\section{Sự hoạt động bất thường}

Khi người học làm quen với các hàm, có vài điều khiến họ thường nhầm lẫn. Trong mục này, tôi sẽ trình bày và giải thích một số vấn đề thường gặp.

Lấy ví dụ, chẳng hạn bạn muốn một hàm nhận tham biến là một đối tượng \py{System} với các biến \py{alpha} và \py{beta}, rồi tính sức chứa, \py{-alpha/beta}.  Sau đây là một cách làm hay: 

\begin{python}
def carrying_capacity(system):
    K = -system.alpha / system.beta
    return K
    
sys1 = System(alpha=0.025, beta=-0.0018)
pop = carrying_capacity(sys1)
print(pop)
\end{python}

Bây giờ hãy xem tất cả những cách làm có khả năng sai sót.

Bất thường \#1: Không dùng tham biết. Ở phiên bản sau đây, hàm không nhận vào tham biến nào cả; khi \py{sys1} xuất hiện trong hàm, nó chỉ đến đối tượng mà ta tạo nên bên ngoài hàm.

\begin{python}
def carrying_capacity():
    K = -sys1.alpha / sys1.beta
    return K
    
sys1 = System(alpha=0.025, beta=-0.0018)
pop = carrying_capacity()
print(pop)
\end{python}

Phiên bản này thực ra vẫn hoạt động được, nhưng không linh hoạt như đáng ra nó có thể. Nếu có vài đối tượng \py{System} khác nhau thì hàm này chỉ hoạt động với một trong số chúng, và chỉ hoạt động khi đối tượng đó đặc đặt tên là \py{sys1}.

Bất thường \#2: ``Hành hạ'' các tham số. Khi người học mới làm quen với các tham số, họ thường viết hàm kiểu như sau:

\begin{python}
# SAI
def carrying_capacity(system):
    system = System(alpha=0.025, beta=-0.0018)
    K = -system.alpha / system.beta
    return K
    
sys1 = System(alpha=0.03, beta=-0.002)
pop = carrying_capacity(sys1)
print(pop)
\end{python}

Ở ví dụ này, ta có một đối tượng \py{System} mang tên \py{sys1} được truyền vào làm đối số cho \py{carrying_capacity}. Nhưng khi hàm này chạy thì nó lờ ngay đối số đi và lập tức thay thế bằng một đối tượng \py{System} mới. Hệ quả là hàm này luôn trả về cùng một giá trị, bất kể đối số nào được truyền đến.

Khi bạn viết một hàm, nói chung bạn sẽ không biết các giá trị tham số sẽ là gì. Nhiệm vụ của bạn là viết một hàm hoạt động được với mọi giá trị hợp lệ. Nếu bạn đen gán các giá trị cụ thể vào cho tham số thì bạn đã phá vỡ hết mục đích của hàm rồi.

Bất thường \#3: Không trả về giá trị nào. Sau đây là phiên bản tính giá trị của \py{K} mà không trả lại giá trị này.

\begin{python}
# SAI
def carrying_capacity(system):
    K = -system.alpha / system.beta
    
sys1 = System(alpha=0.025, beta=-0.0018)
pop = carrying_capacity(sys1)
print(pop)
\end{python}

Một hàm mà không có câu lệnh return sẽ luôn trả lại một giá trị đặc biệt gọi là \py{None}, bởi vậy trong ví dụ này giá trị của \py{pop} là \py{None}. Nếu bạn đang gỡ lỗi một chương trình và phát hiện thấy giá trị của một biến là \py{None} trong khi lẽ ra không phải vậy, thì có thể nguyên nhân vì một hàm không có câu lệnh return.
\index{None}

Bất thường \#4: Phớt lờ giá trị được trả lại. Sau cùng, đây là một phiên bản mà hàm đã viết đúng rồi, nhưng cách dùng nó thì sai.

\begin{python}
# SAI
def carrying_capacity(system):
    K = -system.alpha / system.beta
    return K
    
sys1 = System(alpha=0.025, beta=-0.0018)
carrying_capacity(sys1)
print(K)
\end{python}

Ở ví dụ này, \py{carrying_capacity} chạy và trả kết quả \py{K}, nhưng giá trị đó bị đánh rơi mất.

Khi bạn chạy một hàm mà hàm này trả giá trị, bạn cần phải làm gì đó với kết quả. Thường thì bạn sẽ gán nó vào một biến, như ở các ví dụ trước, hoặc bạn cũng có thể dùng nó như một bộ phận trong một biểu thức. Chẳng hạn, bạn có thể triệt tiêu biến tạm thời \py{pop} như sau:

\begin{python}
print(carrying_capacity(sys1))
\end{python}

Hoặc nếu bạn có nhiều hệ thống thì bạn có thể tính tổng sức chứa như sau:

\begin{python}
total = carrying_capacity(sys1) + carrying_capacity(sys2)
\end{python}

Trước khi tiếp tục, có thể bạn sẽ muốn đọc tập mã lệnh cho chương này, \py{chap07.ipynb}, và làm các bài tập. Để biết những hướng dẫn tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.




\chapter{Dự đoán}
\label{chap08}

Ở chương trước, ta đã phát triển một mô hình bậc hai cho sự tăng trưởng dân số thế giới từ 1950 đến 2016. Đây là một mô hình đơn giản, nhưng nó khớp với số liệu và cơ chế hoạt động của nó khá hợp lý.

Trong chương này ta sẽ dùng mô hình bậc hai để phát sinh ra dự phóng về sự tăng trưởng trong tương lai, cũng như so sánh kết quả ta tìm được với những dự phóng thực sự do các nhà dân số học đã nghiên cứu. Chúng ta cũng sẽ trình bày các mô hình từ những chương trước dưới dạng phương trình vi phân và giải chúng theo cách giải tích.

\index{dự đoán}
\index{dự phóng}


\section{Phát sinh các dự phóng}

Ta sẽ bắt đầu bằng mô hình bậc hai từ Mục ~\ref{quadratic}, vốn được dựa trên hàm được ập nhật sau:
\index{tăng trưởng bậc hai}

\begin{python}
def update_func_quad(pop, t, system):
    net_growth = system.alpha * pop + system.beta * pop**2
    return pop + net_growth
\end{python}

Như ta đã thấy từ chương trước, ta có thể lấy ngày bắt đầu, ngày kết thúc và dân số ban đầu từ \py{census}, vốn là một dãy chứa các ước lượng dân số liệt kê bởi Cục Điều tra Hoa Kỳ:

\begin{python}
t_0 = get_first_label(census)
t_end = get_last_label(census)
p_0 = census[t_0]
\end{python}

Bây giờ ta có thể tạo một đối tượng \py{System}:
\index{System (đối tượng)}

\begin{python}
system = System(t_0=t_0, 
                t_end=t_end,
                p_0=p_0,
                alpha=0.025,
                beta=-0.0018)
\end{python}

Rồi chạy mô hình:

\begin{python}
results = run_simulation(system, update_func_quad)
\end{python}

Ta đã thấy kết quả ở Hình~\ref{chap03-fig04}.  Bây giờ, để tạo một dự phóng, cái duy nhất mà ta cần thay đổi là \py{t_end}:

\begin{python}
system.t_end = 2250
results = run_simulation(system, update_func_quad)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap04-fig01.pdf}}
\caption{Mô hình bậc hai cho sự tăng trưởng dân số thế giới, cùng dự phóng từ năm 2016 đến 2250.}
\label{chap04-fig01}
\end{figure}

Hình~\ref{chap04-fig01} cho thấy kết quả, với dự phóng đến tận năm 2250. Theo mô hình này, mức tăng trưởng dân số sẽ tiếp tục gần như tuyến tính trong 50--100 năm tới, và rồi chậm lại trong 100 năm tiếp theo, tiệm cận đến 13.9 tỉ vào năm 2250.

Tôi chủ ý dùng chữ ``dự phóng" thay vì ``dự đoán", với sự khác biệt sau đây: ``dự đoán" ngụ ý rằng ``đây là điều mà chúng ta cần trông đợi sẽ xảy ra, chí ít là gần như vậy"; còn ``dự phóng" ngụ ý rằng ``nếu mô hình này thực sự là cách mô tả sát với những gì đang xảy ra trong hệ thống, và trong tương lai không có gì làm thay đổi các tham số của mô hình, thì kết quả này là những gì sẽ xảy ra."

Bằng cách nói ``dự phóng" sẽ để ngỏ khả năng những thứ quan trọng trên thực tế vẫn chưa được nắm giữ lại trong mô hình. Nó cũng gợi ý rằng, ngay cả khi mô hình đã tốt chăng nữa, thì các tham số mà ta dự đoán dựa theo quá khứ vẫn có thể khác đi trong tương lai.

Mô hình bậc 2 mà ta đang làm việc với được dựa trên giả thiết rằng mức độ tăng trưởng dân số bị giới hạn bởi mức độ sẵn có của tài nguyên. Trong trường hợp này, khi dân số tiệm cận với sức chứa dân cư thì sinh suất sẽ giảm và tử suất tăng vì tài nguyên trở nên hiếm hoi.

\index{sức chứa dân cư}

Nếu giả thiết đó là đúng thì ta có thể sẽ dùng được mức độ tăng trưởng dân số thực tế để ước tính sức chứa dân cư, đặc biệt nếu ta quan sát sự chuyển đổi về tình trạng khi mà sinh suất bắt đầu giảm.

Nhưng trong trường hợp tăng trưởng dân số thế giới, các điều kiện đó không nghiệm đúng. Trong vòng 50 năm qua, tốc độ tăng trưởng ròng đã đi ngang nhưng vẫn chưa hạ, vì vậy ta chưa có đủ số liệu để ước tính sức chứa dân cư một cách đáng tin cậy. Và những hạn chế tài nguyên có lẽ {\em không phải} là nguyên nhân chính dẫn đến sự tăng chậm của dân số. Dẫn chứng ư? Hãy xét xem:

\begin{itemize}

\item Trước hế, tử suất không tăng lên, mà giảm từ 1.9\% năm 1950 xuống còn 0.8\% ở hiện tại (xem \url{http://modsimpy.com/mortality}).  Như vậy sự giảm mức tăng trưởng ròng hoàn toàn do giảm sinh suất.

\index{tử suất}

\item Thứ hai, mối liên hệ giữa tài nguyên và sinh suất trái ngược với những gì mà mô hình giả sử; vì các nước phát triển hơn và người dân giàu có hơn, sinh suất có xu hướng giảm.

\index{sinh suất}

\end{itemize} 

Ta không nên bảo lưu cứng nhắc ý kiến rằng mô hình này có thể ước tính được sức chứa dân cư. Nhưng các dự đoán của mô hình có thể tin cậy được ngay cả khi các giả thiết mô hình không nhất nhất phải đúng. Chẳng hạn, sự tăng trưởng dân cư có thể diễn biến {\em như thể} nó bị hạn chế bởi tài nguyên, dù rằng cơ chế thực sự lại ở chỗ khác.

Thực ra, các nhà nhân khẩu học khi nghiên cứu tăng trưởng dân số cũng dùng những mô hình ta đang xem đây. Trong mục tới, ta sẽ so sánh những dự phóng của ta với của họ.


\section{So sánh các dự phóng}

Bảng 3 lấy từ \url{http://modsimpy.com/worldpop} có chứa các kết quả dự phóng từ Cục điều tra Hoa Kỳ và tổ chức DESA Liên hợp Quốc:

\begin{python}
table3 = tables[3]
\end{python}

Có những năm mà một cơ quan nào đó không công bố một kết quả dự phóng, vì vậy vài phần tử trong  \py{table3} chứa giá trị đặc biệt \py{NaN}, viết tắt từ ``not a number" (không phải một trị số).  \py{NaN} thường được dùng để biểu diễn một giá trị khuyết thiếu.

\index{không phải trị số}
\index{NaN}
\index{giá trị khuyết thiếu}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap04-fig02.pdf}}
\caption{Các dự phóng dân số thế giới phát sinh bởi Cục điều tra Hoa Kỳ, Liên hợp Quốc, và mô hình bậc hai ta đang dùng.}
\label{chap04-fig02}
\end{figure}

Pandas cung cấp các hàm xử lý số liệu khuyết thiếu, bao gồm \py{dropna}, để loại bỏ bất kì phần tử trong dãy có chứa \py{NaN}.  Bằng cách dùng \py{dropna}, ta có thể vẽ đồ thị kết quả dự phóng như sau:

\index{Pandas}
\index{dropna}

\begin{python}
def plot_projections(table):
    census_proj = table.census / 1e9
    un_proj = table.un / 1e9
    
    plot(census_proj.dropna(), 'b:', label='US Census')
    plot(un_proj.dropna(), 'g--', label='UN DESA')
\end{python}

Chuỗi định dạng \py{'b:'} thể hiện một đường nét chấm xanh lam; còn \py{g--} thể hiện đường gạch đứt xanh lục.

\index{chuỗi định dạng}
\index{đồ thị}

Ta có thể chạy mô hình cho cùng thời khoảng đó:

\begin{python}
system.t_end = 2100
results = run_simulation(system, update_func_quad)
\end{python}

Rồi so sánh kết quả dự phóng của ta với của họ. Hình~\ref{chap04-fig02} thể hiện kết quả. Các nhà nhân khẩu học đều dự liệu rằng dân số thế giới sẽ tăng chậm hơn là kết quả chúng ta dự phóng, có thể do mô hình của họ được phân chia áp dụng cho từng miền, từng quốc gia, nơi có điều kiện khác nhau, và họ cũng xét đến yếu tố phát triển kinh tế nữa.

\index{nhân khẩu học}

Dù sao, những dự phóng của họ cũng tương tự về mặt định tính với kết quả chúng ta, và giữa các nhà nhân khẩu cũng có kết quả khác nhau như họ khác chúng ta. Vì vậy kết quả mô hình chúng ta, dù đơn giản, song không hẳn là kết quả bỏ đi.

Trước khi tiếp tục, bạn có thể muốn xem tập lệnh cho chương này, \py{chap08.ipynb}, và làm các bài tập. Để biết chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


% ================


\chapter{Giải tích}
\label{chap09}

Ở chương này, ta diễn đạt những mô hình trong các chương trước dưới dạng phương trình sai phân và phương trình vi phân, giải những phương trình này và thiết lập dạng biểu thức toán cho nghiệm. Ta cũng sẽ thảo luận vai trò bổ trợ của giải tích toán học trong mô phỏng.


\section{Liên hệ lặp lại}

Những mô hình dân số trong chương trước và chương này đơn giản ở mức ta không thực sự cần phải chạy mô phỏng, mà có thể giải bằng toán học. Chẳng hạn, ta viết mô hình tăng trưởng hằng số như sau:

\begin{python}
model[t+1] = model[t] + annual_growth
\end{python}

Bằng kí hiệu toán học, ta có thể viết chính mô hình đó dưới dạng:
%
\[ x_{n+1} = x_n + c \]
%
trong đó $x_n$ là dân số trong năm $n$, $x_0$ là dân số ban đầu đã cho, còn $c$ là hằng số tăng trưởng từng năm.  Cách biểu diễn mô hình như thế này được gọi là {\bf liên hệ lặp lại}; xem \url{http://modsimpy.com/recur}.

\index{liên hệ lặp lại}

Đôi khi ta có thể giải được một liên hệ lặp lại bằng cách một phương trình tính trực tiếp $x_n$, ứng với một giá trị đã biết của $n$; nghĩa là không cần phải tính qua những giá trị trung gian từ $x_1$ đến tận $x_{n-1}$.

Trong trường hợp tăng trưởng hằng số, có thể thấy rằng $x_1 = x_0 + c$, và $x_2 = x_1 + c$.  Kết hợp chúng lại, ta được $x_2 = x_0 + 2c$, và tiếp đó $x_3 = x_0 + 3c$. Không quá khó để kết luận được rằng nói chung
%
\[ x_n = x_0 + nc \]
%
Như vậy, nếu ta muốn biết $x_{100}$ mà không cần để tâm tới các giá trị khác, thì ta có thể tính nó bằng một phép nhân và một phép cộng.

Ta cũng có thể viết mô hình tỉ lệ theo dạng liên hệ lặp lại:
%
\[ x_{n+1} = x_n + \alpha x_n \]
%
Hay một cách quy củ hơn như sau:
%
\[ x_{n+1} = x_n (1 + \alpha) \]
%
Bây giờ ta có thể thấy $x_1 = x_0 (1 + \alpha)$, và $x_2 = x_0 (1 + \alpha)^2$, và nói chung 
%
\[ x_n = x_0 (1 + \alpha)^n \]
%
Kết quả này là một {\bf cấp số nhân}; xem \url{http://modsimpy.com/geom}.  Khi $\alpha$ là số dương, thừa số $1+\alpha$ lớn hơn 1, vì vậy các phần tử trong dãy cứ tăng lên không giới hạn.

\index{cấp số nhân}
\index{tăng trưởng bậc hai}

Sau cùng, ta có thể viết mô hình bậc hai như sau:
%
\[ x_{n+1} = x_n + \alpha x_n + \beta x_n^2 \]
%
hay với cách tham số hoá thường gặp như sau:
%
\[ x_{n+1} = x_n + r x_n (1 - x_n / K) \]
%
Không có nghiệm giải tích nào cho phương trình này, song ta có thể xấp xỉ nó bằng một phương trình sai phân rồi giải, đó là việc ta sẽ làm trong mục tiếp sau.


\section{Phương trình vi phân}
\label{diffeq}

Ta hãy lại bắt đầu từ mô hình tăng trưởng hằng số
%
\[ x_{n+1} = x_n + c \]
%
Nếu định nghĩa $\Delta x$ là mức thay đổi của $x$ từ một bước thời gian tới bước tiếp theo, ta có thể viết:
%
\[ \Delta x = x_{n+1} - x_n = c \]
%
Nếu định nghĩa $\Delta t$ là bước thời gian, vốn bằng 1 năm ở ví dụ này, thì ta có thể viết tốc độ thay đổi trong mỗi bước thời gian như sau:
%
\[ \frac{\Delta x}{\Delta t} = c \]
%
Mô hình này là {\bf rời rạc}, nghĩa là nó chỉ được xác định tại những giá trị nguyên của $n$ chứ không phải giữa những giá trị đó. Song trên thực tế, thế giới luôn có người sinh ra về chết đi liên tục mọi thời điểm chứ không phải mỗi năm chỉ một lần, vì vậy một mô hình {\bf liên tục} có thể sẽ sát thực hơn.

\index{rời rạc}
\index{liên tục}
\index{bước thời gian}

Ta có thể làm cho mô hình này liên tục bằng cách viết tốc theo đổi dưới dạng một đạo hàm:
%
\[ \frac{dx}{dt} = c \]
%
Cách biểu diễn mô hình này là một {\bf phương trình vi phân}; xem \url{http://modsimpy.com/diffeq}.

\index{phương trình vi phân}

Ta có thể giải phương trình vi phân này nếu nhân cả hai vế với $dt$:
%
\[ dx = c dt \]
%
Rồi sau đó lấy tích phân hai vế:
%
\[ x(t) = c t + x_0 \]
%
Tương tự, ta có thể viết mô hình tăng trưởng tỉ lệ như sau:
%
\[ \frac{\Delta x}{\Delta t} = \alpha x \]
%
Và dưới dạng phương trình vi phân như sau:
%
\[ \frac{dx}{dt} = \alpha x \]
%
Nếu nhân cả hai vế với $dt$ và chia cho $x$, ta thu được
%
\[ \frac{1}{x}~dx = \alpha~dt \] 
%
Bây giờ ta lấy tích phân hai vế để nhận được:
%
\[ \ln x = \alpha t + K \]
%
trong đó $\ln$ là loga tự nhiên còn $K$ là hằng số tích phân. Lấy hàm mũ cả hai vế\footnote{Hàm mũ có thể viết là  $\exp(x)$ hay $e^x$.  Trong sách này tôi chọn cách thứ nhất vì nó trông giống mã lệnh Python. }, ta có
%
\[ \exp(\ln(x)) = \exp(\alpha t + K) \]
%
vốn có thể viết lại thành
%
\[ x = \exp(\alpha t) \exp(K) \]
%
Vì $K$ là một hằng số tuỳ ý, $\exp(K)$ cũng là một hằng số tuỳ ý, nên ta có thể viết
%
\[ x = C \exp(\alpha t) \]
%
trong đó $C = \exp(K)$.  Có nhiều nghiệm của phương trình vi phân này, với các giá trị khác nhau của $C$.  Nghiệm riêng mà ta muốn là nghiệm có giá trị bằng $x_0$ khi $t=0$. 

Khi $t=0$, $x(t) = C$, do vậy $C = x_0$ và nghiệm ta có là
%
\[ x(t) = x_0 \exp(\alpha t) \]
%
Nếu bạn muốn thấy cách biến đổi đạo hàm trên một cách kĩ lưỡng thì có thể xem video này: \url{http://modsimpy.com/khan1}.

\index{loga}
\index{hàm mũ}
\index{tích phân}
\index{hằng số tích phân}


\section{Giải tích và mô phỏng}

Một khi bạn đã thiết kế nên mô hình, thường có hai cách tiếp tục: mô phỏng và giải tích. Mô phỏng thường tiến hành dưới dạng một chương trình máy tính nhằm mô hình hóa sự thay đổi diễn ra trong hệ thống theo thời gina, như sự sinh ra và chết đi, hay xe di chuyển giữa các địa điểm. Giải tích được tiến hành dưới dạng đại số: nghĩa là biến đổi các biểu thức toán học với các kí hiệu.

\index{giải tích}
\index{đại số}
\index{phép toán với kí hiệu}

Giải tích và mô phỏng có chức năng khác nhau và với những hạn chế riêng. Nói chung, mô phỏng có tính linh động hơn; ta có thể dễ dàng bổ sung hoặc rút bớt từng phần chương trình và kiểm tra nhiều phiên bản của một mô hình, như đã thực hiện ở những ví dụ trước đây.

Tuy nhiên còn vài điều ta có thể làm bằng giải tích mà sẽ khó hơn, thậm chí không thể, bằng mô phỏng:

\begin{itemize}

\item Bằng giải tích, đôi khi ta có thể tính được một cách chính xác và hiệu quả, một giá trị mà dùng mô phỏng thì chỉ tính được xấp xỉ và kém hiệu quả hơn. Chẳng hạn, trên Hình~\ref{chap03-fig05}, có thể thấy rằng mức tăng trưởng ròng tiến tới 0 khi dân số ở gần 14 tỉ, và ta có thể ước tính sức chứa bằng một thuật toán dò tìm số (sẽ đề cập tới sau này). Nhưng bằng cách giải tích ở Mục~\ref{equilibrium}, ta thu được kết quả tổng quát là $K=-\alpha/\beta$.

\item Giải tích thường cho ta những ``lối tắt tính toán", nghĩa là, khả năng nhảy tới tương lai để tính ra trạng thái của hệ thống ở cách nhiều bước thời gian mà không phải tính những trạng thái trung gian.

\index{bước thời gian}

\item Ta có thể dùng giải tích để phát biểu và chứng minh những lý luận khái quát về mô hình; chẳng hạn ta có thể chứng minh rằng những kết quả nhất định sẽ luôn luôn hoặc không bao giờ xảy ra. Bằng mô phỏng, ta có thể thể hiện những ví dụ và đôi khi tìm ra những phản chứng, song sẽ rất khó để chứng minh được điều gì.

\index{chứng minh}

\item Giải tích có thể cho ta những chi tiết sâu trong mô hình và hệ thống mà chúng miêu tả; chẳng hạn đôi khi ta có thể nhận diện những chế độ mà hệ thống có ứng xử định tính riêng, cùng những tham số mấu chốt kiểm soát những ứng xử đó.

\index{chế độ}

\end{itemize}

Khi người ta thấy được những gì mà giải tích có thể làm được, họ đôi khi say sưa với những khả năng đó, tưởng rằng nó có thể cho những khả năng đặc biệt để vén bức màn thế giới sự vật và khám phá quy luật toán học chi phối vũ trụ. Khi họ phân tích một mô hình của hệ thống vật lý, họ nói về ``phép toán đằng sau nó" như thể thế giới chúng ta chỉ là một hình bóng của thees giới những thực thể toán học lý tưởng\footnote{Tôi không bày đặt ra điều này; hãy xem  \url{http://modsimpy.com/plato}.}.

\index{Plato}

Dĩ nhiên điều này không phải là nhảm nhí. Những kí hiệu toán học là một ngôn ngữ được con người tạo ra nhằm mục đích cụ thể, đặc biệt là để làm phép tính đại số. Tương tự, những ngôn ngữ lập trình được thiết kế nhằm mục đích biểu diễn những ý tưởng tính toán và chạy các chương trình.

\index{kí hiệu toán học}
\index{ngôn ngữ lập trình}

Mỗi loại ngôn ngữ nêu trên đều phù hợp với mục đích mà nó được tạo ra nhưng không phù hợp với những mục đích khác. Song chúng thường bổ trợ cho nhau, và một trong những mục tiêu của cuốn sách này là cho thấy chúng được sử dụng kết hợp như thế nào.


\section{Giải tích dùng WolframAlpha}

Cho đến gần đây, hầu hết phép tính giải tích được thực hiện bằng ngòi bút viết trên giấy\footnote{Hoặc ``mài viên đá phấn trên tảng đá đen'' (rubbing the white rock on the black rock), một dòng chữ mà tôi đã đọc được từ Woodie Flowers, người trích theo Stephen Jacobsen.}, một công việc vất vả và dễ phạm sai sót. Một cách khác là dùng máy tính thực hiện phép toán với kí hiệu. Nếu bạn đã sử dụng một dịch vụ kiểu như WolframAlpha, thì chính bạn đã dùng tính toán với kí hiệu rồi đó.

\index{tính toán kí hiệu}
\index{WolframAlpha}

Chẳng hạn, nếu bạn vào trang web \url{https://www.wolframalpha.com/} và gõ 

\begin{python}
df(t) / dt = alpha f(t)
\end{python}

thì WolframAlpha sẽ suy luận rằng \py{f(t)} là một hàm chứa \py{t} còn \py{alpha} là một tham số; truy vấn (``câu lệnh'') này được liệt vào loại ``phương trình vi phân thường tuyến tính bậc nhất", và nghiệm tổng quát được báo lại là:
%
\[ f(t) = c_1 \exp(\alpha t) \]
%
Nếu bạn thêm một phương trình thứ hai để chỉ định điều kiện ban đầu:

\begin{python}
df(t) / dt = alpha f(t),  f(0) = p_0
\end{python}

thì WolframAlpha sẽ báo lại nghiệm riêng:

\[ f(t) = p_0 \exp(\alpha t) \]

WolframAlpha được dựa trên Mathematica, một ngôn ngữ lập trình mạnh mẽ được thiết kế riêng cho mục đích tính toán kí hiệu.

\index{Mathematica}


\section{Giải tích dùng SymPy}

Python có một thư viện tên là SymPy để cung cấp những công cụ tính toán kí hiệu cũng tương tự như Mathematica.  Chúng không dễ dùng như WolframAlpha, song lại có một số lợi thế khác.

\index{SymPy}

Trước khi sử dụng SymPy, ta phải viết lệnh nhập nó.

\index{import (câu lệnh)}
\index{câu lệnh!import}

\begin{python}
from sympy import *
\end{python}

SymPy định nghĩa nhiều hàm, và một vài trong số chúng trùng tên với các hàm định nghĩa bởi \py{modsim} và những thư viện khác mà ta đang sử dụng. Để tránh những xung đột này, tôi khuyên bạn tính toán kí hiệu bằng SymPy trên một trang sổ tính khác.

SymPy định nghĩa một đối tượng \py{Symbol} để biểu diễn các tên biến, tên hàm và kí hiệu toán học khác.

\index{Symbol (đối tượng)}

Hàm \py{symbols} nhận vào một chuỗi rối trả lại các đối tượng \py{Symbol} objects.  Vì vậy, nếu ta chạy câu lệnh này:

\begin{python}
t = symbols('t')
\end{python}

thì Python sẽ hiểu rằng \py{t} là một kí hiệu, chứ không phải một trị số. Bây giờ, nếu ta chạy lệnh

\begin{python}
expr = t + 1
\end{python}

thì Python sẽ không cố thử làm phép tính cộng. Trái lại, nó tạo một \py{Symbol} mới để biểu diễn tổng của \py{t} và \py{1}.  Ta có thể lượng giá tổng này bằng cách dùng \py{subs}, một phương thức thay thế giá trị cho một kí hiệu. Ví dụ sau sẽ thay thế giá trị 2 cho \py{t}:

\begin{python}
expr.subs(t, 2)
\end{python}

Kết quả sẽ là 3.

Các hàm trong SymPy được biểu diễn bởi một loại \py{Symbol} đặc biệt:

\begin{python}
f = Function('f')
\end{python}

Bây giờ nếu ta viết \py{f(t)}, ta sẽ thu được một đối tượng biểu diễn giá trị của một hàm, $f$, tại một giá trị của $t$. Nhưng một lần nữa, SymPy sẽ không cố thử lượng giá nó.


\section{Phương trình vi phân trong SymPy}

SymPy cung cấp một hàm, \py{diff}, có thể tính vi phân một hàm số. Ta có thể áp dụng nó cho hàm số \py{f(t)} như sau:

\index{phương trình vi phân}
\index{SymPy}

\begin{python}
dfdt = diff(f(t), t)
\end{python}

Kết quả là một \py{Symbol} biểu diễn cho đạo hàm của \py{f} theo \py{t}.  Nhưng một lần nữa, SymPy chưa vội cố gắng tính đạo hàm này.

\index{Symbol (đối tượng)}

Để biểu diễn một phương trình vi phân, ta dùng \py{Eq}:

\begin{python}
alpha = symbols('alpha')
eq1 = Eq(dfdt, alpha*f(t))
\end{python}

Kết quả là một đối tượng biểu diễn cho một phương trình, vốn được hiển thị như sau:
%
\[ \frac{d}{d t} f{\left (t \right )} = \alpha f{\left (t \right )} \]
%
Bây giờ ta có thể dùng \py{dsolve} để giải phương trình vi phân này:

\begin{python}
solution_eq = dsolve(eq1)
\end{python}

Kết quả là phương trình
%
\[ f{\left (t \right )} = C_{1} \exp(\alpha t) \]
%
Đây là {\bf nghiệm tổng quát}, trong đó vẫn chứa một hằng số không xác định, $C_1$.  Để thu được {\bf nghiệm riêng} ứng với $f(0) = p_0$, ta thay thế \py{p0} cho \py{C1}.  Trước hết, ta cần tạo thêm hai kí hiệu nữa:

\index{nghiệm tổng quát}
\index{nghiệm riêng}

\begin{python}
C1, p_0 = symbols('C1 p_0')
\end{python}

Bây giờ ta có thể thực hiện thay thế:

\begin{python}
particular = solution_eq.subs(C1, p_0)
\end{python}

Kết quả là
%
\[ f{\left (t \right )} = p_{0} \exp(\alpha t) \]
%
Hàm số này được gọi là {\bf đường cong tăng trưởng theo cấp số nhân}; xem \url{http://modsimpy.com/expo}.

\index{tăng trưởng theo cấp số nhân}


\section{Giải mô hình tăng trưởng bậc hai}

Trong tập lệnh của chương này, bạn sẽ thấy cách sử dụng cùng bộ công cụ để giải mô hình tăng trưởng bậch hai với các tham số $r$ và $K$.  Nghiệm tổng quát là 
%
\[ f{\left (t \right )} = \frac{K \exp(C_{1} K + r t)}{\exp(C_{1} K + r t) - 1} \]
%
Để thu được nghiệm riêng ứng với $f(0) = p_0$, ta ước lượng nghiệm tổng quát tại $t=0$, kết quả cho ta:
%
\[ f(0) = \frac{K \exp(C_{1} K)}{\exp(C_{1} K) - 1} \]
%
Sau đó ta đặt biểu thức này bằng $p_0$ rồi giải tìm ra $C_1$.  Kết quả là:
%
\[ C_1 = \frac{1}{K} \ln{\left (- \frac{p_{0}}{K - p_{0}} \right )} \]
%
Sau cùng, ta thay thế giá trị $C_1$ này vào nghiệm tổng quát, kết quả được:
%
\[ f(t) = \frac{K p_{0} \exp(r t)}{K + p_{0} \exp(r t) - p_{0}} \]
%
Hàm số này được gọi là {\bf đường trong tăng trưởng lôgit}; xem \url{http://modsimpy.com/logistic}.  Trong ngữ cảnh mô hình tăng trưởng, hàm lôgit thường được viết dưới dạng tương đương:
%
\[ f(t) = \frac{K}{1 + A \exp(-rt)} \]
%
trong đó $A = (K - p_0) / p_0$.

Nếu muốn xem cách giải bằng tay phương trình vi phân này, có thể bạn sẽ 
thích video này: \url{http://modsimpy.com/khan2}
\index{tăng trưởng bậc hai}
\index{hàm lôgit}


\section{Tóm tắt}

Bảng dưới đây tóm tắt những kết quả ta thu được đến giờ:

\begin{tabular}{l|l} 
\hline
Loại tăng trưởng         & Rời rạc (phương trình sai phân) \\ 
\hline 
Hằng số & tuyến tính: $x_n = p_0 + \alpha n$  \\ 
 
Tỉ lệ & cấp số nhân: $x_n = p_0(1+\alpha)^n$  \\ 

\end{tabular} 

\begin{tabular}{l|l} 
\hline
        & Liên tục (phương trình vi phân) \\ 
\hline 
Hằng số & tuyến tính: $x(t) = p_0 + \alpha t$ \\ 
 
Tỉ lệ & cấp số nhân: $x(t) = p_0 \exp(\alpha t)$ \\ 
 
Bậc hai & lôgit: $x(t) = K / (1 + A\exp(-rt))$ \\ 
\end{tabular} 

Cái mà tôi gọi là mô hình tăng trưởng hằng số thường được biết đến với tên ``tăng trưởng tuyến tính" vì nghiệm là một đường thẳng. Tương tự, cái mà tôi gọi là tỉ lệ thường được biết đến là ``cấp số nhân", và bậc hai -- thường được biết với tên ``lôgit". Tôi tránh những thuật ngữ thường dùng vì đến bây giờ chúng dựa đến những kết quả mà ta vẫn chưa suy luận ra được.

\index{tăng trưởng tuyến tính}
\index{tăng trưởng cấp số nhân}
\index{tăng trưởng logit}

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap09sympy.ipynb}.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Những nghiên cứu cụ thể}
\label{chap10}

Chương này điểm lại những dạng mẫu tính toán mà ta đã gặ đến giờ cũng như trình bày các bài tập mà bạn có thể áp dụng những dạng mẫu đó.

\section{Công cụ tính toán}

Ở Chương~\ref{chap01}, chúng ta đã dùng Pint để định nghĩa các đơn vị và thực hiện tính toán với đơn vị:

\begin{code}
meter = UNITS.meter
second = UNITS.second
a = 9.8 * meter / second**2
\end{code}

Ở Chương~\ref{chap02} ta đã định nghĩa một đối tượng \py{State} để chứa các biến đại diện cho trạng thái của hệ thống, thường thay đổi theo thời gian:

\begin{code}
bikeshare = State(olin=10, wellesley=2)
\end{code}

Ta đã dùng những toán tử cập nhật như \py{+=} và \py{-=} để thay đổi các biến trạng thái. Ta dùng các câu lệnh \py{print} để hiển thị giá rị của các biến.

Ta đã dùng hàm \py{flip} để mô phỏng các thời điểm tới ngẫu nhiên, và dùng câu lệnh  \py{if} để kiểm tra kết quả.

Ta đã học cách định nghĩa những hàm mới có nhận các tham số:

\begin{code}
def step(p1, p2):
    if flip(p1):
        bike_to_wellesley()
        
    if flip(p2):
        bike_to_olin()
\end{code}

Ta đã dùng một vòng lặp \py{for} với hàm \py{range} để thực thi phần thân của một vòng lặp với số lần định trước.

\begin{code}
for i in range(4):
    step(p1, p2)
\end{code}

Ta đã học cách tạo một đối tượng \py{TimeSeries} rồi dùng nó để lưu giữ giá trị của một biến trạng thái khi nó thay đổi theo thời gian:

\begin{code}
results = TimeSeries()

for i in range(10):
    step(0.3, 0.2)
    results[i] = bikeshare.olin
\end{code}

Ta đã dùng \py{plot} để vẽ đồ thị kết quả, \py{decorate} để ghi tiêu đề trục, và \py{savefig} để lưu hình vẽ.

\begin{code}
plot(results, label='Olin')
decorate(xlabel='Time step (min)', 
         ylabel='Number of bikes')
savefig('chap01-fig01.pdf)
\end{code}

Ở Chương~\ref{chap03} ta đã dùng toán tử so sánh để kiểm tra những điều kiện nhất định và câu lệnh  \py{return} để kết thúc thực thi một hàm.

\begin{code}
def bike_to_olin(state):
    if state.wellesley == 0:
        state.wellesley_empty += 1
        return
    state.wellesley -= 1
    state.olin += 1
\end{code}

Ở Chương~\ref{chap04} ta đã viết một phiên bản của \py{run_simulation} có dùng một lệnh \py{return} để trả lại một giá trị:

\begin{code}
def run_simulation(p1, p2, num_steps):
    state = State(olin=10, wellesley=2, 
                  olin_empty=0, wellesley_empty=0)
                    
    for i in range(num_steps):
        step(state, p1, p2)
        
    return state
\end{code}

Phiên bản này của \py{run_simulation} trả lại giá trị cuối cùng của \py{state}, trong đó chứa các thông số (metrics) mà ta có thể dùng để đo hiệu năng của hệ thống.

Ta đã dùng \py{linspace} để tạo nên một mảng NumPy chứa những giá trị cách đều nhau, và một vòng lặp \py{for} để lặp qua mảng này. Ta đã dùng một \py{SweepSeries} để lưu kết quả từ một loạt (series) các mô phỏng, ánh xạ từ giá trị của mỗi thông số tới giá trị của metric tương ứng.

\begin{code}
p1_array = linspace(0, 1, 11)
sweep = SweepSeries()

for p1 in p1_array:
    state = run_simulation(p1, p2, num_steps)
    sweep[p1] = state.olin_empty
\end{code}

Ở Chương~\ref{chap05}, ta đã dùng Pandas để đọc dữ liệu từ một trang web và lưu kết quả vào trong một \py{DataFrame}.  Ta đã chọn một cột từ \py{DataFrame} này để thu được một dãy \py{Series}.

Ở Chương~\ref{chap06}, ta đã tạo một đối tượng \py{System} có chứa các tham số mô hình, và định nghĩa một phiên bản khác cho \py{run_simulation}:

\begin{code}
def run_simulation(system, update_func):
    results = TimeSeries()
    results[system.t_0] = system.p_0
    
    for t in linrange(system.t_0, system.t_end):
        results[t+1] = update_func(results[t], t, system)
        
    return results
\end{code}

Phiên bản này nhận vào một đối tượng \py{System} làm tham số, và một hàm cập nhật. Thay vì trả lại trạng thái cuối của hệ thống, nó trả lại một \py{TimeSeries} có chứa trạng thái khi thay đổi theo thời gian.

Hàm cập nhật nhận lấy các tham số gồm trạng thái hiện thời của hệ thống, thời gian, và đối tượng \py{System}, rồi trả lại trạng thái mới. Chẳng hạn, sau đây là hàm cập nhật cho mô hình phát triển bậc hai.

\begin{code}
def update_func_quad(pop, t, system):
    net_growth = system.alpha * pop + system.beta * pop**2
    return pop + net_growth
\end{code}

Ở ví dụ này, trạng thái của hệ thống là một con số, \py{pop}.  Sau này ta sẽ thấy những ví dụ mà trạng thái được biểu diễn bởi một đối tượng \py{State} chứa nhiều hơn một biến.

Chương~\ref{chap07} giới thiệu mô hình tăng trưởng bậc hai và Chương~\ref{chap08} sử dụng mô hình đó để phát sinh những dự đoán, nhưng hai chương này đều không giới thiệu thêm công cụ tính toán nào mới cả.

Chương~\ref{chap09} giới thiệu SymPy, mà ta có thể sử dụng để tạo các đối tương \py{Symbol}:

\begin{code}
t, alpha = symbols('t alpha')
f = Function('f')
\end{code}

viết các phương trình vi phân:

\begin{code}
dfdt = diff(f(t), t)
eq1 = Eq(dfdt, alpha*f(t))
\end{code}

rồi giải chúng:

\begin{code}
solution_eq = dsolve(eq1)
\end{code}

Trên đây đã tóm tắt những công cụ tính toán mà ta đã thấy cho đến giờ.


\section{Nhìn bên trong}
\label{dataframe}

Đến giờ ta đã dùng các đối tượng \py{DataFrame} và \py{Series} mà không thực sự hiểu được cách chúng hoạt động ra sao. Ở mục này, ta sẽ điểm lại những gì ta biết đến giờ và đi sâu thêm chút nữa vào các chi tiết.

Mỗi \py{DataFrame} có chứa 3 đối tượng: \py{index} là một dãy các nhãn ghi các hàng, \py{columns} là một dãy các nhãn ghi các cột, và \py{values} là một mảng NumPy chứa dữ liệu.

Với các đối tượng \py{DataFrame} trong chương này, \py{index} có chứa các năm từ 1950 đến 2016, \py{columns} chứa tên của các tổ chức hoặc cá nhân thực hiện dự đoán, còn \py{values} là mảng chứa các trị số dự đoán.

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/dataframe.pdf}}
\caption{Các thành phần hợp nên một \py{DataFrame} và một \py{Series}.}
\label{fig-dataframe}
\end{figure}

Một \py{Series} cũng giống với \py{DataFrame} chỉ có một cột: nó chứa một chuỗi kí tự \py{name} giống như một nhãn tên cột, một chỉ số, và một mảng các giá trị.

Hình~\ref{fig-dataframe} minh họa các phần tử của một \py{DataFrame} và \py{Series}.

\index{type (hàm)}

Để xác dịnh kiểu của những phần tử này, ta có thể sử dụng hàm \py{type} trong Python:

\begin{code}
type(table2)
type(table2.index)
type(table2.columns)
type(table2.values)
\end{code}

Kiểu của \py{table2} là \py{DataFrame}.  Kiểu của \py{table2.index} là \py{Int64Index}, vốn giống như một \py{Series}.

Kiểu của \py{table2.columns} là \py{Index}, vốn có vẻ lạ, vì chỉ số là dãy các nhãn tên hàng. Nhưng dãy ác nhãn tên cột cũng là một kiểu chỉ số vậy.

Kiểu của \py{table2.values} là \py{ndarray}, vốn là kiểu mảng cơ bản được NumPy cung cấp; tên của nó chỉ rằng mảng này có \textit{n} chiều (``n-dimensional"); nghĩa là nó có thể có số chiều tùy ý.

Trong \py{census} hay \py{un}, chỉ số là một đối tượng \py{Int64Index} còn giá trị được lưu vào trong một \py{ndarray}.

Trong thư viện \py{modsim}, các hàm \py{get_first_label} và \py{get_last_label} cho ta một cách đơn giản để truy cập tới chỉ số của một \py{DataFrame} hoặc \py{Series}:

\begin{code}
def get_first_label(series):
    return series.index[0]

def get_last_label(series):
    return series.index[-1]
\end{code}

Viết trong cặp dấu ngoặc, số \py{0} chọn lấy nhãn thứ nhất; còn số \py{-1} chọn lấy nhãn cuối cùng.

Vài đối tượng trong số đã định nghĩa ở \py{modsim} là các phiên bản được chỉnh sửa từ các đối tượng \py{Series}.  Các đối tượng \py{State} và \py{System} là các \py{Series} trong đó các nhãn là những tên biến. Một \py{TimeSeries} là một \py{Series} trong đó các nhãn là thời gian, còn một \py{SweepSeries} là một \py{Series}  trong đó các nhãn là những giá trị tham số.

Không cần thiết phải dịnh nghĩa những đối tượng này; ta có thể làm điều tương tự bằng cách dùng những đối tượng \py{Series}. Nhưng bằng cách đặt tên khác nhau cho chúng đã giúp cho mã lệnh dễ đọc và dễ hiểu hơn, và cũng giúp tránh được những kiểu lỗi nhất định (như bị nhầm lẫn hai loại đối tượng \py{Series}).

Sau này nếu bạn viết các mô phỏng bằng Python, bạn có thể tiếp tục sử dụng những đối tượng trong \py{modsim} khi cần thiết, hoặc có thể trực tiếp sử dụng các đối tượng Pandas.


\section{Một hàng đợi hay là hai?}

Chương này trình bày hai nghiên cứu cụ thể giúp bạn thực hành những gì đã học. Nghiên cứu thứ nhất liên quan tới {\bf lý thuyết hàng đợi}, vốn đi tìm hiểu những hệ thống có thời gian chờ đợi trong các hàng, còn gọi là  những ``hàng đợi".  

Giả sử bạn dang thiết kế khu vực thanh toán của một quầy hàng. Có đủ chỗ trong quầy để bạn bố trí 2 bàn thanh toán và một khu dành cho khách hàng đứng đợi. Bạn có thể bố trí khách xếp hai hàng, mỗi hàng tiến vào một bàn thanh toán, hay chỉ một hàng đi vào cả 2 bàn.

Về lý thuyết, bạn sẽ dự trù rằng một hàng hẳn phải tốt hơn, nhưng nó có những trở ngại rất thực tế: để duy trì dược một hàng, bạn phải đặt thêm rào chắn, và khách hàng có thể cảm thấy bực vì hàng có vẻ dài hơn, dù rằng hàng này sẽ di chuyển nhanh hơn.

Như vậy bạn sẽ muốn kiểm tra xem liệu một hàng có thực sự nhanh hơn không và nếu có thì nhanh hơn bao nhiêu. Mô phỏng sẽ giúp ta giải đáp điều này.

\begin{figure}
\centerline{\includegraphics[width=4.5in]{figs/queue.pdf}}
\caption{Một hàng đợi với một bàn phục vụ (trái), một hàng đợi với hai bàn phục vụ (giữa), hai hàng đợi với hai bàn phục vụ (phải).}
\label{fig-queue}
\end{figure}

Hình~\ref{fig-queue} cho thấy ba kịch bản mà ta cần xét đến. Như đã làm với mô hình chung xe, ta sẽ giả sử rằng một khách hàng có khả năng đồng đều xuất hiện vào bất kì bước thời gian nào. Tôi sẽ kí hiệu xác suất này bằng chữ cái Hi Lạp lambda, $\lambda$, hoặc bằng tên biến \py{lam}.  Trị số của $\lambda$ có lẽ thay đổi ngày qua ngày, bởi vậy ta sẽ phải xét một khoảng các xác suất.

Dựa vào số liệu từ những cửa hàng khác, bạn biết rằng trung bình mỗi khách hàng phải mất 5 phút để chờ đến khi thanh toán xong. Nhưng thời gian thanh toán này lại khác nhau: đa số khách hàng mất ít hơn 5 phút, nhưng có người lại mất nhiều hơn 5 phút rất nhiều. Một cách dơn giản để mô hình hóa sự biến đổi này là giả sử rằng khi một khách hàng thanh toán, luôn có cùng xác suất để thanh toán xong xuôi ở bước thời gian kế tiếp, bất kể họ đã mất bao nhiêu thời gian từ lúc xếp hàng đến giờ. Tôi sẽ kí hiệu xác suất này bằng chữ cái Hi Lạp mu, $\mu$, hay là tên biến \py{mu}.

Nếu ta chọn $\mu=1/5$ mỗi phút, thì thời gian trung bình của mỗi lượt thanh toán sẽ là 5 phút; điều này thống nhất với số liệu ta có. Hầu hết mọi người chỉ mất ít hơn 5 phút, nhưng vài người mất thời gian lâu hơn nhiều, vốn có lẽ không phải một mô hình tệ đối với sự phân bố (thời gian thanh toán) thực tế trong quầy.

Bây giờ ta đã sẵn sàng bắt đầu. Trong thư mục mã lệnh kèm cuốn sách này, bạn sẽ thấy một cuốn sổ có tên \py{queue.ipynb} trong đó chứa mã lệnh giúp bạn bắt đầu cùng những hướng dẫn nữa. 

Như thường lệ, bạn nên luyện tập cách phát triển tăng dần: mỗi lần chỉ viết một hai dòng lệnh chứ không hơn, và vừa viết vừa thử chạy chương trình!



\section{Dự đoán số lượng cá hồi}

Hàng năm, Ủy ban đánh giá cá hồi Đại Tây Dương (Atlantic Salmon Assessment Committee) của Hoa Kỳ đều báo cáo con số ước tính số cá hồi trên biển và trong sông ở Đông bắc Hoa Kỳ. Những báo cáo này rất hữu ích để giám sát những thay đổi về số lượng cá, nhưng nói chung không bao gồm các con số dự đoán.

Mục tiêu của nghiên cứu cụ thể này nhằm mô phỏng thay đổi hằng năm của số cá hồi, đánh giá xem những thay đổi này có dễ dự đoán không, và ước tính xác suất để một số cá cụ thể sẽ tăng hay giảm trong vòng 10 năm tới.

Lấy ví dụ, tôi dùng dữ liệu từ trang 18 của cuốn báo cáo năm 2017, vốn cung cấp những số cá ước tính cho các dòng sông Narraguagus và Sheepscot ở bang Maine.

Trong thư mục mã lệnh kèm cuốn sách này, bạn sẽ thấy một cuốn sổ có tên \py{salmon.ipynb} trong đó chứa mã lệnh giúp bạn bắt đầu cùng những hướng dẫn nữa. 

Bạn nên theo hướng dẫn mà tôi đã gợi ý; nếu bạn muốn thử điều gì khác, hãy làm nó!


\section{Sự tăng trưởng của cây xanh}

Nghiên cứu cụ thể này được dựa theo ``Height-Age Curves for Planted Stands of Douglas Fir, with Adjustments for Density" (tạm dịch: các đường cong biểu hiện chiều cao-tuổi cây thông Douglas được gieo trồng, có điều chỉnh theo mật độ cây), một bài báo của nhóm tác giả Flewelling, Collier, Gonyea, Marshall, và Turnblom, xem link \url{http://modsimpy.com/trees}.

Bài báo cho ta các ``đường cong chỉ số theo địa điểm", đây là những đường cong đồ thị biểu diên chiều cao ước tính của cây cao nhất trong một hàng cây thông Douglas như một hàm tuổi cây, đối với hàng trồng các cây cùng tuổi.

Tùy thuộc vào chất lượng của hàng ở từng địa điểm, cây có thể mọc nhanh hơn hoặc chậm hơn. Như vậy, mỗi đường đồ thị được nhận diện bởi một ``chỉ số địa điểm" vốn phản ánh chất lượng của địa điểm này.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/trees-fig01.pdf}}
\caption{Đồ thị chỉ số địa điểm cho sự sinh trưởng của cây.}
\label{trees-fig01}
\end{figure}

Hình~\ref{trees-fig01} thể hiện các đường đồ thị cho ba chỉ số địa điểm khác nhau. Mục đích của nghiên cứu cụ thể này nhằm giải thích hình dạng của các đường cong này; nghĩa là tại sao cây lại sinh trưởng như vậy.

Để bắt đầu, ta hãy giả sử rằng khả năng cây trồng tăng trọng thì bị hạn chế bởi diện tích nó phơi ra ngoài ánh mặt trời, còn tốc độ tăng trưởng (về khối lượng) thì tỉ lệ thuận với diện tích đó. Như vậy, ta có thể viết:
%
$ m_{n+1} = m_n + \alpha A$
%
trong đó $m_n$ là khối lượng cây tại bước thời gian $n$, $A$ là diện tích phơi nắng, còn $\alpha$ là một hệ số sinh trưởng mà ta chưa biết.

Để đi từ $m$ đến $A$, tôi sẽ giả sử thêm rằng khối lượng thì tỉ lệ với chiều cao lũy thừa một số mũ chưa biết khác:
%
$ m = \beta h^D $
%
trong đó $h$ là chiều cao, $\beta$ là một hằng số tỉ lệ chưa biết, và $D$ là đại lượng liên hệ giữa chiều cao và khối lượng. Để bắt đầu, tôi sẽ giả sử $D=3$, và sẽ còn kiểm tra lại giả sử này sau.

Cuối cùng, tôi sẽ giả sử rằng diện tích thì tỉ lệ với bình phương của chiều cao:

$ A = \gamma h^2$

Tôi tính chiều cao theo feet, và chọn các đơn vị cho khối lượng và diện tích sao cho $\beta=1$ và $\gamma=1$. Tổng hợp mọi thứ lại, ta có thể viết được một phương trình sai phân cho chiều cao:

$ h_{n+1}^D = h_n^D + \alpha h_n^2 $

Nghiệm của phương trình này hóa ra lại gần như một đường thẳng, vậy là mô hình không tồi để biểu diễn đường cong tăng trưởng. Nhưng mô hình lại cho cây lớn lên mãi, và ta biết điều này không đúng. Khi cây càng cao thì càng khó để đưa nước và dưỡng chất lên dưới ảnh hưởng của trọng lực, và do vậy sự tăng trưởng cũng chậm lại.

Ta có thể mô hình hóa hiệu ứng này bằng cách thêm một hệ số vào mô hình tương tự như ta đã thấy ở mô hình logit về tăng trưởng dân số. Thay vì giả sử rằng:

$ m_{n+1} = m_n + \alpha A $ 

Hãy giả sử rằng

$ m_{n+1} = m_n + \alpha A (1 - h / K) $

trong đó $K$ tương tự như sức chứa trong mô hình logit. Khi $h$ tiến đến $K$, thừa số $(1 - h/K)$ sẽ tiến đến 0, dẫn đến mức tăng trưởng bị chậm đi.

Trong thư mục mã lệnh kèm cuốn sách này, bạn sẽ thấy một cuốn sổ có tên \py{trees.ipynb} trong đó lập trình cho cả 2 mô hình và dùng chúng để khớp với dữ liệu. Không có bài tập nào cho nghiên cứu cụ thể này cả. Nghiên cứu chỉ là ví dụ cho thấy bạn có thể làm gì với những công cụ ta học đến giờ, và hé lộ những gì ta có thể làm với công cụ này trong vài chương sắp tới.




\chapter{Dịch tễ học}
\label{chap11}

Trong chương này, chúng tôi phát triển một mô hình dịch bệnh lây lan trong một vùng dân cư dễ lây nhiễm, và sử dụng mô hình để đánh giá mức độ hiệu quả những biện pháp ngăn chặn.

\index{bệnh dịch}

Trình bày của tôi về mô hình SIR trong vài chương sắp tới được dựa theo bài báo xuất sắc của David Smith và Lang Moore\footnote{Smith and Moore, ``The SIR Model for Spread of Disease," Journal of Online Mathematics and its Applications, December 2001, at \url{http://modsimpy.com/sir}.}.

\index{SIR (mô hình)}


\section{Bệnh dịch tân sinh viên}

Hằng năm ở trường Olin College, có khoảng 90 tân sinh viên tới kí túc xá từ khắp nơi trên thế giới. Hầu hết khi mới tới, họ đều khỏe mạnh và vui vẻ, song ít nhất một người mang đến một loại bệnh lây nhiễm nào đó. Vài tuần sau, chắc bạn cũng đoán được, một phần trong số sinh viên bị mắc phải chứng ``bệnh dịch tân sinh viên".

\index{Olin College}
\index{bệnh dịch tân sinh viên}
\index{Kermack-McKendrick}

Ở chương này, chúng tôi giới thiệu một mô hình nổi tiếng về bệnh dịch lây nhiễm, mô hình Kermack-McKendrick, và dùng nó để giải thích sự tiến triển bệnh dịch trong suốt một học kì, dự đoán ảnh hưởng của những biện pháp can thiệp khả dĩ (như miễn dịch) và thiết kế chương trình can thiệp hiệu quả nhất.

\index{bệnh}
\index{lây nhiễm}
\index{thiết kế}

Đến giờ ta đã thực hiện mô phỏng của riêng mình; nghĩa là ta chọn hệ thống vật thể, nhận diện những yếu tố dường như quan trọng, và ra quyết định về cách biểu diễn chúng. Ở chương này, ta bắt đầu bằng một mô hình sẵn có và phân tích nó theo chiều hướng ngược lại. Trong quá trình thực hiện, ta xét những quyết định mô hình gắn với nó và nhận diện những khả năng cùng hạn chế của mô hình này.


\section{Mô hình SIR}

Mô hình Kermack-McKendrick là một phiên bản của {\bf mô hình SIR}. Sở dĩ có tên gọi như vậy vì nó đề cập đến ba nhóm người:

\begin{itemize}

\item {\bf S}: Những người dễ tổn thương, tiếng Anh gọi là ``susceptible"; họ có khả năng bị nhiễm bệnh khi tiếp xúc với những ai mang bệnh.

\item {\bf I}: Những người lây nhiễm, tiếng Anh gọi là ``infectious"; họ có khả năng truyền bệnh nếu họ tiếp xúc với người dễ tổn thương.

\item {\bf R}: Những người đã hồi phục, tiếng Anh gọi là ``recovered".

\end{itemize}

Trong dạng cơ bản của mô hình, những người đã hồi phục thì được coi là miễn nhiễm. Đây là một mô hình hợp lý với vài căn bệnh nhưng lại không phù hợp với các căn bệnh khác; cho nên điều này được xếp vào danh sách những giả sử để sau này xem xét.

Hãy cùng xem số người mỗi loại biến đổi ra sao theo thời gian. Chẳng hạn, ta biết rằng những người mắc bệnh trung bình trong khoảng thời gian 4 ngày. Nếu có 100 người có bệnh tại một thời điểm nào đó, và ta bỏ qua thời điểm cụ thể khi họ bắt đầu mắc thì ta sẽ dự trù rằng cứ trong 4 người sẽ có 1 người hồi phục vào bất kì ngày nào. 

Nói cách khác, nếu thời gian giữa các lần hòi phục là là 4 ngày thì tốc độ hồi phục là khoảng 0.25 ca mỗi ngày. Ta sẽ kí hiệu đại lượng này bằng chữ cái Hy Lạp gamma,  $\gamma$. Nếu số người trong tổng thể dân cư là $N$, và tỉ lệ hiện bị nhiễm là $i$, thì số ca hồi phục mà ta dự trù mỗi ngày sẽ là $\gamma i N$.

\index{tốc độ hồi phục}

Bây giờ hãy hình dung số ca nhiễm mới. Coi như ta biết rằng mỗi người tổn thương tới tiếp xúc với 1 người trong khoảng thời gian trung bình 3 ngày, do đó họ sẽ bị nhiễm  bệnh nếu người kia đã bị nhiễm. Ta sẽ kí hiệu tốc độ tiếp xúc này bằng chữ cái Hy Lạp beta, $\beta$.

\index{tốc độ lây nhiễm}

Có lẽ sẽ không hợp lý nếu giả thiết rằng ta biết trước $\beta$, song về sau ta sẽ thấy cách ước tính nó dựa trên số liệu từ những đợt bùng phát dịch trước đây.

Nếu $s$ là tỉ lệ dân số dễ tổn thương, $s N$ là số người dễ tổn thương, thì $\beta s N$ là số lượt tiếp xúc mỗi ngày, và $\beta s i N$ là số những tiếp xúc trong đó người kia đã nhiễm bệnh.

\index{dễ tổn thương}

Nói tóm lại:

\begin{itemize}

\item Số ca hồi phục ta dự liệu mỗi ngày là $\gamma i N$; đem chia cho $N$ được tỉ lệ dân số phục hồi mỗi ngày, chính là $\gamma i$.

\item Số ca nhiễm mới mỗi ngày là $\beta s i N$; đem chia cho $N$ được tỉ lệ dân số nhiễm bệnh mỗi ngày, chính là $\beta s i$.

\end{itemize}

Mô hình này giả thiết rằng dân số khép kín; nghĩa là không ai mới đến hoặc rời khỏi khu dân cư, và vì vậy số người $N$, là không đổi.


\section{Các phương trình SIR}
\label{sireqn}

Nếu coi thời gian là một đại lượng liên tục thì ta có thể viết các phương trình vi phân mô tả tốc độ thay đổi của $s$, $i$, và $r$ (trong đó $r$ là tỉ lệ dân số đã hồi phục):
%
\begin{align*}
\frac{ds}{dt} &= -\beta s i \\
\frac{di}{dt} &= \beta s i - \gamma i\\
\frac{dr}{dt} &= \gamma i
\end{align*}
%
Để tránh bị chồng chéo, khi viết $s$ tôi đã ngụ ý đó là một hàm theo thời gian, $s(t)$, và tương tự như vậy với $i$ và $r$.
\index{phương trình vi phân}

Các mô hình SIR là ví dụ về {\bf mô hình khoang chứa}. Sở dĩ có tên gọi như vậy vì chúng chia thế giới thực thành các ngăn riêng biệt, cũng như mô tả sự trao đổi giữa các ngăn. Những ngăn này cũng được gọi là {\bf kho} và sự chuyển đổi giữa chúng được gọi là {\bf luồng}.

\index{mô hình khoang chứa}
\index{kho}
\index{luồng}
\index{biểu đồ kho và luồng}

Ở ví dụ này, ta có 3 ``kho'' --- nhóm tổn thương, nhóm nhiễm bệnh, và nhóm phục hồi --- cùng với 2 luồng --- nhiễm mới và phục hồi. Các mô hình khoang chứa thường được biểu diễn bằng sơ đồ kho và luồng (xem \url{http://modsimpy.com/stock}).
Hình~\ref{stock_flow1} thể hiện sơ đồ kho và luồng cho một mô hình SIR.

\begin{figure}
% first version was on YUML
% https://yuml.me/edit/3de9c163
% wget https://yuml.me/2389d485.pdf; mv 2389d485.pdf figs/stock_flow1.pdf
% current version uses lodraw
\centerline{\includegraphics[width=4in]{figs/stock_flow1.pdf}}
\caption{Sơ đồ kho và luồng cho một mô hình SIR.}
\label{stock_flow1}
\end{figure}

Các kho được biểu diễn bằng hình chữ nhật, và luồng bằng những mũi tên. Khí hiệu nằm giữa mũi tên thể hiện một cái van để điều tiết tốc độ luồng chảy; sơ đồ cũng cho thấy những tham số kiểm soát các van này.


\section{Thực hiện}

Với một hệ thống vật lí cho trước, có rất nhiều mô hình khả dĩ; cũng như với một mô hình cho trước sẽ có nhiều cách biểu diễn nó. Chẳng hạn, ta có thể biểu diễn một mô hình SIR như một sơ đồ kho và luồng, như một hệ phương trình vi phân, hoặc như một chương trình Python. Quá trình biểu diễn một mô hình dưới những hình thức này được gọi là {\bf thực hiện}. Ở mục này, ta thực hiện mô hình SIR bằng Python.

\index{thực hiện}

Tôi sẽ biểu diễn trạng thái ban đầu của hệ thống bằng một đối tượng \py{State} cùng những biến trạng thái \py{S}, \py{I}, và \py{R}; chúng thể hiện tỉ lệ của dân số trong từng thành phần.

\index{System (đối tượng)}
\index{State (đối tượng)}
\index{biến trạng thái}

Ta có thể khởi tạo đối tượng \py{State} với {\em số} người thuộc từng thành phần, nếu coi như có một sinh viên bị nhiễm bệnh trong một lớn gồm 90 người:

\begin{python}
init = State(S=89, I=1, R=0)
\end{python}

Và rồi chuyển đổi những con số này về tỉ lệ bằng cách chia cho tổng số:

\begin{python}
init /= sum(init)
\end{python}

Bây giờ ta hãy coi như đã biết thời gian giữa các sự tiếp xúc và thời gian giữa các ca phục hồi:

\begin{python}
tc = 3             # thời gian giữa các tiếp xúc, tính theo ngày
tr = 4             # thời gian hồi phục tính theo ngày
\end{python}

Ta có thể dùng chúng để tính ra các tham số mô hình:

\begin{python}
beta = 1 / tc      # tốc độ tiếp xúc, mỗi ngày
gamma = 1 / tr     # tốc độ hồi phục, mỗi ngày
\end{python}

Bây giờ ta cần một đối tượng \py{System} để lưu trữ các tham số và điều kiện đầu. Hàm sau đây nhận vào những tham số hiệ thống dưới dạng tham số hàm rồi trả lại một đối tượng \py{System} mới:

\index{\py{make_system}}

\begin{python}
def make_system(beta, gamma):
    init = State(S=89, I=1, R=0)
    init /= sum(init)

    t0 = 0
    t_end = 7 * 14

    return System(init=init, t0=t0, t_end=t_end,
                  beta=beta, gamma=gamma)
\end{python}

Giá trị mặc định cho \py{t_end} là 14 tuần, bằng khoảng một học kì.


\section{Hàm cập nhật}

Tai bất kì thời điểm nào, trạng thái của hệ thống được biểu diễn bởi một đối tượng \py{State} với ba biến số, \py{S}, \py{I} và \py{R}.  Vì vậy, tôi sẽ định nghĩa một hàm cập nhật để nhận các tham số gồm một đối tượng \py{State}, thời điểm hiện tại, và một đối tượng \py{System}:

\index{cập nhật (hàm)}
\index{hàm!cập nhật}
\index{bước thời gian}

\begin{python}
def update_func(state, t, system):
    s, i, r = state

    infected = system.beta * i * s    
    recovered = system.gamma * i
    
    s -= infected
    i += infected - recovered
    r += recovered
    
    return State(S=s, I=i, R=r)
\end{python}

Dòng thứ nhất sử dụng một đặc điểm mà tôi chưa từng thấy, {\bf lệnh gán bội}.  Ở vế phải là một đối tượng \py{State} gồm 3 giá trị. Ở vế trái là một dãy gồm 3 tên biến. Lệnh gán bội này thực hiện đúng việc ta mong muốn: nó gán 3 giá trị từ đối tượng \py{State} vào 3 biến theo đúng thứ tự.

Các biến cục bộ, \py{s}, \py{i} và \py{r}, được viết chữ thường để phân biệt với chữ in là các biến trạng thái, \py{S}, \py{I} và \py{R}.

\index{State (đối tượng)}
\index{biến trạng thái}
\index{biến cục bộ}

Hàm cập nhật tính ra \py{infected} và \py{recovered} dưới dạng tỉ lệ của tổng thể, rồi cập nhật \py{s}, \py{i} và \py{r}.  Giá trị trả lại là một \py{State} có chứa các trị số đã cập nhật.

\index{giá trị trả lại}

Khi ta gọi \py{update_func} như sau:

\begin{python}
state = update_func(init, 0, system)
\end{python}

thì kết quả sẽ là một đối tượng \py{State} với các giá trị:

\begin{tabular}{lr}
 & {\bf \sf value} \\ 
\hline 
{\bf \sf S} & 0.985388 \\ 
{\bf \sf I} & 0.011865 \\ 
{\bf \sf R} & 0.002747 \\ 
\end{tabular} 

Bạn có thể phát hiện thấy rằng phiên bản này của \py{update_func} không dùng đến một trong các tham biến của nó là \py{t}.  Dù sao tôi vẫn giữ lại tham biến này mà không bỏ đi, vì đôi lúc hàm cập nhật còn phụ thuộc vào thời gian, và sẽ tiện lợi hơn nếu về mặt hình thức, hàm có những tham biến như nhau, bất kể chúng có được dùng tới hay không.



\section{Chạy mô phỏng}

Bây giờ, ta có thể mô phỏng mô hình qua một dãy thời điểm:

\index{bước thời gian}

\begin{python}
def run_simulation(system, update_func):
    state = system.init

    for t in linrange(system.t0, system.t_end):
        state = update_func(state, t, system)

    return state
\end{python}

Các tham số của \py{run_simulation} bao gồm đối tượng \py{System} và hàm cập nhật. Đối tượng \py{System} cung cấp các tham số, điều kiện ban đầu, và những giá trị \py{t0} và \py{t_end}.

\index{\py{run_simulation}}

Nét bao quát của hàm này chắc bạn thấy quen thuộc; nó giống như hàm ta đã dùng cho mô hình dân số trong Mục~\ref{nowwithsystem}.

Bây giờ ta có thể gọi \py{run_simulation} như sau:

\begin{python}
system = make_system(beta, gamma)
final_state = run_simulation(system, update_func)
\end{python}

Kết quả là trạng thái cuối cùng của hệ thống:

\begin{tabular}{lr}
 & {\bf \sf value} \\ 
\hline 
{\bf \sf S} & 0.520819 \\ 
{\bf \sf I} & 0.000676 \\ 
{\bf \sf R} & 0.478505 \\ 
\end{tabular} 

Kết quả này cho thấy rằng sau 14 tuần (98 ngày), có khoảng 52\% dân số còn bị tổn thương, nghĩa là họ chưa từng bị nhiễm, dưới 1\% hiện đang bị nhiễm, và 48\% đã phục hồi, nghĩa là trong quá khứ có lúc họ đã bị nhiễm.


\section{Thu thập kết quả}

Phiên bản trước của \py{run_simulation} chỉ trả lại trạng thái cuối cùng, nhưng ta có thể muốn xem trạng thái diễn biến ra sao. Ta sẽ xét hai cách thực hiện: đầu tiên là dùng ba đối tượng \py{TimeSeries}, tiếp theo là dùng một đối tượng mới có tên \py{TimeFrame}.

\index{TimeFrame (đối tượng)}
\index{TimeSeries (đối tượng)}

Sau đây là phiên bản thứ nhất:

\begin{python}
def run_simulation(system, update_func):
    S = TimeSeries()
    I = TimeSeries()
    R = TimeSeries()

    state = system.init
    t0 = system.t0
    S[t0], I[t0], R[t0] = state
    
    for t in linrange(system.t0, system.t_end):
        state = update_func(state, t, system)
        S[t+1], I[t+1], R[t+1] = state
    
    return S, I, R
\end{python}

Đầu tiên, ta tạo ra các đối tượng \py{TimeSeries} để lưu trữ kết quả. Chú ý rằng các biến \py{S}, \py{I}, và \py{R} giờ đây là những đối tượng \py{TimeSeries}.

Tiếp theo, ta khởi tạo \py{state}, \py{t0}, cùng những phần tử đầu tiên của \py{S}, \py{I} và \py{R}.  

Bên trong vòng lặp, ta dùng \py{update_func} để tính toán trạng thái của hệ thống tại bước thời gian tiếp theo, rồi dùng lệnh gán bội để gỡ các giá trị của \py{state}, gán từng giá trị cho \py{TimeSeries} tương ứng.

\index{bước thời gian}

Ở cuối hàm này, ta trả lại những giá trị \py{S}, \py{I}, và \py{R}.  Đây là ví dụ đâu tiên ta thấy một hàm trả lại nhiều giá trị.

Bây giờ ta có thể chạy hàm này như sau:

\begin{python}
system = make_system(beta, gamma)
S, I, R = run_simulation(system, update_func)
\end{python}

Ta sẽ dùng các hàm sau để vẽ đồ thị kết quả:

\begin{python}
def plot_results(S, I, R):
    plot(S, '--', label='Tổn thương')
    plot(I, '-', label='Nhiễm')
    plot(R, ':', label='Kháng')
    decorate(xlabel='T.gian (ngày)',
             ylabel='Tỉ lệ dân số')
\end{python}

\index{vẽ đồ thị}
\index{trang trí}

Và rồi chạy mã lệnh như sau:

\begin{python}
plot_results(S, I, R)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig01.pdf}}
\caption{Các chuỗi thời gian \py{S}, \py{I}, và \py{R} trong khoảng thời gian 98 ngày.}
\label{chap05-fig01}
\end{figure}

Hình~\ref{chap05-fig01} cho thấy kết quả. Lưu ý rằng sẽ mất khoảng 3 tuần (21 ngày) để sự bùng phát dịch bệnh diễn ra, và khoảng 6 tuần (42 ngày) trước khi nó đạt đỉnh. Tỉ lệ của dân số nhiễm bệnh chưa bao giờ quá cao, song nó sẽ tích lũy lại. Tổng cộng, có đến gần nửa dân số bị bệnh.


\section{Đến lượt dùng TimeFrame}
\label{timeframe}

Nếu số các biến trạng thái còn ít thì việc dùng những đối tượng  \py{TimeSeries} riêng biệt có thể không quá tệ. Nhưng cách tốt hơn là dùng một \py{TimeFrame}, vốn là một đối tượng khác được định nghĩa trong thư viện \py{modsim}.

\index{TimeFrame (đối tượng)}
\index{DataFrame (đối tượng)}

Một \py{TimeFrame} gần như giống hệt một \py{DataFrame}, vốn ta đã dùng ở Mục~\ref{worldpopdata}, nhưng có vài điểm mà tôi đã điều chỉnh để nó phù hợp với mục đích của ta.

Sau đây là phiên bản \py{run_simulation} được viết gọn hơn khi dùng \py{TimeFrame}:

\begin{python}
def run_simulation(system, update_func):
    frame = TimeFrame(columns=system.init.index)
    frame.row[system.t0] = system.init
    
    for t in linrange(system.t0, system.t_end):
        frame.row[t+1] = update_func(frame.row[t], system)
    
    return frame
\end{python}

Dòng đầu tiên tạo ra một \py{TimeFrame} trống với mỗi cột dành cho từng biến trạng thái. Tiếp theo, trước khi bắt đầu vòng lặp, ta lưu điều kiện ban đầu vào trong \py{TimeFrame} tại \py{t0}.  Dựa theo cách ta đã làm với đối tượng \py{TimeSeries}, có lẽ bạn muốn viết:

\begin{python}
frame[system.t0] = system.init
\end{python}

Nhưng khi dùng toán tử ngoặc vuông cho một \py{TimeFrame} hay \py{DataFrame}, nó sẽ lụa chọn một cột chứ không phải một hàng. Chẳng hạn, để chọn một cột, ta có thể viết:

\index{ngoặc vuông (toán tử)}
\index{toán tử~ngoặc vuông}

\begin{python}
frame['S']
\end{python}

Để chọn một hàng, ta phải dùng \py{row}, như thế này:

\index{row}

\begin{python}
frame.row[system.t0] = system.init
\end{python}

Vì giá trị ở vế phải là một \py{State}, phép gán đem khớp chỉ số của \py{State} với cột của \py{TimeFrame}; nghĩa là nó gán giá trị \py{S} từ \py{system.init} vào cột \py{S} của \py{frame}, và tương tự đối với \py{I} và \py{R}.

\index{phép gán}

Ta có thể dùng chính đặc điểm này để viết các vòng lặp một cách gọn gàng hơn, đem gán \py{State} nhận được từ \py{update_func} trực tiếp vào hàng tiếp theo của \py{frame}.
  
\index{biến hệ thống}

Sau cùng, ta trả lại \py{frame}. Ta có thể gọi phiên bản này của \py{run_simulation} như sau:

\begin{python}
results = run_simulation(system, update_func)
\end{python}

Và vẽ đồ thị kết quả như sau:

\begin{python}
plot_results(results.S, results.I, results.R)
\end{python}

Cũng giống với một \py{DataFrame}, ta có thể dùng toán tử dấu chấm để chọn các cột từ một \py{TimeFrame}.

\index{dấu chấm (toán tử)}
\index{toán tử!dấu chấm}

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap11.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Tối ưu hóa}
\label{chap12}

Ở chương trước, tôi đã trình bày mô hình SIR về bệnh truyền nhiễm và dùng nó để mô hình hóa bệnh dịch tân sinh viên tại Olin. Ở chương này, ta sẽ xét những thang đo hay metric được thiết kế để đánh giá hiệu ứng của dịch bệnh và những can thiệp vốn có thể làm giảm những  hiệu ứng tiêu cực.


\section{Metric}
\label{metrics2}

Khi ta vẽ đồ thị một chuỗi số liệu thời gian, ta sẽ có được một cái nhìn  tổng thể những gì đã xảy ra khi mô hình chạy. Nhưng thường a muốn kết tinh lại thành vài con số để tóm tắt kết quả. Những số thống kê tóm tắt đó là {\bf metric}, như ta đã thấy ở Mục~\ref{metrics}.

\index{metric}

Trong mô hình SIR, có thể ta muốn biết thời gian đến tận đỉnh của sự lan tràn dịch bệnh, số người bị bệnh tại đỉnh dịch, số sinh viên vẫn còn bệnh vào cuối kì, hay tổng số sinh viên bị bệnh tại thời điểm bất kì.

Lấy ví dụ, tôi sẽ tập trung vào cái cuối cùng --- tổng số sinh viên bị bệnh --- và ta sẽ xét những sự can thiệp dự kiến để giảm thiểu nó.

Khi một người bị nhiễm bệnh, họ chuyển từ  \py{S} sang \py{I}, bởi vậy ta có thể tìm số ca nhiễm bằng cách tính hiệu số \py{S} tại các thời điểm đầu và cuối:

\begin{python}
def calc_total_infected(results, system):
    return results.S[system.t0] - results.S[system.t_end]
\end{python}

Ở sổ tính cho chương này, bạn sẽ có cơ hội viết các hàm tính những metric khác. Hai hàm mà bạn có thể thấy hữu ích là \py{max} và \py{idxmax}.

\index{max}
\index{idxmax}
 
Nếu bạn có một \py{Series} tên là \py{S}, bạn có thể tìm giá trị lớn nhất của dãy này như sau:

\begin{python}
largest_value = S.max()
\end{python}

Và nhãn của giá trị lớn nhất như sau:

\begin{python}
time_of_largest_value = S.idxmax()
\end{python}

Nếu \py{Series} là một chuỗi thời gian \py{TimeSeries}, thì nhãn mà bạn lấy từ \py{idxmax} sẽ là một thời điểm hoặc ngày tháng. Bạn có thể đọc thêm về những hàm  này trong tài liệu  \py{Series} tại \url{http://modsimpy.com/series}.

\index{Series}


\section{Miễn dịch}

Những mô hình như thế này rất hữu ích để kiểm tra các kịch bản ``điều gì sẽ xảy ra nếu...?". Lấy ví dụ, ta sẽ xét ảnh hưởng của sự miễn dịch.

\index{miễn dịch}
\index{vắc-xin}
\index{Bệnh dịch tân sinh viên}

Giả sử có một loại vắc-xin khiến cho sinh viên trở nên miễn nhiễm với dịch tân sinh viên này. Bạn cần phải chỉnh sửa mô hình ra sao để nắm bắt được hiệu ứng như vậy?

Một lựa chọn là coi miễn dịch như một cách đi tắt từ người bị nhiễm tới hồi phục mà không thông qua lây nhiễm. Ta có thể thực hiện đặc điểm này như sau:

\begin{python}
def add_immunization(system, fraction):
    system.init.S -= fraction
    system.init.R += fraction
\end{python}

\py{add_immunization} chuyển một phần cho trước của tổng thể từ \py{S} sang \py{R}.  Nếu ta giả sử như 10\% số sinh viên được tiêm vắc-xin tại lúc bắt đầu học kì, và vắc-xin hiệu nghiệm 100\%, thì ta có thể mô phỏng hiệu ứng này như sau:

\begin{python}
system2 = make_system(beta, gamma)
add_immunization(system2, 0.1)
results2 = run_simulation(system2, update_func)
\end{python}

Để so sánh, ta có thể chạy cùng mô hình không có miễn dịch và vẽ biểu đồ kết quả. Hình ~\ref{chap05-fig02} cho thấy \py{S} như một hàm theo thời gian, có và không có sự miễn dịch.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig02.pdf}}
\caption{Chuỗi thời gian của \py{S}, có và không có sự miễn dịch.}
\label{chap05-fig02}
\end{figure}

Khi không có miễn dịch, gần 47\% tổng thể sẽ bị lây nhiễm tại một thời điểm nhất định. Với 10\% miễn dịch, chỉ 31\% bị lây nhiễm. Như vậy là khá tốt.

Bây giờ hãy cùng xem điều gì sẽ xảy ra nếu ta chỉ định thêm vắc-xin. Hàm dưới đây sẽ quét qua một khoảng các trị số tỉ lệ miễn dịch:

\index{sweep}

\begin{python}
def sweep_immunity(immunize_array):
    sweep = SweepSeries()

    for fraction in immunize_array:
        sir = make_system(beta, gamma)
        add_immunization(sir, fraction)
        results = run_simulation(sir, update_func)
        sweep[fraction] = calc_total_infected(results, sir)

    return sweep
\end{python}

Tham số \py{sweep_immunity} là một mảng các tỉ lệ miễn dịch. Kết quả là một đối tượng  \py{SweepSeries} trong đó ánh xạ từng tỉ lệ miễn dịch tới kết quả tỉ lệ sinh viên từng bị nhiễm bệnh.
  
\index{SweepSeries (đối tượng)}
\index{quét tham số}

Hình~\ref{chap05-fig03} cho thấy biểu đồ của \py{SweepSeries}.  Lưu ý rằng trục x là tỉ lệ miễn dịch chứ không phải thời gian.

Khi tỉ lệ miễn dịch tăng lên, số các ca nhiễm giảm mạnh. Nếu 40\% số sinh viên được miễn dịch thì sẽ chỉ dưới 4\% bị bệnh thôi. Đó là vì sự miễn dịch có 2 tác dụng: nó bảo vệ người miễn dịch (dĩ nhiên rồi) những cũng bảo vệ phần còn lại của tổng thể.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig03.pdf}}
\caption{Số phần của tổng thể bị nhiễm bệnh như một hàm số phụ thuộc vào tỉ lệ miễn dịch.}
\label{chap05-fig03}
\end{figure} 

Việc giảm số các ``người nhiễm" và tăng số ``người miễn dịch" khiến cho bệnh dịch khó lây lan hơn, vì một phần của những lượt tiếp xúc lại hướng đến những người không thể bị nhiễm bệnh rồi. Hiện tượng này được gọi là {\bf miễn dịch cộng đồng}, và cơ chế này đóng vai trò quan trọng trong y tế cộng đồng (xem \url{http://modsimpy.com/herd}).

\index{miễn dịch cộng đồng}

Độ dốc của đường cong trên Hình~\ref{chap05-fig03} có cả tốt lẫn xấu. Mặt tốt là vì ta không cần phải cho tất cả mọi người miễn dịch, và vắc-xin có thể bảo vệ cộng đồng ngay cả khi thuốc này không công hiệu 100\%.

Nhưng ở đó cũng có mặt xấu vì một sự giảm nhẹ về miễn dịch có thể làm tăng mạnh những ca nhiễm. Ở ví dụ này, nếu ta giảm tỉ lệ miễn dịch từ 80\% xuống còn 60\%, thì tình hình còn chưa tệ. Nhưng nếu giảm tiếp từ 40\% xuống 20\%, thì điều đó sẽ kích hoạt sự bùng phát mạnh, ảnh hưởng hơn 15\% dân số tổng thể. Với một căn bệnh nặng như sởi chẳng hạn, thì đó sẽ là một thảm họa với y tế cộng đồng.

\index{bệnh sởi}

Một tác dụng của những mô hình như thế này là biểu diễn những hiện tượng như miễn dịch cộng đồng và dự đoán hiệu ứng của những biện pháp can thiệp như tiêm vắc-xin. Một ứng dụng khác là để đánh giá những phương án và định hướng việc ra quyết định. Ta sẽ thấy một ví dụ trong mục tiếp theo.


\section{Rửa tay}

Giả sử bạn là Trưởng ban Đời sống sinh viên, và bạn chỉ có quỹ \$1200  để chống lại Bệnh dịch tân sinh viên. Bạn có hai phương án tiêu số tiền này:

\begin{enumerate}

\item Bạn có thể chi trả việc tiêm vắc-xin với giá \$100 mỗi liều.

\item Bạn có thể tiêu tiền để vận động tuyên truyền cho sinh viên rửa tay thường xuyên.

\end{enumerate}

Ta đã thấy rằng có thể mô hình hóa hiệu ứng của vắc-xin như thế nào rồi. Giờ ta hãy nghĩ về vận động tuyên truyền rửa tay. Ta sẽ phải trả lời hai câu hỏi:

\begin{enumerate}

\item Làm thế nào để đưa hiệu ứng của việc rửa tay vào mô hình này?

\item Làm thế nào để định lượng hiệu ứng của số tiền dành cho tổ chức vận động tuyên truyền cho rửa tay?

\end{enumerate}

Để đơn giản, hãy giả sử rằng ta đã có dữ liệu của một đợt vận động tương tự ở một trường học khác, trong đó cho thấy rằng một đợt vận động được đầu tư đầy đủ sẽ làm thay đổi hành động của cộng đồng sinh viên đến mức giảm được tỉ lệ nhiễm bớt được 20\%.  

Xét về khía cạnh mô hình, việc rửa tay có hiệu ứng làm giảm \py{beta}.  Đó không phải cách duy nhất mà ta có thẻ đưa hiệu ứng vào, nhưng nó có vẻ hợp lý và dễ thực hiện.

Bây giờ ta phải mô hình hóa mối liên hệ giữa số tiền chi và hiệu quả của cuộc vận động. Một lần nữa, hãy giả sử rằng dữ liệu từ ngôi trường khác cho thấy:

\begin{itemize}

\item Nếu ta chi \$500 cho các poster, vật liệu và thời gian lao động, thì ta có thể làm thay đổi biểu hiện của học sinh theo cách làm giảm giá trị hiệu quả của \py{beta} đi 10\%.

\item Nếu ta chi \$1000, mức tăng tổng cộng của \py{beta} sẽ gần bằng 20\%.

\item Quá \$1000, những chi tiêu vượt thêm chỉ mang lại ít lợi ích.

\end{itemize}

Ở cuốn sổ tính cho chương này bạn sẽ thấy tôi dùng một đường cong logit để khớp số liệu này như thế nào. Kết quả là hàm dưới đây, hàm này nhận vào tham số và trả lại một \py{factor}, tức là một hệ số mà \py{beta} sẽ bị giảm bớt đi:

\index{logistic curve}

\begin{python}
def compute_factor(spending):
    return logistic(spending, M=500, K=0.2, B=0.01)
\end{python}

Tôi dùng \py{compute_factor} để viết \py{add_hand_washing}, hàm này nhận vào một đối tượng \py{System} và một số tiền quỹ, rồi thay đổi \py{system.beta} để mô hình hóa hiệu ứng của việc rửa tay:

\begin{python}
def add_hand_washing(system, spending):
    factor = compute_factor(spending)
    system.beta *= (1 - factor)
\end{python}

Bây giờ ta có thể quét một khoảng giá trị cho \py{spending} và dùng mô phỏng này để tính toán hiệu ứng:

\begin{python}
def sweep_hand_washing(spending_array):
    sweep = SweepSeries()
    
    for spending in spending_array:
        sir = make_system(beta, gamma)
        add_hand_washing(sir, spending)
        results, run_simulation(sir, update_func)
        sweep[spending] = calc_total_infected(results, sir)
        
    return sweep
\end{python}

Và dưới đây là cách ta chạy nó:

\begin{python}
spending_array = linspace(0, 1200, 20)
infected_sweep = sweep_hand_washing(spending_array)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig05.pdf}}
\caption{Phần của dân số bị nhiễm bệnh như mọt hàm số phụ thuộc vào số tiền chi vận động rửa tay.}
\label{chap05-fig05}
\end{figure} 

Hình~\ref{chap05-fig05} cho thấy kết quả. Dưới mức \$200, cuộc vận động ít hiệu quả. Ở mức \$800, nó có hiệu quả đáng kể, giảm tỉ lệ nhiễm tổng cộng từ 46\% xuống còn 20\%.  Trên mức \$800, những lợi ích phụ thêm là rất nhỏ.


\section{Tối ưu hóa} 

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig06.pdf}}
\caption{Phần của dân số bị nhiễm bệnh như mọt hàm số phụ thuộc vào số liều vắc-xin.}
\label{chap05-fig06}
\end{figure} 

Ta hãy tổng hợp tất cả lại. Với một quỹ cố định \$1200, ta phải quyết định xem cần mua bao nhiêu bao nhiêu liều vắc-xin và phải tiêu bao nhiêu cho vận động tuyên truyền rửa tay.

\index{tối ưu hóa}

Sau đây là các thông số:

\begin{python}
num_students = 90
budget = 1200
price_per_dose = 100
max_doses = int(budget / price_per_dose)
\end{python}

Tỉ số \py{budget/price_per_dose} có thể không phải là một số nguyên. \py{int} là hàm dựng sẵn để quy đổi các số thành số nguyên, làm tròn xuống.

Ta sẽ quét một loạt các liều lượng khả dĩ:

\begin{python}
dose_array = linrange(max_doses, endpoint=True)
\end{python}

Ở ví dụ này ta gọi \py{linrange} với chỉ một đối số; nó trả lại một mảng NumPy array với các số nguyên từ 0 đến \py{max_doses}.  Với đối số \py{endpoint=True}, kết quả đã bao gồm cả hai đầu.

\index{linrange}
\index{NumPy}
\index{mảng}

Sau đó ta chạy mô phỏng cho từng phần tử của \py{dose_array}:

\begin{python}
def sweep_doses(dose_array):
    sweep = SweepSeries()
    
    for doses in dose_array:
        fraction = doses / num_students
        spending = budget - doses * price_per_dose
        
        sir = make_system(beta, gamma)
        add_immunization(sir, fraction)
        add_hand_washing(sir, spending)
        
        run_simulation(sir, update_func)
        sweep[doses] = calc_total_infected(sir)

    return sweep
\end{python}

Với từng số liều, ta tính tỉ lệ sinh viên mà ta có thể gây miễn dịch, \py{fraction}, và số tiền còn lại có thể tiêu cho cuộc vận động, \py{spending}.  Sau đó ta chạy mô phỏng với những đại lượng này và lưu lại số ca nhiễm.

Hình~\ref{chap05-fig06} cho thấy kết quả. Nếu ta không mua liều vắc-xin nào cả và tiêu toàn bộ tiền cho cuộc vận động, thì tỉ lệ nhiễm vào khoảng 19\%.  Với 4 liều, ta còn khoảng \$800 cho cuộc vận động, và đây là điểm tối ưu giúp cho cực tiểu hóa số sinh viên bị bệnh.

Khi tăng số liều thuốc, ta phải cắt giảm chi tiêu cho vận động; điều đó hóa ra lại tồi tệ hơn. Nhưng dáng lưu tâm là khi ta áp dụng trên 10 liều thì ảnh hưởng miễn dịch cộng đồng bắt đầu phát huy tác dụng và số sinh viên bị bệnh lại giảm xuống.

\index{miễn dịch cộng đồng}

Trước khi tiếp tục, bạn có thể muốn đọc các sổ tính cho chương này, \py{chap12.ipynb}, và làm các bài tập. Để biết thông tini hướng dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.



\chapter{Quét hai tham số}
\label{chap13}

Ở chương trước, tôi đã trình bày một mô hình SIR cho các bệnh truyền nhiễm, cụ thể là mô hình Kermack-McKendrick. Chúng ta đã mô hình hóa để bao gồm việc tiêm vắc-xin và hiệu ứng của cuộc vận động rửa tay, và dùng mô hình mở rộng này để điều động nguồn vốn hạn hẹp này một cách tối ưu, nghĩa là phải giảm thiểu số ca nhiễm.

\index{Kermack-McKendrick (mô hình)}
\index{SIR (mô hình)}

Nhưng chúng ta đã giả sử rằng các tham số của mô hình, gồm tỉ lệ tiếp xúc và tỉ lệ phục hồi, đều đã biết. Nhưng ở chương này, chúng ta khảo sát ứng xử của mô hình này khi ta đã thay đổi các tham số nêu trên, dùng phép giải tích để hiểu rõ hơn về những mối liên hệ, và đề xuất một phương thức để dùng dữ liệu nhằm ước lượng các tham số.


\section{Unpack - tháo dữ liệu}
\label{unpack}

Trước khi phân tích mô hình SIR, tôi muốn cải thiện mã lệnh một chút. Ở chương trước, ta đã dùng phiên bản này của \py{run_simulation}:
\index{\py{run_simulation}}

\begin{python}
def run_simulation(system, update_func):
    frame = DataFrame(columns=system.init.index)
    frame.row[system.t0] = system.init
    
    for t in linrange(system.t0, system.t_end):
        frame.row[t+1] = update_func(frame.row[t], t, system)
    
    system.results = frame
\end{python}

Trước khi ta đọc rất nhiều biến từ \py{system}, mã lệnh này còn chút lủng củng. Ta có thể làm gọn nó bằng \py{unpack}, vốn được định nghĩa trong thư viện \py{modsim}.  \py{unpack} nhận vào một đối tượng \py{System} làm tham số và làm cho các biến hệ thống dùng được mà không phải viết dấu chấm. Bởi vậy ta có thể viết lại \py{run_simulation} như sau:

\index{unpack}
\index{System (đối tượng)}

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t0] = init
    
    for t in linrange(t0, t_end):
        frame.row[t+1] = update_func(frame.row[t], t, system)
    
    system.results = frame
\end{python}

Các biến mà bạn tháo được cần được coi là biến chỉ đọc. Nếu thay đổi chúng cũng sẽ không gây ra lỗi, song có thể nó không ứng xử như bạn mong đợi. Trong sổ tính chương này, bạn có thể dùng \py{unpack} để làm gọn \py{update1}.


\section{Quét beta}

Hãy nhớ lại rằng $\beta$ là tỉ lệ tiếp xúc, tham số này ghi nhận được cả tần  số tiếp xúc lẫn tỉ lệ các tiếp xúc chuyển thành ca nhiễm mới. Nếu $N$ là cỡ tổng thể và $s$ là tỉ lệ bị nhiễm bệnh thì $s N$ số người nhiễm, $\beta s N$ là số lượt tiếp xúc mỗi ngày giữa người nhiễm bệnh với những người khác, và $\beta s i N$ là số những lượt tiếp xúc  như vậy khi "người khác" đó cũng bị nhiễm bệnh.
\index{quét tham số}

Khi $\beta$ tăng, ta dự kiến rằng tổng số ca nhiễm cũng tăng lên. Để lượng hóa mối liên hệ này, tôi sẽ tạo một loạt các giá trị $\beta$:

\begin{python}
beta_array = linspace(0.1, 1.1, 11)
\end{python}

Rồi chạy mô phỏng cho từng giá trị và in kết quả.

\begin{python}
for beta in beta_array:
    sir = make_system(beta, gamma)
    run_simulation(sir, update1)
    print(sir.beta, calc_total_infected(sir))
\end{python}

Ta có thể bọc mã lệnh này vào một hàm rồi lưu kết quả vào một đối tượng \py{SweepSeries}:
\index{SweepSeries (đối tượng)}

\begin{python}
def sweep_beta(beta_array, gamma):
    sweep = SweepSeries()
    for beta in beta_array:
        system = make_system(beta, gamma)
        run_simulation(system, update1)
        sweep[system.beta] = calc_total_infected(system)
    return sweep
\end{python}

Giờ thì ta có thể chạy \py{sweep_beta} như sau:

\begin{python}
infected_sweep = sweep_beta(beta_array, gamma)
\end{python}

Rồi vẽ kết quả:

\begin{python}
label = 'gamma = ' + str(gamma)
plot(infected_sweep, label=label)
\end{python}

%TODO: hình dung xem lúc nào nên giới thiệu các chuỗi

Dòng đầu tiên sử dụng phép toán với chuỗi để dán nhãn lên đường đồ thị vừa vẽ:
\index{chuỗi}

\begin{itemize}

\item Khi toán tử \py{+} được áp dụng cho chuỗi, nó nối tiếp các chuỗi thành vần, do vậy thao tác này được gọi là {\bf nối}. 
 
\index{nối}

\item Hàm \py{str} quy đổi một đối tượng kiểu bất kì về một biểu diễn dạng chuỗi. Trong trường hợp này, \py{gamma} là một số, bởi vậy ta phải quy đổi nó thành chuỗi trước khi thực hiện ghép nối.

\index{str (hàm)}

\end{itemize}

Nếu \py{gamma} có giá trị bằng \py{0.25}, \py{label} sẽ có giá trị là chuỗi \py{'gamma = 0.25'}.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap06-fig01.pdf}}
\caption{Tổng số sinh viên nhiễm bệnh như một hàm phụ thuộc tham số \py{beta}, với \py{gamma = 0.25}.}
\label{chap06-fig01}
\end{figure}

Hình~\ref{chap06-fig01} cho thấy kết quả. Hãy nhớ rằng hình này thể hiện việc quét tham số chứ không phải một chuỗi thời gian; bởi vậy trục x là tham số \py{beta}, chứ không phải thời gian.

Khi \py{beta} nhỏ, tốc độ tiếp xúc còn thấp và thực ra không có sự bùng phát bệnh; tổng số các sinh viên bị nhiễm gần bằng không. Khi \py{beta} tăng, nó đạt tới ngưỡng gần bằng 0.3, tại đó tỉ lệ các sinh viên bị nhiễm tăng nhanh chóng. Khi \py{beta} vượt quá 0.5, có hơn 80\% tổng thể bị bệnh.


\section{Quét gamma}

Bây giờ hãy cùng xem điều gì xuất hiện với vài trị số \py{gamma} khác nhau.  Ta sẽ lại dùng \py{linspace} để tạo một mảng các giá trị:

\index{linspace}

\begin{python}
gamma_array = linspace(0.1, 0.7, 4)
\end{python}

Rồi chạy \py{sweep_beta} cho từng giá trị \py{gamma}:

\begin{python}
for gamma in gamma_array:
    infected_sweep = sweep_beta(beta_array, gamma)
    label = 'gamma = ' + str(gamma)
    plot(infected_sweep, label=label)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap06-fig02.pdf}}
\caption{Tổng số sinh viên bị nhiễm là một hàm phụ thuộc tham số \py{beta}, với vài giá trị của \py{gamma}.}
\label{chap06-fig02}
\end{figure}

Hình~\ref{chap06-fig02} cho thấy kết quả. Khi \py{gamma} còn thấp, tốc độ hồi phục khá chậm, đồng nghĩa với việc người mắc bệnh lâu hơn. Trường hợp này, ngay cả một tốc độ tiếp xúc (\py{beta}) thấp vẫn gây nên đại dịch.

Khi \py{gamma} cao, \py{beta} thậm chí phải còn cao hơn nữa để mọi thứ tiếp diễn. Quan sát này gợi cho ta biết có thể tồn tại mối liên hệ giữa \py{gamma} và \py{beta} để quy định kết quả của mô hình. Và đúng là vậy. Trong hai chương sắp tới tôi sẽ thể hiện điều này bằng cách chạy mô phỏng và dùng toán để suy luận.

Trước khi tiếp tục, bạn có thể cần đọc sổ tính của chương này \py{chap13.ipynb}, và làm các bài tập. Để biết cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Phân tích} 
\label{chap14}

Ở những chương trước, ta dùng mô phỏng để dự đoán ảnh hưởng của một bệnh truyền nhiễm đối với cộng đồng có dễ tổn thương, và để thiết kế các biện pháp can thiệp giảm thiểu ảnh hưởng đó.

Trong chương này, ta dùng toán phân tích để điều tra mối liên hệ giữa hai tham số, \py{beta} và \py{gamma}, cũng như kết quả của mô phỏng.


\section{Phi thứ nguyên}
\label{nondim}

Trước khi tiếp tục, hãy cùng bọc mã lệnh từ chương trước vào trong một hàm:

\begin{python}
def sweep_parameters(beta_array, gamma_array):
    frame = SweepFrame(columns=gamma_array)
    for gamma in gamma_array:
        frame[gamma] = sweep_beta(beta_array, gamma)
    return frame
\end{python}

\py{sweep_parameters} nhận các tham số gồm hai mảng: một dãy các giá trị cho \py{beta} và một dãy các giá trị cho \py{gamma}.

Hàm này tạo ra một \py{SweepFrame} để lưu trữ kết quả, với mỗi cột lưu cho một giá trị \py{gamma} và mỗi hàng cho một giá trị \py{beta}.  \py{SweepFrame} là một dạng \py{DataFrame}, nhưng được định nghĩa trong thư viện \py{modsim}.  Mục đích của nó là để lưu các kết quả từ một lượt quét tham số hai chiều.
\index{SweepFrame, đối tượng}
\index{DataFrame, đối tượng}

Mỗi lần qua vòng lặp, ta lại chạy \py{sweep_beta}.  Kết quả là một đối tượng \py{SweepSeries} với mỗi phần tử cho từng giá trị \py{gamma}.  Phép gán

\begin{python}
frame[gamma] = sweep_beta(beta_array, gamma)
\end{python}

sẽ lưu giá trị từ đối tượng \py{SweepSeries} thành một cột mới trong \py{SweepFrame}, tương ứng với giá trị hiện thời của \py{gamma}.

Sau cùng, \py{SweepFrame} lưu lại tỉ lệ sinh viên bị nhiễm ứng với từng cặp tham số, \py{beta} và \py{gamma}.

Ta có thể chạy \py{sweep_parameters} như sau:

\begin{python}
frame = sweep_parameters(beta_array, gamma_array)
\end{python}

Tiếp đó có thể lặp qua kết quả như sau:

\begin{python}
for gamma in frame.columns:
    series = frame[gamma]
    for beta in series.index:
        frac_infected = series[beta]
        print(beta, gamma, frac_infected)
\end{python}

Đây là ví dụ đàu tiên mà ta thấy có vòng lặp \py{for} đặt trong một vòng lặp khác:

\begin{itemize}

\item Mỗi lần vòng lặp bên ngoài chạy, nó chọn một giá trị \py{gamma} từ các cột của \py{DataFrame} rồi kết xuất cột tương ứng thành một dãy \py{Series}.
\index{Series}

\item Mỗi lần vòng lặp bên trong chạy, nó chọn một giá trị \py{beta} từ các \py{Series} rồi chọn phần tử tương ứng, tức là tỉ lệ sinh viên bị nhiễm.

\end{itemize}  

Ở ví dụ này, \py{frame} có 4 cột, mỗi cột chứa một giá trị \py{gamma}, và 11 hàng, mỗi hàng chứa một giá trị \py{beta}. Bởi vậy các vòng lặp này in ra 44 hàng, mỗi hàng chứa một cặp tham số.

Bây giờ hãy cùng nghĩ về mối liên hệ khả dĩ giữa \py{beta} và \py{gamma}:

\begin{itemize}

\item Khi \py{beta} vượt quá \py{gamma}, điều đó nghĩa là có nhiều lượt tiếp xúc (tức tiềm năng nhiễm) hơn là lượt phục hồi. Có thể gọi hiệu số giữa \py{beta} và \py{gamma} là ``tỉ lệ tiếp xúc vượt", đơn vị đo là số lượt tiếp xúc mỗi ngày.

\item Một cách khác là xét tỉ số \py{beta/gamma}, đây là số lượt tiếp xúc ứng với mỗi ca phục hồi. Vì tử số và mẫu số cùng đơn vị nhau nên tỉ số này là {\bf phi thứ nguyên}, nó không có đơn vị.
\index{phi thứ nguyên}

\end{itemize}

Trong trò chơi mô hình hóa và mô phỏng, một nước đi quan trọng là việc mô tả các hệ thống vật lí bằng những tham số phi thứ nguyên. Nó quan trọng đến nỗi có hẳn một tên riêng: {\bf phi thứ nguyên hóa} (xem \url{http://modsimpy.com/nondim}).

\index{phi thứ nguyên hóa}

Ta sẽ thử phương án thứ hai trước. Ở cuốn sổ lệnh cho chương này, bạn cũng có thể khám phá phương án thứ nhất, coi đó như một bài tập.

Hàm sau đây sẽ gói các vòng lặp đã nêu rồi vẽ đồ thị tỉ lệ nhiễm phụ thuộc theo tỉ số \py{beta/gamma}:

\begin{python}
def plot_sweep_frame(frame):
    for gamma in frame.columns:
        series = frame[gamma]
        for beta in series.index:
            frac_infected = series[beta]
            plot(beta/gamma, frac_infected, 'ro')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap06-fig03.pdf}}
\caption{Tỉ lệ nhiễm tổng cộng phụ thuojc theo số ca tiếp xúc.}
\label{chap06-fig03}
\end{figure}

Hình~\ref{chap06-fig03} cho thấy rằng các điểm kết quả sẽ xếp thành một hàng thẳng, hay ít ra là gần được như vậy. Điều đó nghĩa là ta đã dự đoán được tỉ lệ sinh viên sẽ bị nhiễm dựa trên một tham số thôi, đó là tỉ số \py{beta/gamma}.  Ta không phải biết cụ thể từng giá trị \py{beta} và \py{gamma}.


\section{Số ca tiếp xúc}
\label{contact}

Hãy nhớ lại rằng trong một ngày nhất định, số ca nhiễm mới sẽ là $\beta s i N$, và số ca hồi phục là $\gamma i N$.  Nếu ta đem chia hai đại lượng này, kết quả là $\beta s / \gamma$, chính là số ca nhiễm mới tính trên mỗi ca hồi phục (như một tỉ lệ phần dân số).

\index{số tiếp xúc | contact number}
\index{số tái tạo cơ bản | basic reproduction number}

Khi một căn bệnh mới ảnh hưởng đến nhóm dân cư dễ tổn thương, thì $s$ xấp xỉ bằng 1, vậy số người bị nhiễm bởi mỗi người bệnh sẽ là $\beta / \gamma$.  Tỉ số này được gọi là ``tiếp xúc" hoặc ``số tái tạo cơ bản" (xem \url{http://modsimpy.com/contact}).  Theo quy ước, nó thường được viết là $R_0$, nhưng trong ngữ cảnh mô hình SIR, cách viết này sẽ dễ hiểu lầm nên ta dùng kí hiệu $c$.

Kết quả ở mục trên gợi ý rằng có mối liên hệ giữa $c$ và tổng số ca nhiễm. Ta có thể rút ra mối liên hệ này bằng cách phân tích các phương trình vi phân từ Mục~\ref{sireqn}:
%
\begin{align*}
\frac{ds}{dt} &= -\beta s i \\
\frac{di}{dt} &= \beta s i - \gamma i\\
\frac{dr}{dt} &= \gamma i
\end{align*}
%
Theo cách tương tự, ta đem chia tốc độ tiếp xúc cho tốc độ nhiễm để thu được đại lượng phi thứ nguyên $c$, bây giờ ta sẽ đem chia $di/dt$ cho $ds/dt$ để thu được tỉ số các tốc độ:
%
\[ \frac{di}{ds} = -1 + \frac{1}{cs} \]
%
Việc chia một phương trình vi phân này cho một phương trình vi phân khác không thật hiển nhiên, nhưng ở đây sẽ hữu ích vì nó cho ta liên hệ giữa $i$, $s$ và $c$ mà không phụ thuộc vào thời gian. Từ liên hệ này, ta có thể rút ra một phương trình gắn $c$ với giá trị cuối cùng của $S$.  Trên lý thuyết, phương trình này cho phép ta suy ra $c$ bằng cách quan sát quá trình đợt dịch.

Sau đây là cách biến đổi toán học. Ta nhân cả hai vế phương trình trên với $ds$:
%
\[ di = \left( -1 + \frac{1}{cs} \right) ds \]
%
Và rồi lấy tích phân cả hai vế:
%
\[ i = -s + \frac{1}{c} \log s + q \]
%
trong đó $q$ là hằng số tích phân. Sắp xếp lại các số hạng, ta được:
%
\[ q = i + s - \frac{1}{c} \log s \]
%
Bây giờ hãy xem liệu ta có thể hình dung ra $q$ bằng bao nhiêu. Ở đầu đợt dịch, nếu tỉ lệ nhiễm còn nhỏ và gần như mọi người đều dễ bị nhiễm, ta có thể dùng cách xấp xỉ $i(0) = 0$ và $s(0) = 1$ để tính $q$:
%
\[ q = 0 + 1 + \frac{1}{c} \log 1 \]
%
Vì $\log 1 = 0$, ta có $q = 1$.
\index{tích phân | integration}
\index{hằng số tích phân | constant of integration}

\newcommand{\sinf}{s_{\infty}}

Bây giờ, ở cuối đợt dịch, ta hãy giả sử rằng $i(\infty) = 0$, và $s(\infty)$ là một đại lượng chưa biết, $\sinf$.  Bây giờ ta có:
%
\[ q = 1 = 0 + \sinf - \frac{1}{c} \log \sinf \]
%
Giải ra tìm $c$, ta thu được
%
\[ c = \frac{\log \sinf}{\sinf - 1} \]
%
Bằng cách liên hệ $c$ và $\sinf$, phương trình này cho phép ta ước tính $c$ dựa trên số liệu, và có thể dự đoán động thái của những dịch bệnh trong tương lai.

\section{Phân tích và mô phỏng}

Hãy cùng so sánh nghiệm giải tích này với kết quả mô phỏng.
Tôi sẽ tạo một mảng chứa các giá trị của $\sinf$
\index{linspace}

\begin{python}
s_inf_array = linspace(0.0001, 0.9999, 31)
\end{python}

Rồi tính các giá trị tương ứng của $c$:

\begin{python}
c_array = log(s_inf_array) / (s_inf_array - 1)
\end{python}

Để thu được tổng số người nhiễm, ta đi tính hiệu số giữa $s(0)$ và $s(\infty)$, rồi lưu kết quả vào một dãy \py{Series}:
\index{array}
\index{series}

\begin{python}
frac_infected = 1 - s_inf_array
frac_infected_series = Series(frac_infected, index=c_array)
\end{python}

Hãy nhớ rằng trong Mục~\ref{dataframe}, một đối tượng \py{Series} có chứa một chỉ số cùng một chuỗi giá trị tương ứng. Ở đây, chỉ số là \py{c_array} còn các giá trị nhận được từ \py{frac_infected}.

Bây giờ ta có thể vẽ đồ thị kết quả:

\begin{python}
plot(frac_infected_series)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap06-fig04.pdf}}
\caption{Tổng tỉ lệ nhiễm biểu diễn như hàm số các ca tiếp xúc, cho thấy kết quả từ mô phỏng và nghiệm giải tích.}
\label{chap06-fig04}
\end{figure}

Hình~\ref{chap06-fig04} so sánh kết quả nghiệm giải tích của mục này với kết quả mô phỏng từ Mục~\ref{nondim}. Trong phần lớn khoảng giá trị, hai kết quả này tương đồng nhau, chỉ với một khác biệt: khi số ca tiếp xúc nhỏ hơn 1 thì nghiệm giải tích cho thấy không có lây nhiễm; nhưng trong mô phỏng một phần nhỏ của tổng thể vẫn bị ảnh hưởng ngay cả khi $c<1$.
\index{analysis}

Lí do về sự khác biệt này là: cách mô phỏng đã chia thời gian thành chuỗi những ngày rời lẻ, trong khi nghiệm giải tích lại coi thời gian như đại lượng liên tục. Nói cách khác, hai phương pháp này thực ra là dựa trên các mô hình khác nhau. Vậy mô hình nào tốt hơn?

Có lẽ không thể nói được. Nếu số ca nhiễm còn thấp, quá trình lây lan ban đầu phụ thuộc vào chi tiết kịch bản. Nếu ta may mắn, người nhiễm đầu tiên, ``bệnh nhân số không", chỉ nhiễm cho không quá một người và sẽ không có đại dịch xảy ra. Nhưng nếu xui rủi, bệnh nhân số không có thể có nhiều bạn thân, hoặc họ làm việc ở nhà ăn (mà quên thực hành quy tắc vệ sinh an toàn thực phẩm).
\index{bệnh nhân số không | patient zero}

Với số ca tiếp xúc gần bằng hoặc nhỏ hơn 1, ta có thể cần tới một mô hình chi tiết hơn. Nhưng với các số ca tiếp xúc cao thì mô hình SIR có lẽ cũng đủ chính xác.

Hình~\ref{chap06-fig04} cho thấy rằng nếu ta biết được số ca tiếp xúc thì ta sẽ tính được tỉ lệ lây nhiễm. Nhưng ta cũng có thể đọc điều này theo chiều hướng ngược lại, như sau: Ở cuối thời kì đại dịch, nếu ta ước tính được tỉ lệ dân số đã từng bị nhiễm thì ta có thể dùng nó để tính ra số tiếp xúc.

Hoặc chí ít cũng như vậy trên lý thuyết. Còn trong thực tế, điều này có thể không đúng lắm, vì hình dạng của đường cong đồ thị. Khi số tiếp xúc gần bằng 2 thì đường đồ thị sẽ rất dốc, nghĩa là một sự thay đổi $c$ rất nhỏ sẽ dẫn tới việc số lây nhiễm thay đổi rất lớn. Nếu ta quan sát thấy tổng tỉ lệ nhiễm rơi vào khoảng từ 20\% đến 80\%, thì ta có thể kết luận rằng $c$ gần bằng 2.

Mặt khác, với những số lây nhiễm lớn hơn, thì gần như toàn bộ tổng thể đều bị nhiễm, do vậy đường cong sẽ bằng phẳng. Lúc này ta sẽ không thể ước lượng chính xác $c$ được, vì bất kì giá trị nào lớn hơn 3 sẽ cho kết quả coi như bằng nhau. Song thật may rằng điều này không mấy khi xảy ra trong thực tế: có rất ít đại dịch ảnh hưởng nhiều đến mức 90\% tổng thể dân cư.

Như vậy mô hình SIR có hạn chế của nó. Tuy nhiên, nó vẫn cho ta thấy động thái của dịch bệnh truyền nhiễm, đặc biệt là hiện tượng miễn dịch cộng đồng. Như đã thấy ở chương trước, nếu ta biết các tham số mô hình, ta có thể dùng nó để đánh giá những cách can thiệp khả dĩ. Và như đã thấy ở chương này, ta có thể dùng số liệu từ những đợt bùng phát trước để ước tính tham số mô hình.

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap14.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.

%\part{Mô hình hoá các hệ thống truyền nhiệt}



\chapter{Nhiệt}
\label{chap15}

Đến giờ các hệ thống ta nghiên cứu đều thuộc thể loại vật lý theo nghĩa chúng tồn tại trên thế giới, nhưng không hẳn là vật lý theo nghĩa bài vở môn học vật lý được giảng trên lớp. Ở vài chương tiếp theo, ta sẽ làm một số vấn đề vật lý, bắt đầu với {\bf hệ thống nhiệt}, nghĩa là những hệ thống mà nhiệt độ của vật thể thay đổi khi nhiệt truyền từ vật này sang vật khác.

\index{hệ thống nhiệt}

\section{Bài toán làm nguội cà-phê}

Bài toán làm nguội cà-phê được Jearl Walker thảo luận trên báo {\it Scientific American} năm 1977\footnote{Walker, ``The Amateur Scientist", {\it Scientific American}, Quyển 237, Số 5, Tháng 11-1977.}; và từ đó nó trở nên một ví dụ tiêu chuẩn cho mô hình hoá và mô phỏng.

\index{bài toán làm nguội cà-phê}
\index{Walker, Jearl}

Tôi sẽ diễn đạt lại bài toán như sau:

\begin{quote}
Giả dụ rằng trên đường đi làm, tôi dừng lại bên đường mua một cốc cà phê. Tôi cũng mang theo sữa rồi. Coi như rằng tôi muốn khi đến văn phòng thì cà phê càng nóng càng tốt. Vậy tôi nên cho sữa ngay khi mới mua cà phê, cho sữa vào lúc giữa đường, hay lúc đến văn phòng?
\end{quote}

Để giúp trả lời câu hỏi này, tôi đã làm thử thí nghiệm đặt sữa và cà phê trong những ngăn riêng và thực hiện đo đạc\footnote{Đây là ví dụ. Tôi thường uống trà và đạp xe đi làm.}:

\begin{itemize}

\item Khi được giao hàng, nhiệt độ cà phê là \SI{90}{\celsius}.  Dung tích là \SI{300}{mL}.

\item Sữa có nhiệt độ ban đầu \SI{5}{\celsius}, và tôi mang đi khoảng \SI{50}{mL}.

\item Nhiệt độ nền trong xe hơi của tôi là \SI{22}{\celsius}.

\item Cà phê được đựng trong cốc cách nhiệt tốt. Khi tôi đến văn phòng 30 phút sau đó, nhiệt độ cà phê đã giảm chỉ còn \SI{70}{\celsius}.

\item Bình đựng sữa thì không cách nhiệt. Sau 15 phút, sữa ấm dần đến \SI{20}{\celsius}, gần bằng nhiệt độ nền.

\end{itemize}

Để dùng số liệu này và trả lời câu hỏi, ta cần phải biết đôi chút về nhiệt độ và nhiệt, đồng thời phải ra quyết định mô hình hoá.


\section{Nhiệt độ và nhiệt}

Để hiểu được cà phê nguội (và sữa ấm lên) ra sao, ta cần có một mô hình nhiệt độ và nhiệt.  {\bf Nhiệt độ} là một thuộc tính của đối tượng hoặc hệ thống; trong hệ SI đơn vị của nó là độ C (\si{\celsius}).  Nhiệt độ định lượng xem vật thể nóng/lạnh bao nhiêu, điều này vốn liên quan tới vận tốc trung bình của các hạt (phân tử) cấu thành vật thể đó.

\index{nhiệt độ | temperature}

Khi các hạt của vật nóng tiếp xúc với các hạt của vật lạnh, vật nóng sẽ nguội đi và vật lạnh ấm lên do năng lượng được truyền từ vật này sang vật kia. Năng lượng đã truyền này được gọi là {\bf nhiệt}; nó có đơn vị là jun / joule (\si{\joule}) trong hệ SI.

\index{nhiệt | heat}

Nhiệt có liên quan đến nhiệt độ theo biểu thức sau (xem \url{http://modsimpy.com/thermass}):
%
\[ Q = C \Delta T \]
%
trong đó $Q$ là lượng nhiệt truyền tới một vật, $\Delta T$ là mức biến đổi nhiệt độ tương ứng, còn $C$ là {\bf khối lượng nhiệt} của vật đó, nó lượng hoá xem cần bao nhiêu năng lượng để nung nóng hoặc làm nguội vật. Khối lượng nhiệt có đơn vị đo là jun trên độ C (\si{\joule\per\celsius}) trong hệ SI.

\index{khối lượng nhiệt | thermal mass}

Với những vật chủ yếu làm từ một loại vật liệu thì khối lượng nhiệt có thể được tính như sau:
%
\[ C = m c_p \]
%
trong đó $m$ là khối lượng vật còn $c_p$ là {\bf nhiệt dung riêng} của vật liệu (xem \url{http://modsimpy.com/specheat}).

\index{nhiệt dung riêng | specific heat capacity}

Ta có thể dùng những biểu thức trên để ước tính khối lượng nhiệt của cốc cà phê. Nhiệt dung riêng của cà phê có lẽ xấp xỉ của nước, tức là \SI{4.2}{\joule\per\gram\per\celsius}.  Nếu coi mật độ cà phê xấp xỉ bằng của nước, tức \SI{1}{\gram\per\milli\liter}, thì khối lượng của \SI{300}{\milli\liter} cà phê sẽ là \SI{300}{\gram}, và khối lượng nhiệt sẽ là \SI{1260}{\joule\per\celsius}.

\index{mật độ | density}

Như vậy, khi cốc cà phê nguội từ \SI{90}{\celsius} xuống còn \SI{70}{\celsius}, thì mức thay đổi nhiệt độ, $\Delta T$ bằng \SI{20}{\celsius}, nghĩa là \SI{25200}{\joule} nhiệt năng được chuyển từ cà phê sang môi trường xung quanh (giá đỡ cốc và không khí trong xe hơi).

Để hình dung được năng lượng đó bằng bao nhiêu, giả sử như bạn khống chế được toàn bộ nhiệt lượng đó để thực hiện công (điều mà thực tế là không thể\footnote{Xem \url{http://modsimpy.com/thermo}.}), thì bạn có thể dùng nó để nâng cốc cà phê từ mực nước biển lên tới \SI{8571}{\meter}, chỉ thấp hơn đỉnh Everest, \SI{8848}{\meter}, đôi chút.

\index{Núi Everest | Mount Everest}

Giả sử rằng cốc có khối lượng nhỏ hơn so với lượng cà phê, và được làm từ vật liệu có nhiệt dung thấp hơn, thì ta có thể bỏ qua khối lượng nhiệt của cốc. Trong trường hợp cốc có khối lượng nhiệt đáng kể thì ta có thể phải đùng đến mô hình tính riêng nhiệt độ của cà phê và nhiệt độ cốc.


\section{Truyền nhiệt}

Trong trường hợp như bài toán làm nguội cà phê, có 3 cách mà nhiệt truyền từ vật này sang vật khác (xem \url{http://modsimpy.com/transfer}):

\index{truyền nhiệt | heat transfer}
\index{dẫn nhiệt | conduction}
\index{đối lưu | convection}
\index{bức xạ | radiation}

\begin{itemize}

\item Dẫn nhiệt: Khi các vật khác nhau về nhiệt độ tiếp xúc với nhau thì những hạt di chuyển nhanh của vật nhiệt độ cao sẽ truyền động năng cho các hạt di chuyển chậm của vật nguội hơn.

\item Đối lưu: Khi các hạt trong một dòng khí hay chất lỏng di chuyển thì chúng cũng mang nhiệt đi theo. Các dòng chất lưu có thể gây ra do tác động từ bên ngoài, như khuấy động hay do chênh lệnh nhiệt độ ngay nội tại. Chẳng hạn, bạn có thể biết những dòng không khí nóng sẽ thăng lên, đây chính là một dạng ``đối lưu tự nhiên".

\index{dòng chất lưu | fluid flow}

\item Bức xạ: Khi các hạt trong vật di chuyển do nhiệt năng thì chúng phát ra bức xạ điện từ. Năng lượng mà bức xạ này mang theo sẽ phụ thuộc vào nhiệt độ của vật và các đặc tính bề mặt của nó (xem \url{http://modsimpy.com/thermrad}).

\end{itemize}

Với những vật như cà phê trong xe hơi, hiệu ứng của bức xạ sẽ nhỏ hơn nhiều so với các hiệu ứng của dẫn nhiệt và đối lưu, do vậy ta sẽ bỏ qua bức xạ.

Đối lưu có thể là một chủ đề phức tạp, vì nó thường phụ thuộc vào dòng chất lưu trong không gian 3 chiều. Nhưng ở bài toán này ta có thể tránh khỏi khó khăn bằng một mô hình đơn giản có tên ``Định luật cấp nhiệt Newton".

\index{Định luật cấp nhiệt Newton | Newton's law of cooling}

\section{Định luật cấp nhiệt Newton}

Định luật cấp nhiệt Newton phát biểu rằng tốc độ thay đổi nhiệt độ của vật thì tỉ lệ thuận với chênh lệch nhiệt độ giữa vật đó với nhiệt độ môi trường xung quanh:
%
\[ \frac{dT}{dt} = -r (T - T_{env}) \]
%
trong đó $T$, nhiệt độ của vật, là một hàm số theo thời gian, $t$; $T_{env}$ là nhiệt độ của môi trường, còn $r$ là hằng số đặc trưng cho tốc độ truyền nhiệt giữa hệ thống với môi trường.

Cái được gọi là ``định luật" này của Newton thực ra là một mô hình theo nghĩa nó đạt tới gần đúng trong những điều khiện nhất định, nhưng chỉ hơi đúng trong những trường hợp khác, thậm chí có trường hợp còn sai hoàn toàn.

Chẳng hạn, nếu cơ chế truyền nhiệt chính là dẫn nhiệt thì định luật Newton sẽ ``đúng", nghĩa là trị số $r$ không đổi trên một khoảng rộng nhiệt độ khác nhau. Và đôi khi ta có thể ước tính được $r$ dựa trên đặc tính vật liệu và hình dạng của vật thể.

Khi đối lưu đóng vai trò không thể bỏ qua trong quá trình truyền nhiệt, $r$ sẽ phụ thuộc vào nhiệt độ, song định luật Newton vẫn thường đủ chính xác, ít nhất là trong một khoảng nhiệt độ hẹp. Với trường hợp này, $r$ thường phải được xác định bằng cách thực nghiệm, vì nó còn phụ thuộc vào chi tiết hình dạng bề mặt, dòng khí, sự bốc hơi v.v. nữa.

Khi bức xạ đóng vai trò đáng kể trong sự truyền nhiệt thì định luật Newton không còn là mô hình phù hợp nữa. Với trường hợp mà vật thể ở trong vũ trụ hoặc chân không, và với những vật thể có nhiệt độ cao (nóng hơn vài trăm độ C chẳng hạn).

\index{bức xạ | radiation}

Tuy nhiên, với trường hợp như bài toán làm nguội cốc cà phê thì ta vẫn trông đợi mô hình Newton ứng nghiệm tốt.


\section{Lập trình}
\label{coffee_impl}

Để bắt đầu, ta hãy tạm quên phần sữa đi và chú ý vào cà phê. Tôi sẽ tạo một đối tượng \py{State} để biểu diễn nhiệt độ ban đầu:

\begin{python}
init = State(T=90)
\end{python}

và một đối tượng \py{System} để chứa những tham số hệ thống:

\index{State (đối tượng) | object}
\index{System (đối tượng) | object}

\begin{python}
coffee = System(init=init,
                volume=300,
                r=0.01,
                T_env=22,
                t_0=0, 
                t_end=30,
                dt=1)
\end{python}

Các giá trị của \py{volume}, \py{T_env}, và \py{t_end} đều lấy từ đề bài. Tạm thời tôi chọn giá trị tuỳ ý cho \py{r}; ta sẽ sớm hình dung ra cách ước tính nó.

\index{bước thời gian | time step}

\py{dt} là thời gian ta dùng để mô phỏng quá trình làm nguội.
Chặt chẽ mà nói, định luật Newton là một phương trình vi phân, nhưng xét trong một thời khoảng rất ngắn thì ta có thể xấp xỉ nó bằng một phương trình sai phân:
%
\[ \Delta T = -r (T - T_{env}) dt \]
%
trong đó $dt$ là một bước thời gian nhỏ còn $\Delta T$ là mức thay đổi nhiệt độ diễn ra trong bước thời gian đó.

Lưu ý: Tôi viết $\Delta T$ để kí hiệu cho mức thay đổi nhiệt độ theo thời gian, song đặt trong ngữ cảnh sự truyền nhiệt, bạn cũng có thể thấy $\Delta T$ được dùng để chỉ chênh lệch nhiêt độ giữa vật và môi trường, $T - T_{env}$.  Để tránh nhầm lẫn, tôi sẽ không dùng cách hiểu thứ hai.

Giờ đây ta có thể viết một hàm cập nhật:

\index{unpack}

\begin{python}
def update_func(state, t, system):
    unpack(system)
    
    T = state.T
    T += -r * (T - T_env) * dt

    return State(T=T)
\end{python}

Cũng như các hàm cập nhật trước đây, hàm này nhận một đối tượng \py{State}, một thời gian, và một đối tượng \py{System}.

Bây giờ nếu ta chạy 

\begin{python}
update_func(init, 0, coffee)
\end{python}

ta sẽ thấy rằng nhiệt độ sau một phút là \SI{89.3}{\celsius}, tức là nhiệt độ đã hạ khoảng \SI{0.7}{\celsius\per\minute}, ít ra là đối với trị số \py{r} này.

Sau đây là một phiên bản \py{run_simulation} để mô phỏng một loạt những bước thời gian từ \py{t_0} tới \py{t_end}:

\index{bước thời gian | time step}
\index{\py{run_simulation}}
\index{tháo | unpack}

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t_0] = init
    ts = linrange(t_0, t_end, dt)
    
    for t in ts:
        frame.row[t+dt] = update_func(frame.row[t], t, system)
        
    # store the final temperature in T_final
    system.T_final = get_last_value(frame.T)
    
    return frame
\end{python}

Hàm này tương tự với những phiên bản \py{run_simulation} trước đây.

Có một điểm khác biệt, đó là nó dùng \py{linrange} để lập một mảng giá trị từ \py{t_0} đến \py{t_end} với bước thời gian \py{dt}.  Kết quả này không bao gồm \py{t_end}, do vậy trị số cuối cùng trong mảng là \py{t_end-dt}.

\index{linrange}
\index{NumPy}
\index{mảng | array}

Ngoài ra, nó còn lưu nhiệt độ cuối như một biến hệ thống, \py{T_final}.

Ta có thể chạy hàm này như sau:

\begin{python}
results = run_simulation(coffee, update_func)
\end{python}

Kết quả là một đối tượng \py{TimeFrame} với mỗi hàng ứng với một bước thời gian và chỉ có một cột, \py{T}.  Nhiệt độ sau 30 phút là \SI{72.3}{\celsius}, trị số này cao hơn một chút so với như đã nêu trong bài, \SI{70}{\celsius}.  Ta có thể chỉnh \py{r} và tìm ra trị số đúng bằng cách thử và sai, nhưng rồi ta sẽ thấy một cách hay hơn trong chương tiếp theo.

\index{bước thời gian | time step}
\index{đối tượng TimeFrame object}

Trước hết, tôi muốn gói mã lệnh đã viết cho tới giờ vào một hàm:

\begin{python}
def make_system(T_init=90, r=0.01, volume=300, t_end=30):
    init = State(T=T_init)
    
    return System(init=init,
                  T_final=T_init,
                  volume=volume,
                  r=r,
                  T_env=22, 
                  t_0=0,
                  t_end=t_end,
                  dt=1)
\end{python}

\py{make_system} nhận các tham số hệ thống rồi xếp chúng vào một đối tượng \py{System}. Bây giờ ta có thể mô phỏng hệ thống như sau:

\index{\py{make_system}}

\begin{python}
coffee = make_system(T_init=90, r=0.01, 
                     volume=300, t_end=30)
results = run_simulation(coffee, update_func)
\end{python}


Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap15.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Hoà trộn}
\label{chap16}

Ở chương trước ta đã viết chương trình mô phỏng sự làm nguội cốc cà phê. Cho trước nhiệt độ ban đầu của cà phê, nhiệt độ không khí, và tham số tốc độ, \py{r}, ta có thể dự đoán được nhiệt độ cà phê sẽ thay đổi thế nào theo thời gian.

Nói chung, ta không biết trị số của \py{r}, nhưng ta có thể dùng kết quả đo đạc để ước tính trị số đó. Cho trước một nhiệt độ ban đầu, một nhiệt độ cuối và khoảng thời gian giữa chúng, ta có thể tính ra \py{r} bằng cách thử và sai.

Trong chương này, ta sẽ biết một cách hay hơn để tính \py{r}, bằng cách dùng hàm mang tên \py{fsolve} có trong SciPy.

Và rồi ta sẽ quay trở lại giải bài toán làm nguội cà phê.

\section{Sử dụng fsolve}
\label{fsolve}

SciPy cung cấp một phương thức có tên \py{fsolve} để tìm các nghiệm của phương trình phi tuyến. Lấy ví dụ đơn giản, chẳng hạn bạn cần tìm các nghiệm của đa thức
%
\[ f(x) = (x - 1)(x - 2)(x - 3) \]
%
trong đó {\bf root} nghĩa là một trị số của $x$ thoả mãn $f(x)=0$.  Bởi cách tôi viết đa thức này nên bạn có thể thấy ngay rằng nếu $x=1$, thừa số đầu bằng 0; nếu $x=2$, thừa số giữa bằng 0; và nếu $x=3$, thừa số cuối bằng 0, vì vậy các trị số đó là ba nghiệm.

\index{\py{fsolve}}
\index{nghiệm}

Nhưng nói chung bài toán sẽ không dễ như vậy. Khi đó \py{fsolve} có thể giúp ta. Trước hết, ta cần viết một hàm để ước lượng $f$:

\begin{python}
def func(x):
    return (x-1) * (x-2) * (x-3)
\end{python}

Bây giờ ta sẽ gọi \py{fsolve} như sau:

\begin{python}
fsolve(func, x0=0)
\end{python}

Đối số thứ nhất là hàm mà ta cần giải ra nghiệm. Đối số thứ hai, \py{x0}, là một dự đoán ban đầu về vị trí mà nghiệm có thể nằm ở đó. Nói chung, trị số dự đoán này mà càng sát nghiệm thực thì \py{fsolve} sẽ chạy càng nhanh. Trong trường hợp này, với đự đoán ban đầu \py{x0=0}, kết quả sẽ là 1.

Thường thì \py{fsolve} tìm ra nghiệm gần nhất với trị số dự đoán ban đầu này. Ở ví dụ đang xét, khi \py{x0=1.9}, \py{fsolve} trả lại 2, còn khi \py{x0=2.9}, \py{fsolve} trả lại 3.  Nhưng động thái này có thể sẽ không dự đoán được; với \py{x0=1.5}, \py{fsolve} vẫn trả lại 3.

Vậy ta sẽ sử dụng \py{fsolve} như thế nào để ước tính \py{r}?  

Thứ ta cần là trị số của \py{r} cho ta nhiệt độ cuối cùng của \SI{70}{\celsius}.  Để làm việc với \py{fsolve}, ta cần một hàm nhận vào \py{r} làm tham số rồi trả lại chênh lệch giữa nhiệt độ cuối cùng và trị số cần hướng tới:

\begin{python}
def error_func1(r):
    system = make_system(r=r)
    results = run_simulation(system, update)
    return system.T_final - 70
\end{python}

Tôi gọi một hàm như vậy là ``hàm sai số" vì nó trả lại hiệu giữa trị số tính được và trị số nhắm tới; hiệu số này là sai số. Khi ta tìm được trị số đúng của \py{r}, thì sai số này sẽ bằng 0.

\index{hàm sai số | error function}
\index{hàm!sai số}

Ta có thể thử \py{error_func1} như sau, với dự đoán ban đầu cho \py{r}:

\begin{python}
error_func1(r=0.01)
\end{python}

Kết quả là sai số bằng \SI{2.3}{\celsius}, vì nhiệt độ cuối cùng ứng với trị số \py{r} này còn quá cao.

Bây giờ ta có thể gọi \py{fsolve} như sau:

\begin{python}
solution = fsolve(error_func1, 0.01)
r_coffee = solution[0]
\end{python}

Giá trị trả lại từ \py{fsolve} là một mảng chỉ với một phần tử là nghiệm  \py{fsolve} tìm được.  Ở ví dụ này, \py{r_coffee} tính ra bằng khoảng \py{0.012}, có đơn vị là \si{\per\minute}.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap07-fig01.pdf}}
\caption{Nhiệt độ của cà phê và sữa theo thời gian.}
\label{chap07-fig01}
\end{figure}

Như một bài tập cho chương này, bạn cần dùng các bước này để ước tính \py{r_milk}.  

Với những giá trị đúng của \py{r_coffee} và \py{r_milk}, kết quả mô phỏng sẽ trông tựa như Hình~\ref{chap07-fig01}, trong đó thể hiện nhiệt độ của cà phê và sữa theo thời gian.


\section{Hoà trộn chất lỏng}

Khi ta trộn hai chất lỏng, nhiệt độ của hỗn hợp sẽ phụ thuộc vào nhiệt độ từng thành phần, nhưng sẽ không dễ để tính ra nhiệt độ này.

\index{hoà trộn | mixing}

Giả dụ rằng không có phản ứng hoá học nào thu nhiệt hay toả nhiệt, thì tổng nhiệt năng của hệ trước và sau khi hoà trộn vẫn giữ nguyên. Nói cách khác, nhiệt năng được {\bf bảo toàn}.

\index{bảo toàn năng lượng | conservation of energy}

Nếu nhiệt độ của chất lỏng thứ nhất là $T_1$, nhiệt độ của chất lỏng thứ hai là $T_2$, và nhiệt độ sau cùng của hỗn hợp là $T$, thì nhiệt truyền vào chất lỏng thứ nhất là $C_1 (T - T_1)$ và nhiệt truyền vào chất lỏng thứ hai là $C_2 (T - T_2)$, trong đó $C_1$ và $C_2$ là các khối lượng nhiệt của chất lỏng.

Để bảo toàn năng lượng, các lượng truyền nhiệt này cộng lại phải bằng 0:
%
\[ C_1 (T - T_1) + C_2 (T - T_2) = 0 \]
%
We can solve this equation for T:
%
\[ T = \frac{C_1 T_1 + C_2 T_2}{C_1 + C_2} \]
%
Với bài toán làm nguội cà phê, ta có dung tích từng chất lỏng. Nếu ta cũng có mật độ, $\rho$, và nhiệt dung riêng, $c_p$, ta có thể khối lượng nhiệt:
%
\[ C = \rho V c_p \]
%
Nếu ta giả sử rằng mật độ và nhiệt dung riêng của sữa và cà phê là như nhau, thì các số hạng sẽ triệt tiêu và ta có thể viết:
%
\[ T = \frac{V_1 T_1 + V_2 T_2}{V_1 + V_2} \]
%
trong đó $V_1$ và $V_2$ là thể tích các chất lỏng. Một bài tập đặt ra là bạn có thể tra tìm mật độ và nhiệt dung riêng của sữa xem cách xấp xỉ như trên có chuẩn không.

\index{dung tích | volume}
\index{mật độ | density}
\index{nhiệt dung riêng | specific heat}

Hàm sau đây nhận vào hai đối tượng \py{System} biểu diễn cho cà phê và sữa, rồi tạo nên một \py{System} mới để biểu diễn cho hỗn hợp:

\begin{python}
def mix(s1, s2):
    assert s1.t_end == s2.t_end
    
    V_mix = s1.volume + s2.volume
    
    T_mix = (s1.volume * s1.T_final + 
             s2.volume * s2.T_final) / V_mix
    
    mixture = make_system(T_init=T_mix,
                          t_end=0,
                          r=s1.r,
                          volume=V_mix)
    
    return mixture
\end{python}

Dòng lệnh đầu là một lệnh \py{assert}, vốn là một cách kiểm tra lỗi. Lệnh này so sánh \py{t_end} cho hai hệ thống để khẳng định rằng chúng được làm nguội trong cùng thời gian. Nếu không, \py{assert} hiển thị một lời thông báo lỗi và dừng chương trình.

\index{assert (câu lệnh) | (statement)}
\index{câu lệnh!assert}

Hai câu lệnh tiếp theo tính toán tổng dung tích hỗn hợp cùng nhiệt độ của nó. Sau cùng, \py{mix} tạo một đối tượng \py{System} mới rồi trả lại nó.

Hàm này sử dụng giá trị \py{r} từ \py{s1} làm giá trị \py{r} cho toàn hỗn hợp. Nếu \py{s1} biểu diễn cho cà phê, và chúng ta thêm sữa vào cà phê thì có lẽ việc chọn này là phù hợp. Mặt khác, khi ta tăng lượng chất lỏng vào cốc cà phê thì việc này có thể làm thay đổi \py{r}.  Do vậy, đây là một giả thiết quan trọng mà ta có thể sẽ cần phải quay trở lại xem xét.


\section{Hoà trộn lúc đầu hay lúc cuối?}

Bây giờ khi đã có đủ thứ cần để giải bài toán, trước hết tôi sẽ tạo nên đối tượng biểu diễn cho cà phê và sữa, rồi chạy mô phỏng 30 phút.

\begin{python}
coffee = make_system(T_init=90, t_end=30, 
                     r=r_coffee, volume=300)
coffee_results = run_simulation(coffee, update_func)

milk = make_system(T_init=5, t_end=30, 
                   r=r_milk, volume=50)
milk_results = run_simulation(milk, update_func)
\end{python}

Nhiệt độ cuối cùng, trước khi hoà trộn, là \SI{70}{\celsius} và \SI{21.8}{\celsius}.  Sau đó tôi sẽ trộn chúng lại:

\begin{python}
mix_last = mix(coffee, milk)
\end{python}

Sau khi hoà trộn, nhiệt độ là \SI{63.1}{\celsius}, như vậy vẫn đủ ấm để thưởng thức cà phê sữa. Song nếu ta cho sữa vào trước thì có hay hơn không?

Để biết điều này, tôi sẽ tạo nên những đối tượng mới cho cà phê và sữa:

\begin{python}
coffee = make_system(T_init=90, r=r_coffee, 
                     volume=300, t_end=30)
milk = make_system(T_init=5, r=r_milk, 
                   volume=50, t_end=30)
\end{python}

Rồi trộn chúng lại và mô phỏng 30 phút:

\begin{python}
mix_first = mix(coffee, milk)
results = run_simulation(mix_first, update_func)
\end{python}

Nhiệt độ cuối cùng chỉ là \SI{61.4}{\celsius}.  Như vậy có vẻ như là thêm sữa vào sau cùng thì sẽ tốt hơn, nhiệt độ hơn những \SI{1.7}{\celsius}.  Nhưng phải chăng đó là cách tốt nhất mà ta có thể làm được?


\section{Tối ưu hoá}

Cho sữa vào sau 30 phút thì tốt hơn là cho vào ngay, nhưng có thể vẫn còn cách làm trung gian nào đó thậm chí còn tốt hơn nữa. Để tìm ra điều này, tôi sẽ dùng hàm dưới đây, hàm này nhận vào \py{t_add} như một tham số:

\index{tối ưu hoá | optimization}

\begin{python}
def run_and_mix(t_add, t_total=30):
    coffee = make_system(T_init=90, t_end=t_add, 
                         r=r_coffee, volume=300)
    coffee_results = run_simulation(coffee, update_func)

    milk = make_system(T_init=5, t_end=t_add, 
                       r=r_milk, volume=50)
    milk_results = run_simulation(milk, update_func)
    
    mixture = mix(coffee, milk)
    mixture.t_end = t_total - t_add
    results = run_simulation(mixture, update_func)

    return mixture.T_final
\end{python}

Khi \py{t_add=0}, ta thêm sữa ngay lập tức; khi \py{t_add=30}, ta thêm sữa vào sau cùng. Bây giờ ta có thể quét khoảng giá trị trung gian:

\begin{python}
sweep = SweepSeries()
for t_add in linspace(0, 30, 11):
    sweep[t_add] = run_and_mix(t_add, 30)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap07-fig02.pdf}}
\caption{Nhiệt độ cuối cùng như một hàm theo thời gian cho sữa vào.}
\label{chap07-fig02}
\end{figure}

Hình~\ref{chap07-fig02} thể hiện kết quả. Một lần nữa, lưu ý rằng đây là cách quét tham số chứ không phải chuỗi thời gian. Trục x là thời gian khi ta thêm sữa, chứ không phải chỉ số của một dãy \py{TimeSeries}.

Nhiệt độ cuối cùng đạt cực đại khi \py{t_add=30}, bởi vậy việc cho sữa lúc cuối là tối ưu.

Trong quyển mã lệnh cho chương này bạn sẽ có cơ hội khảo sát cách giải này và thử một vài biến thể nữa. Chẳng hạn, nếu như cửa hàng cà phê không cho tôi đựng sữa vào một cốc riêng nhưng tôi có sẵn chai sữa trong tủ lạnh ở văn phòng rồi. Khi đó, giữa việc cho sữa vào ngay ở cửa hàng hay đợi đến văn phòng mới cho sữa, đằng nào hay hơn?


\section{Giải tích}

Việc mô phỏng định luật cấp nhiệt Newton xem chừng ngốc nghếch vì ta có thể giải được phương trình vi phân bằng cách giải tích. Nếu
%
\[ \frac{dT}{dt} = -r (T - T_{env}) \]
%
thì nghiệm tổng quát là 
%
\[ T{\left (t \right )} = C_{1} \exp(-r t) + T_{env} \]
%
và nghiệm riêng khi $T(0) = T_{init}$ là
%
\[ T_{env} + \left(- T_{env} + T_{init}\right) \exp(-r t) \]
%
Bạn có thể thấy cách tôi tìm nghiệm bằng SymPy trong file \py{chap16sympy.ipynb} thuộc kho mã lệnh của cuốn sách. Nếu bạn muốn xem cách giải thủ công, hãy xem video này: \url{http://modsimpy.com/khan3}.

\index{giải tích | analysis}
\index{SymPy}

Bây giờ ta có thể dùng số liệu quan sát để ước tính tham số $r$.  Nếu ta quan sát được $T(t_{end}) = T_{end}$, ta có thể thay thế $t_{end}$ và $T_{end}$ vào nghiệm riêng để giải ra $r$.  Kết quả là:
%
\[ r = \frac{1}{t_{end}} \log{\left (\frac{T_{init} - T_{env}}{T_{end} - T_{env}} \right )} \]
%
Thay $t_{end}=30$ và $T_{end}=70$ (vẫn với $T_{init}=90$ và $T_{env}=22$), kết quả ước tính cho ta $r$ bằng 0.0116.

Ta có thể dùng hàm sau đây để tính ra chuỗi thời gian:

\index{tháo | unpack}

\begin{python}
def run_analysis(system):
    unpack(system)
    
    T_init = init.T    
    ts = linrange(t_0, t_end, dt, endpoint=True)
    
    T_array = T_env + (T_init - T_env) * exp(-r * ts)
    
    results = TimeFrame(T_array, index=ts, columns=['T'])
    system.T_final = get_last_value(results.T)

    return results
\end{python}

Hàm này tương tự như \py{run_simulation}; nó nhận vào \py{System} như một tham số và trả lại kết quả là một \py{TimeFrame}.

Vì \py{linrange} trả lại một mảng NumPy, \py{T_array} cũng là một mảng NumPy. Để nhất quán với \py{run_simulation}, ta phải đặt nó vào trong một \py{TimeFrame}.

Ta có thể chạy nó như sau:
\index{\py{run_analysis}}

\begin{python}
r_coffee2 = 0.0116
coffee2 = make_system(T_init=90, r=r_coffee2, 
                      volume=300, t_end=30)
results = run_analysis(coffee2)
\end{python}

Nhiệt độ cuối cùng là \SI{70}{\celsius}, như trị số cần đạt được. Thực ra, kết quả này giống hệt như những gì đạt được qua mô phỏng, chỉ có chút khác biệt do làm tròn số.

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap16.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


%%\part{Pharmacokinetics}

\chapter{Dược động học}
\label{chap17}

{\bf Dược động học} là ngành học về các hiện tượng thuốc cùng các chất khác di chuyển trong cơ thể, phản ứng và tiêu huỷ. Trong chương này, ta sẽ lập trình một trong những mô hình dược động thông dụng nhất: {\bf mô hình tối thiểu} cho glucose và insulin trong mạch máu.

\index{dược động học | pharmacokinetics}

Ta sẽ dùng mô hình này để khớp số liệu thu thập từ một bệnh nhân, và sử dụng các tham số từ mô hình đã khớp để lượng hoá khả năng của bệnh nhân sản sinh ra insulin và xử lý glucose.

\index{glucose}
\index{insulin}

Tôi trình bày chương này theo bài viết của Bergman (2005) ``Minimal Model" (tóm tắt ở \url{http://modsimpy.com/bergman},
file PDF ở \url{http://modsimpy.com/minmod}).



\section{Hệ glucose-insulin}

{\bf Glucose} là một dạng đường lưu thông trong máu động vật; nó được dùng là nhiên liệu để các bó cơ, não cùng các cơ quan khác hoạt động. Nồng độ đường huyết được kiểm soát bởi hệ hoócmôn, và đặc biệt là bởi {\bf insulin}, vốn được sản sinh ra từ tuỵ và có hiệu ứng làm giảm đường huyết.

\index{tuỵ | pancreas}

Ở những người mà tuyến tuỵ hoạt động bình thường thì hệ hoócmôn duy trì {\bf cân bằng nội sinh}; nghĩa là nó giữ cho nồng độ đường huyết luôn trong khoảng không quá cao cũng không quá thấp.

Nhưng nếu tuỵ không tiết đủ insulin, hay nếu các tế bào có chức năng phản hồi insulin trở nên kém nhạy thì đường huyết có thể tăng vọt, gây nên tình trạng gọi là {\bf tăng đường huyết}.  Tình trạng tăng đường huyết nặng, kéo dài là một triệu chứng rõ của bệnh {\bf đái tháo đường}, một bệnh nghiêm trọng ảnh hưởng tới 10\% dân số Hoa Kỳ. (Xem \url{http://modsimpy.com/cdc}).

\index{tăng đường huyết | hyperglycemia}
\index{đái tháo đường | diabetes}

Một trong những phép thử thông dụng nhất cho sự tăng đường huyết và bệnh đái tháo đường là xét nghiệm dung nạp glucose intravenous lấy mẫu thường xuyên (frequently sampled intravenous glucose tolerance test, FSIGT), trong đó glucose được tiêm vào mạch máu của chủ thể nhịn ăn trước khi tiêm; sau đó các mẫu máu được lấy cách nhau 2--10 phút trong suốt 3 giờ. Các mẫu này được phân tích để đo nồng độ glucose và insulin.

\index{FSIGT}

Bằng cách phân tích các kết quả đo này, ta có thể ước tính ra vài tham số của phản hồi từ chủ thể; trong đó quan trọng nhất là tham số kí hiệu $S_I$, vốn định lượng hiệu ứng insulin đối với tốc độ giảm đường huyết.


\section{Mô hình glucose tối thiểu}

``Mô hình tối thiểu" được Bergman, Ider, Bowden, và Cobelli\footnote{Bergman RN, Ider YZ, Bowden CR, Cobelli C., ``Quantitative estimation of insulin sensitivity", Am J Physiol. 1979 Jun;236(6):E667-77.  Abstract at \url{http://modsimpy.com/insulin}.} đề xuất.
Mô hình này gồm 2 phần: mô hình glucose và mô hình insulin model.  Tôi sẽ trình bày cách lập trình mô hình glucose; bạn sẽ có dịp lập trình mô hình insulin như một nghiên cứu tình huống cụ thể.

\index{mô hình tối thiểu | minimal model}

Mô hình gốc đã được phát triển vào thập niên 1970; từ đó có thêm nhiều biến thể và phiên bản mở rộng được đề xuất. Những nhận xét của Bergman về việc phát triển mô hình đã giúp ta hiểu thêm về công việc:

\begin{quote}
Chúng tôi đã áp dụng nguyên lý Lưỡi cạo Occam, nghĩa là đặt câu hỏi
đâu là mô hình đơn giản nhất dựa trên sinh lý học đã biết
để giải thích được liên hệ insulin-glucose 
xuất hiện trong số liệu. Một mô hình như vậy phải đủ
đơn giản để xét đến sự toàn bộ glucose đo được (cho trước
số liệu insulin đầu vào), nhưng cũng phải dùng đến
phép toán để ước tính tất cả tham số đặc trưng
cho mô hình từ một bộ số liệu đơn lẻ (và do vậy tránh
những giả thiết không thể kiểm chứng).
\end{quote}

Những mô hình hữu ích nhất là những cái đạt tới sự cân bằng này: bao gồm đủ thực tế để nắm bắt những đặc điểm thiết yếu của hệ thống mà lại không quá phức tạp, để còn sự thực dụng. Ở đây, giới hạn thực dụng là khả năng từ số liệu có thể ước tính ra tham số mô hình, và có thể diễn giải các tham số này một cách hợp lẽ.

\index{Lưỡi cạo Occam | Occam's Razor}

Bergman thảo luận những đặc điểm mà ông cùng cộng sự đã cho rằng thiết yếu:

\begin{quote}
(1) Glucose, một khi được tăng vọt khi tiêm, sẽ trở lại mức nền do
hai hiệu ứng: bản thân từ chính glucose để chuẩn hoá nồng độ
của nó [...] cũng như hiệu ứng xúc tác từ insulin để cho phép
glucose tự chuẩn hoá (2) Chúng tôi cũng phát hiện thấy rằng
hiệu ứng của insulin lên lượng giảm ròng của glucose
phải rất chậm chạp --- nghĩa là insulin hoạt động rất chậm vì 
trước hết insulin phải di chuyển từ plasma vào một khoang chứa tách biệt [...] để gây tác động lên sự tiêu huỷ glucose.
\end{quote}

Diễn đạt điểm thứ hai bằng cách khác, hiệu ứng của insulin đối với thải loại glucose, như thấy ở số liệu, sẽ diễn ra chậm hơn so với ta hình dung nếu như nó phụ thuộc chủ yếu vào nồng độ insulin trong máu.  Nhóm của Bergman đặt ra giả thiết rằng insulin phải di chuyển tương đối chậm, từ máu vào trong một ``khoang chứa'' nơi nó sẽ phát huy tác dụng.

\index{mô hình khoang chứa | compartment model}

Lúc bấy giờ, khoang chứa là một cách trừu tượng hoá có thể có, hoặc cũng có thể không phản ánh một thứ cụ thể. Về sau này, theo Bergman, thứ đó ``đã cho thấy là dịch mô kẽ'', tức là chất lỏng bao quanh tế bào mô. Trong lịch sử mô hình toán học, rất thường thấy việc những thực thể tưởng tượng được thêm vào mô hình để đạt được những hiệu ứng cụ thể, sau này đã thấy xuất hiện tương ứng với những thứ có thực.

\index{dịch mô kẽ | interstitial fluid}

Mô hình glucose bao gồm hai phương trình vi phân:
%
\[ \frac{dG}{dt} = -k_1 \left[ G(t) - G_b \right] - X(t) G(t)  \]
%
\[ \frac{dX}{dt} = k_3 \left[I(t) - I_b \right] - k_2 X(t) \]
%
trong đó

\begin{itemize}

\item $G$ là nồng độ đường huyết dưới dạng hàm theo thời gian và $dG/dt$ là tốc độ thay đổi của nó.

\item $I$ là nồng độ insulin trong máu như hàm số thời gian, vốn được lấy như một đầu vào mô hình, dựa trên số liệu đo.

\item $G_b$ là nồng độ nền của đường huyết còn $I_b$ là nồng độ nền của insulin trong máu, hay là nồng độ ở mức cân bằng. Cả hai hằng số này đều được ước tính từ những đo đạc ban đầu hay cuối của xét nghiệm.

\item $X$ là nồng độ insulin trong dịch mô, biểu diễn như một hàm theo thời gian, còn $dX/dt$ là tốc độ thay đổi của nó.

\item $k_1$, $k_2$, và $k_3$ là những tham số dương để kiểm soát tốc độ xuất hiện và biến mất của glucose và insulin. 

\end{itemize}

Ta có thể diễn giải từng đại lượng trong phương trình:

\begin{itemize}

\item $-k_1 \left[ G(t) - G_b \right]$ là tốc độ biến mất của glucose do hiệu ứng từ bản thân glucose.  Khi $G(t)$ cao hơn mức nền, $G_b$, thì đại lượng nêu trên sẽ âm; còn khi $G(t)$ thấp hơn mức nền thì đại lượng sẽ dương. Như vậy khi không có insulin, đại lượng này có xu hướng phục hồi đường huyết về mức nền.

\item $-X(t) G(t)$ mô hình hoá tương tác giữa glucose và insulin trong dịch mô, do vậy tốc độ này sẽ tăng lên khi $X$ hoặc $G$ tăng. Đại lượng này không đòi hỏi một tham số tốc độ vì đơn vị của $X$ không quy định sẵn; ta có thể coi $X$ đo bằng bất kì đơn vị nào khiến tham số của đại lượng này bằng 1.

\item $k_3 \left[ I(t) - I_b \right]$ là tốc độ mà insulin khuếch tán giữa máu và dịch mô. Khi $I(t)$ cao hơn mức nền, insulin khuếch tán từ máu vào trong dịch mô. Khi $I(t)$ thấp dưới mức nền thì insulin khuếch tán từ mô vào máu.

\item $-k_2 X(t)$ là tốc độ biến mất của insulin khỏi dịch mô khi nó bị tiêu thụ hoặc phân huỷ.

\end{itemize}

Trạng thái ban đầu của mô hình là $X(0) = I_b$ và $G(0) = G_0$, trong đó $G_0$ là một hằng số biểu diễn nồng độ đường huyết ngay sau khi tiêm. Về lý thuyết ta có thể ước tính đyiwhc $G_0$ dựa theo đo đạc, nhưng trong thực tế vẫn cần thời gian để glucose lan truyền trong thể máu. Vì $G_0$ không thể đo đuaowjc, nó sẽ được coi như một {\bf tham số tự do} của mô hình, theo nghĩa là ta có quyền từ do lựa chọn trị số để nó khớp với số liệu đo nhất.

\index{tham số tự do | free parameter}


\section{Số liệu}

Để phát triển và kiểm thử mô hình, tôi dùng số liệu của Pacini và Bergman\footnote{``MINMOD: A computer program to calculate insulin sensitivity and pancreatic responsivity from the frequently sampled intravenous glucose tolerance test", {\em Computer Methods and Programs in Biomedicine} 23: 113-122, 1986.}.  Bộ số liệu có trong một file thuộc kho mã lệnh kèm theo cuốn sách này; từ số liệu đó ta có thể đọc vào một \py{DataFrame}:

\index{số liệu | data}
\index{đối tượng DataFrame object}

\begin{python}
data = pd.read_csv('data/glucose_insulin.csv',
                   index_col='time')
\end{python}

\py{data} có hai cột: \py{glucose} là nồng độ đường máu theo \si{\milli\gram/\deci\liter}; \py{insulin} là nồng độ insulin trong máu theo \si{\micro U\per\milli\liter} (một ``đơn vị" y học, kí hiệu \si{U}, là một lượng định nghĩa tiện dùng trong ngữ cảnh này).  Các số thứ tự là thời gian đo bằng \si{\minute}.

\index{nồng độ | concentration}

\begin{figure}
\centerline{\includegraphics[width=3.5in]{figs/chap08-fig01.pdf}}
\caption{Nồng độ glucose và insulin đo được bởi FSIGT.}
\label{chap08-fig01}
\end{figure}

Hình~\ref{chap08-fig01} cho thấy các nồng độ glucose và insulin trong suốt \SI{182}{\minute} ở một chủ thể có mức sản xuất và độ nhạy insulin bình thường.


\section{Nội suy}
\label{interpolate}

Trước khi ta sẵn sàng lập trình mô hình, có một vấn đề cần giải quyết. Trong các phương trình vi phân, $I$ là một hàm có thể ước lượng tại bất cứ thời gian $t$ nào.  Nhưng trong \py{DataFrame}, ta chỉ có kết quả đo đạc tại những thời điểm rời rạc thôi.  Đây là vấn đề đặt ra cho phép nội suy!

\index{nội suy | interpolation}

Thư viện \py{modsim} cung cấp một hàm có tên \py{interpolate}, đây là một dạng bao gói hàm \py{interp1d} trong SciPy.  Hàm này nhận vào bất kì kiểu dãy \py{Series} nào làm tham số, kể cả \py{TimeSeries} và \py{SweepSeries}, rồi trả lại một hàm khác. Đúng đó, tôi đã bảo rằng nó trả lại một {\em hàm}.

\index{hàm!kết quả trả lại}
\index{Series}
\index{nội suy | interpolate}
\index{interp1d}
\index{SciPy}

Do vậy ta có thể gọi \py{interpolate} như sau:

\begin{python}
I = interpolate(data.insulin)
\end{python}

Rồi ta có thể gọi hàm mới, \py{I}, như sau:

\begin{python}
I(18)
\end{python}

Kết quả là 31.66, vốn là một phép nội suy tuyến tính giữa các trị số thực đo tại \py{t=16} và \py{t=19}.  Ta cũng có thể truyền một mảng làm đối số tới \py{I}:

\begin{python}
ts = linrange(t_0, t_end, endpoint=True)
I(ts)
\end{python}

Kết quả là một mảng các giá trị nội suy tại những điểm cách đều nhau của \py{t}.

\index{linrange}
\index{NumPy}

\py{interpolate} có thể nhận thêm các đối số nữa; các đối số này được truyền tiếp đến \py{interp1d}.  Bạn có thể đọc về khả năng này ở \url{http://modsimpy.com/interp}.


\section{Lập trình}
\label{glucose}

Để bắt đầu, tôi sẽ giả sử rằng các tham số mô hình đều đã biết rồi. Ta sẽ lập trình mô hình rồi dùng nó để phát sinh chuỗi thời gian cho \py{G} và \py{X}.  Sau đó, ta sẽ xem cách tìm bộ tham số để phát sinh được chuỗi sao cho khớp nhất với những số liệu hiện có.

Lợi dụng những kết quả ước tính từ phần trước, ta sẽ bắt đầu với những trị số sau:

\begin{python}
params = Params(G0 = 290,
                k1 = 0.03,
                k2 = 0.02,
                k3 = 1e-05)
\end{python}

Một đối tượng \py{Params} cũng tương tự như đối tượng \py{System} hay \py{State}; nó giúp ta lưu giữ một tập hợp các tham số.

\index{đối tượng State object}
\index{đối tượng System object}

Ta có thể truyền \py{params} và \py{data} tới cho \py{make_system}:

\begin{python}
def make_system(params, data):
    G0, k1, k2, k3 = params
    
    Gb = data.glucose[0]
    Ib = data.insulin[0]
    
    t_0 = get_first_label(data)
    t_end = get_last_label(data)

    init = State(G=G0, X=0)
    
    return System(G0=G0, k1=k1, k2=k2, k3=k3,
                  init=init, Gb=Gb, Ib=Ib,
                  t_0=t_0, t_end=t_end, dt=2)
\end{python}

\py{make_system} sử dụng những số liệu đo tại \py{t=0} làm các mức nền \py{Gb} và \py{Ib}.
Hàm này lấy \py{t_0} và \py{t_end} từ bộ số liệu.
Và nó dùng tham số \py{G0} làm giá trị ban đầu cho \py{G}.
Sau đó, nó gói tất cả mọi thứ vào một đối tượng \py{System}.

Sau đây là hàm cập nhật:

\index{hàm cập nhật | update function}
\index{hàm!cập nhật}

\begin{python}
def update_func(state, t, system):
    G, X = state
    unpack(system)
        
    dGdt = -k1 * (G - Gb) - X*G
    dXdt = k3 * (I(t) - Ib) - k2 * X
    
    G += dGdt * dt
    X += dXdt * dt

    return State(G=G, X=X)
\end{python}

Như thường lệ, hàm cập nhật này nhận vào các tham số gồm một đối tượng \py{State}, một thời gian, và một đối tượng \py{System}. Dòng đầu tiên \py{update} sử dụng phép gán bội để kết xuất các giá trị hiện thời của \py{G} và \py{X}.  Dòng thứ hai sử dụng \py{unpack} giúp cho ta đọc được các biến hệ thống mà không cần dùng đến toán tử dấu chấm.

\index{tháo | unpack}

Có thể tính được các đạo hàm \py{dGdt} và \py{dXdt} rất dễ dàng; ta chỉ việc chuyển các phương trình từ biểu thức toán học sang mã lệnh Python.

\index{đạo hàm | derivative}

Sau đó, để thực hiện cập nhật, ta đem nhân từng đạo hàm với bước thời gian rời rạc, \py{dt}, mà ở ví dụ này bằng \SI{2}{\minute}. Kết quả trả lại là một đối tượng \py{State} với các trị số mới của \py{G} và \py{X}.

\index{bước thời gian | time step}

Trước khi chạy mô phỏng, ta nên chạy hàm cập nhật với các điều kiện ban đầu:

\begin{python}
update_func(system.init, system.t_0, system)
\end{python}

Bây giờ ta đã sẵn sàng chạy mô phỏng này rồi. Ta sẽ dùng phiên bản \py{run_simulation} này, nó rất giống với các phiên bản trước đó:

\index{\py{run_simulation}}

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t0] = init
    ts = linrange(t0, t_end, dt)
    
    for t in ts:
        frame.row[t+dt] = update_func(frame.row[t], t, system)
    
    return frame
\end{python}

Giờ thì ta có thể chạy mã lệnh như sau:

\begin{python}
results = run_simulation(system, update_func)
\end{python}

\begin{figure}
\centerline{\includegraphics[width=3.5in]{figs/chap08-fig03.pdf}}
\caption{Kết quả từ mô phỏng mô hình glucose tối thiểu.}
\label{chap08-fig03}
\end{figure}

Biểu đồ phía trên ở Hình~\ref{chap08-fig03} cho thấy các mức glucose mô phỏng được bằng mô hình cùng với số liệu đo đạc. Biểu đồ phía dưới cho thấy mức insulin mô phỏng trong dịch mô, đại lượng này không có đơn vị, và không nên nhầm với các mức insulin đo được trong máu.

Với các tham số tôi đã chọn, mô hình khớp với số liệu rất tốt, song ta còn có thể làm tốt hơn nữa.

Ở chương tiếp theo, ta sẽ thay \py{run_simulation} bằng một bộ giải phương trình vi phân tốt hơn, rồi tìm kiếm tham số cho ta sự khớp nhất với số liệu đo được.

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap17.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.



\chapter{Phương pháp số}
\label{chap18}

Ở chương trước, ta đã lập trình mô hình glucose tối thiểu bằng \py{run_simulation}; hàm này giải phương trình vi phân bằng những bước thời gian rời rạc. Phương pháp này phát huy tác dụng trong nhiều trường hợp vận dụng, nhưng nó vẫn không chính xác lắm. Ở mục này ta khám phá một giải pháp tốt hơn: dùng {\bf bộ giải PVT}.

Sau đó ta sẽ sử dụng thuật toán tìm kiếm để tính ra tham số mô hình cho ta mức độ khớp tốt nhất với số liệu.


\section{Giải phương trình vi phân}
\label{slopefunc}

Cho đến giờ, ta đã giải các phương trình vi phân bằng cách viết chúng dưới dạng phương trình sai phân. Ở ví dụ này, các phương trình sai phân là:
%
\[ \frac{dG}{dt} = -k_1 \left[ G(t) - G_b \right] - X(t) G(t)  \]
%
\[ \frac{dX}{dt} = k_3 \left[I(t) - I_b \right] - k_2 X(t) \]
%
Nếu nhân cả hai vế với $dt$, ta được:
%
\[ dG = \left[ -k_1 \left[ G(t) - G_b \right] - X(t) G(t) \right] dt  \]
%
\[ dX = \left[ k_3 \left[I(t) - I_b \right] - k_2 X(t) \right] dt \]
%
Khi $dt$ rất nhỏ, hay đúng hơn là {\bf nhỏ vô cùng}, thì phương trình trên là chính xác. Nhưng trong mô phỏng, $dt$ chỉ bằng \SI{2}{\minute}, tuy nhỏ nhưng chưa phải nhỏ vô cùng. Hệ quả là, trong mô phỏng đã coi rằng những đạo hàm $dG/dt$ và $dX/dt$ đều không đổi suốt mỗi bước thời gian \SI{2}{\minute}.

\index{bước thời gian | time step}

Phương pháp này, trong đó ước lượng những đạo hàm tại các bước thời gian rời rạc và coi rằng chúng không đổi giữa những giá trị đó, được gọi là {\bf phương pháp Euler} (xem \url{http://modsimpy.com/euler}).

\index{phương pháp Euler | Euler's method}

Phương pháp Euler đủ tốt để giải bài toán đơn giản, nhưng vẫn còn nhiều cách tốt hơn để giải các phương trình vi phân. Thay vì tự tay lập trình những phương pháp này, ta sẽ dùng các hàm có trong SciPy.  Thư viện \py{modsim} cung cấp một hàm có tên \py{run_ode_solver}, hàm này lại dùng đến hàm \py{solve_ivp} của SciPy.

\index{SciPy}

Chữ ``ODE" trong \py{run_ode_solver} viết tắt từ ``ordinary differential equation integrator" (tính tích phân cho phương trình vi phân thường). Các phương trình cần giải thuộc dạng ``thường'' vì mọi đạo hàm trong đó đều lấy theo cùng một biến; nói cách khác là không có mặt đạo hàm riêng.

Chữ ``IVP" trong \py{solve_ivp} viết tắt từ ``initial value problem" (bài toán điều kiện đầu), để chỉ các bài toán mà bạn khởi đầu bằng một điều kiện đầu rồi hình dung xem hệ thống sẽ thay đổi ra sao theo thời gian, hay đôi khi là thay đổi trong không gian hay thay đổi theo một đại lượng khác.

\index{phương trình vi phân thường | ordinary differential equation}
\index{bài toán điều kiện đầu | initial value problem}

\py{solve_ivp} có thể dùng một tỏng số vài bộ giải PVT; mặc định nó sẽ dùng {\bf phương pháp Runge-Kutta-Fehlberg}.  Các phương pháp này đều {\bf thích ứng}; nghĩa là chúng sẽ tự động chọn ra độ dài bước, và sẽ sử dụng các bước ngắn khi cần để hạn chế sai số, và những bước dài nếu có thể để tính được nhanh hơn.

Để dùng \py{run_ode_solver}, ta cần phải cung cấp một ``hàm độ dốc", như sau:

\index{độ dốc (hàm) | slope function}
\index{hàm!độ dốc}
\index{tháo | unpack}

\begin{python}
def slope_func(state, t, system):
    G, X = state
    unpack(system)
    
    dGdt = -k1 * (G - Gb) - X*G
    dXdt = k3 * (I(t) - Ib) - k2 * X
    
    return dGdt, dXdt
\end{python}

\py{slope_func} cũng tương tự với \py{update_func}; thực ra nó nhận lấy tham số với thứ tự y hệt. Nhưng \py{slope_func} lại đơn giản hơn, vì tất cả những gì ta cần làm là đi tính các đạo hàm, tức là những độ dốc. Ta không phải cập nhật; \py{run_ode_solver} đã thay ta làm điều này rồi.


\index{\py{run_ode_solver}}

Bây giờ ta có thể gọi \py{run_ode_solver} như sau:

\begin{python}
results, details = run_ode_solver(system, slope_func, 
                                  t_eval=data.index)
\end{python}

\py{run_ode_solver} is similar to \py{run_simulation}: it takes a \py{System} object and a slope function as parameters, and returns a \py{TimeFrame} as a result.  \py{results} has one row for each time step and one column for each state variable.  In this example, the rows are the values from \py{data.index}; the columns are the state variables, \py{G} and \py{X}.
 
\index{đối tượng TimeFrame object}

\py{run_ode_solver} cũng trả lại \py{details}, vốn là một chuỗi \py{ModSimSeries} với thông tin về quá trình chạy của bộ giải, bao gồm mã số đánh dấu cho thành công, thông điệp chẩn đoán và những thông tin khác. Một chuỗi \py{ModSimSeries} cũng giống một đối tượng \py{System} hay \py{State}; nó chứa tập hợp các biến cùng giá trị của chúng.

\index{ModSimSeries}

\py{run_ode_solver} nhận một đối số tuỳ chọn; \py{t_eval}, để biểu thị rằng ta có muốn lượng giá nghiệm số không. Trong trường hpjw này ta muốn kết quả phải có cùng bước thời gian như số liệu để tiện so sánh.

Kết quả thu được cũng tương tự những gì trên Hình~\ref{chap08-fig03}.  Mức chênh lệch tương đối lớn nhất còn dưới 1\%.


\section{Bình phương nhỏ nhất}

Cho tới giờ ta đã nhận những tham số như được cấp, song nhìn chung mọi chuyện sẽ không dễ như vậy. Thường thì ta sẽ được cấp số liệu và phải đi tìm những tham số cho ra một chuỗi thời gian sao cho khớp nhất với số liệu đó.

\index{khớp số liệu | fitting data}

Ta sẽ thực hiện điều này theo hai bước:

\begin{enumerate}

\item Trước hết ta sẽ định nghĩa một {\bf hàm sai số} nhận vào một tập hợp tham số, rồi mô phỏng hệ thống với các tham số đã cho, và tính các sai số, tức là hiệu số giữa kết quả mô phỏng và số liệu hiện có.

\index{sai số (hàm) | error function}
\index{hàm!sai số}

\item Sau đó ta sẽ dùng \py{fit_leastsq}, đẻ tìm kiếm các tham số làm cho sai số quân phương (MSE) là nhỏ nhất.

\index{\py{fit_leastsq}}
\index{leastsq}
\index{sai số quân phương | mean squared error}
\index{MSE}

\end{enumerate}

Khi chạy \py{fit_leastsq}, hàm này gọi đến \py{error_func} nhiều lần, mỗi lần lại với một tập tham số khác, cho đến khi nó hội tụ với các tham số làm cực tiểu hoá MSE.

\index{\py{error_func}}

Sau đây là hàm sai số:

\begin{python}
def error_func(params, data):
    system = make_system(params, data)
    results, details = run_ode_solver(system, slope_func)
    errors = results.G - data.glucose
    return errors
\end{python}

\py{error_func} nhận hai tham số gồm đối tượng \py{Params} và \py{DataFrame} có chứa số liệu thực đo. Nó dùng \py{make_system} để tạo ra đối tượng \py{System}, rồi gọi \py{run_ode_solver} bằng chính hàm độ dốc mà ta đã thấy ở Mục~\ref{slopefunc}.

Sau đó, nó tính hiệu số giữa kết quả mô phỏng và số liệu. Vì \py{results.G} và \py{data.glucose} đều là những đối tượng \py{Series} nên \py{errors} cũng là một \py{Series}.

\index{Series}
\index{\py{run_ode_solver}}

Bây giờ để thực hiện chính việc cực tiểu hoá, ta chạy \py{fit_leastsq}:

\begin{python}
best_params, details = fit_leastsq(error_func, params, data)
\end{python}

Giá trị trả về thứ nhất là một đối tượng \py{Params} với những tham số để cho sự khớp nhất với số liệu hiện có. Giá trị trả lại thứ hai là một đối tượng \py{ModSimSeries} với thông tin bổ sung.


\section{Diễn giải tham số}

Để thấy kết quả, ta có thể truyền \py{best_params} tới \py{make_system} rồi chạy mô phỏng:

\begin{python}
system = make_system(best_params, data)
results, details = run_ode_solver(system, slope_func,
                                  t_eval=data.index)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap08-fig04.pdf}}
\caption{Mô phỏng mô hình glucose tối thiểu với các tham số làm cực tiểu sai số MSE.}
\label{chap08-fig04}
\end{figure}

Hình~\ref{chap08-fig04} cho thấy kết quả. Mô phỏng đã rất khớp với số liệu đo đạc, ngoại trừ vài phút đầu tiên ngay sau khi tiêm.

Nhưng ta cũng chẳng trông đợi mô hình sẽ hoạt động tốt ở giai đoạn đầu này.

Vấn đề là ở chỗ mô hình có tính {\bf phi không gian}; nghĩa là nó không xét đến nồng độ khác nhau trên các phần cơ thể khác nhau. Trái lại, nó coi như nồng độ của glucose và insulin trong máu, cũng đều không đổi trên toàn bộ cơ thể. Cách biểu diễn cơ thể như thế này được các chuyên gia gọi là mô hình ``bịch máu".

\index{mô hình phi không gian | non-spatial model}
\index{bịch máu | bag of blood}

Ngay sau khi tiêm, sẽ cần thời gian để lượng glucose thêm vào luân chuyển trong cơ thể. Trong lúc đó, ta không thể trông đợi mô hình phi không gian đạt độ chính xác được. Vì vậy, không nên quá khắt khe với giá trị ước tính \py{G0}; nó chỉ hữu ích để khớp mô hình chứ không nhằm tương ứng với một đại lượng vật lý đo đạc được.

Mặt khác, những tham số còn lại đều có ý nghĩa; và thực tế chúng chính là lí do để mô hình hữu dụng. Bằng cách dùng những tham số khớp nhất, ta có thể ước tính hai đại lượng cần quan tâm:

\index{hiệu quả glucose | glucose effectiveness}
\index{độ nhạy insulin | insulin sensitivity}

\begin{itemize}

\item ``Hiệu quả glucose", $E$, vốn là xu thế mà việc tăng mức glucose sẽ khiến suy giảm glucose.  

\item ``Độ nhạy insulin", $S$, vốn là khả năng mà mức tăng insuline trong máu làm nâng cao hiệu quả glucose.

\end{itemize}

Hiệu quả glucose được định nghĩa là mức thay đổi của $dG/dt$ khi ta thay đổi $G$:
%
\[ E \equiv - \frac{\delta \dot{G}}{\delta G} \]
%
trong đó $\dot{G}$ là chữ viết tắt cho $dG/dt$.  Lấy đạo hàm của $dG/dt$ theo $G$, ta được
%
\[ E = k_1 + X \]
%
{\bf Chỉ số hiệu quả glucose}, $S_G$, chính là giá trị của $E$ khi insulin trong máu gần bằng mức nền của nó, $I_b$.  Trong trường hợp này, $X$ tiệm cận 0 còn $E$ tiệm cận $k_1$.  Vì vậy, ta có thể dùng giá trị khớp nhất của $k_1$ làm ước tính cho $S_G$.

\index{mức nền | basal level}

Độ nhạy insulin được định nghĩa là mức thay đổi của $E$ khi ta thay đổi $I$:
%
\[ S \equiv - \frac{\delta E}{\delta I} \]
%
{\bf Chỉ số độ nhạy insulin}, $S_I$, là giá trị của $S$ khi cả $E$ và $I$ đều ở trạng thái ổn định:
%
\[ S_I \equiv \frac{\delta E_{SS}}{\delta I_{SS}} \]
%
$E$ và $I$ đạt trạng thái ổn định khi $dG/dt$ và $dX/dt$ bằng 0, nhưng ta sẽ không phải giải trực tiếp những phương trình này để tìm $S_I$.  Nếu đặt $dX/dt = 0$ và giải ra $X$, ta sẽ thu được hệ thức sau:
%
\[ X_{SS} = \frac{k_3}{k_2} I_{SS} \]
%
Và vì $E = k_1 + X$, ta có:
%
\[ S_I = \frac{\delta E_{SS}}{\delta I_{SS}} = \frac{\delta X_{SS}}{\delta I_{SS}} \]
%
Lấy đạo hàm của $X_{SS}$ theo $I_{SS}$, ta được:
%
\[ S_I = k_3 / k_2 \]
%
Như vậy, nếu tìm được các tham số khiến cho mô hình khớp với số liệu thì ta có thể dùng $k_3 / k_2$ làm ước lượng cho $S_I$.  

Với số liệu ví dụ, các giá trị ước lượng cho $S_G$ và $S_I$ là $0.029$ và $8.9 \times 10^{-4}$.  Theo Pacini và Bergman, những giá trị này đều trong khoảng thông thường.

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap18.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Case studies}
\label{chap19}

This chapter reviews the computational patterns we have seen so far and presents exercises where you can apply them.

\section{Computational tools}

In Chapter~\ref{chap11} we saw an update function that uses multiple assignment to unpack a \py{State} object and assign the state variables to local variables.

\begin{python}
def update_func(state, t, system):
    s, i, r = state

    infected = system.beta * i * s    
    recovered = system.gamma * i
    
    s -= infected
    i += infected - recovered
    r += recovered
    
    return State(S=s, I=i, R=r)
\end{python}

And in \py{run_simulation} we used multiple assignment again to assign state variables to a row in a \py{TimeFrame}:

\begin{python}
def run_simulation(system, update_func):
    frame = TimeFrame(columns=system.init.index)
    frame.row[system.t0] = system.init
    
    for t in linrange(system.t0, system.t_end):
        frame.row[t+1] = update_func(frame.row[t], system)
    
    return frame
\end{python}

In Chapter~\ref{chap12} we used the functions \py{max} and \py{idxmax} to compute metrics:

\begin{python}
largest_value = S.max()
time_of_largest_value = S.idxmax()
\end{python}

And we saw the logistic function, a general function which is useful for modeling relationships between variables, like the effectiveness of an intervention as a function of expenditure.

In Chapter~\ref{chap13} we saw the \py{unpack} function, which makes system variables available as if they were local variables.

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t0] = init
    
    for t in linrange(t0, t_end):
        frame.row[t+1] = update_func(frame.row[t], t, system)
    
    system.results = frame
\end{python}

One thing to remember when you use \py{unpack}: if you modify any of the unpacked variables, the change does not affect the \py{System} object.

In Chapter~\ref{chap14} we used a \py{SweepFrame} object to sweep two parameters.

\begin{python}
def sweep_parameters(beta_array, gamma_array):
    frame = SweepFrame(columns=gamma_array)
    for gamma in gamma_array:
        frame[gamma] = sweep_beta(beta_array, gamma)
    return frame
\end{python}

In Chapter~\ref{chap15} we used \py{linrange} to create an array of values with a given step size.  \py{linrange} is similar to \py{linspace}: the difference is that \py{linrange} lets you specify the space between values, and it computes the number of values; \py{linspace} lets you specify the number of values, and it computes the space between them.

Here's a version of \py{run_simulation} that uses \py{linrange}:

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t_0] = init
    ts = linrange(t_0, t_end, dt)
    
    for t in ts:
        frame.row[t+dt] = update_func(frame.row[t], t, system)
        
    # store the final temperature in T_final
    system.T_final = get_last_value(frame.T)
    
    return frame
\end{python}

In Chapter~\ref{chap16} we used \py{fsolve} to find the value of a parameter that yields a particular result.  We defined an error function:

\index{\py{fsolve}}

\begin{python}
def error_func1(r):
    system = make_system(r=r)
    results = run_simulation(system, update)
    return system.T_final - 70
\end{python}

And passed it to \py{fsolve} with an initial guess, like this:

\begin{python}
solution = fsolve(error_func1, 0.01)
r_coffee = solution[0]
\end{python}

In Chapter~\ref{chap17} we used \py{interpolate}, which returns a function:

\begin{python}
I = interpolate(data.insulin)
\end{python}

which we can call like any other function, passing as an argument either a single value or a NumPy array:

\begin{python}
I(18)

ts = linrange(t_0, t_end)
I(ts)
\end{python}

We also used a \py{Params} object, which is a collection of parameters.

\begin{python}
params = Params(G0 = 290,
                k1 = 0.03,
                k2 = 0.02,
                k3 = 1e-05)
\end{python}

Chapter~\ref{chap18} introduces \py{run_ode_solver} which computes numerical solutions to differential equations.

\py{run_ode_solver} uses a slope function, which is similar to an update function:

\begin{python}
def slope_func(state, t, system):
    G, X = state
    unpack(system)
    
    dGdt = -k1 * (G - Gb) - X*G
    dXdt = k3 * (I(t) - Ib) - k2 * X
    
    return dGdt, dXdt
\end{python}

We used \py{run_ode_solver} to write an error function, which takes a \py{Params} object, runs a simulation, and returns the difference between the simulation results and the data:

\begin{python}
def error_func(params, data):
    system = make_system(params, data)
    results, details = run_ode_solver(system, slope_func, 
                                      t_eval=data.index)
    errors = results.G - data.glucose
    return errors
\end{python}

Then we passed the error function to \py{fit_leastsq}, which finds the set of parameters that minimizes the errors:

\begin{python}
best_params, fit_details = fit_leastsq(error_func, params, data)
\end{python}

%TODO: Anything to say here?


\section{Under the hood}

\py{unpack} is a function in the \py{modsim} library that copies the variables and values from a \py{System} object into a special Python data structure that stores global variables.  To be honest, it is a bit of a hack; that is, it may be expedient, but it might not be an example of software engineering you should emulate.

\py{fsolve} is based on a Scipy function that is also called \py{fsolve}; you can read more about it at \url{http://modsimpy.com/fsolve}.
It uses a numerical method called Powell's method, and you can read more about that at \url{http://modsimpy.com/powell}.

\index{\py{fsolve}}

\py{run_ode_solver} uses the SciPy function \py{solve_ivp}, which you can read about at \url{http://modsimpy.com/ivp}.
By default it uses an algorithm called RK45, or RKF45, which you can read about at \url{http://modsimpy.com/runge}).

\py{fit_leastsq} is based on the SciPy function \py{leastsq}; you can read about it at \url{http://modsimpy.com/sq}.
By default it uses a version of the Levenberg-Marquardt method, which you can read about at \url{http://modsimpy.com/lm }.

These SciPy functions don't work with the units provided by Pint, so the \py{modsim} library turns off unit-checking before calling them.  This mechanism is a bit of a hack, so you might get some unexpected behavior.  If so, I suggest you make a modest effort to fix them problem, but don't spend too much time on it.

Carrying units through computations like this is not as common as it should be, so the tools are not as polished as they could be.  I think it is worth trying, because you can catch a lot of errors by checking units; but if it gets to be too much trouble, you can always remove the units from the code.  In that case, you should add comments that document the units for all variables!

The rest of this chapter presents case studies you can use to practice what you have learned so far.


\section{The insulin minimal model}

Along with the glucose minimal model in Chapter~\ref{chap17}, Berman et al.~developed an insulin minimal model, in which the concentration of insulin, $I$, is governed by this differential equation:
%
\[ \frac{dI}{dt} = -k I(t) + \gamma \left[ G(t) - G_T \right] t \]
%
where

\begin{itemize}

\item $k$ is a parameter that controls the rate of insulin disappearance independent of blood glucose.   

\item $G(t)$ is the measured concentration of blood glucose at time $t$.

\item $G_T$ is the glucose threshold; when blood glucose is above this level, it triggers an increase in blood insulin. 

\item $\gamma$ is a parameter that controls the rate of increase (or decrease) in blood insulin when glucose is above (or below) $G_T$.

% TODO: explain why t is there

\end{itemize}

The initial condition is $I(0) = I_0$.  As in the glucose minimal model, we treat the initial condition as a parameter which we'll choose to fit the data.

\index{insulin minimal model}
\index{differential equation}

The parameters of this model can be used to estimate, $\phi_1$ and $\phi_2$, which are values that ``describe the sensitivity to glucose of the first and second phase pancreatic responsivity".  They are related to the parameters as follows:
%
\[ \phi_1 = \frac{I_{max} - I_b}{k (G_0 - G_b)}\]
%
\[ \phi_2 = \gamma \times 10^4 \]
%
where $I_{max}$ is the maximum measured insulin level, and $I_b$ and $G_b$ are the basal levels of insulin and glucose.

%TODO: Clarify whether G0 here is the parameter we estimated in the previous
% model, or the maximum observed value of G.

In the repository for this book, you will find a notebook, \py{insulin.ipynb}, which contains starter code for this case study.   Use it to implement the insulin model, find the parameters that best fit the data, and estimate these values.


\section{Low-Pass Filter}

The following circuit diagram\footnote{From \url{http://modsimpy.com/divider}} shows a low-pass filter built with one resistor and one capacitor.  

\centerline{\includegraphics[height=1.3in]{figs/RC_Divider.pdf}}

A ``filter" is a circuit takes a signal, $V_{in}$, as input and produces a signal, $V_{out}$, as output.  In this context, a ``signal" is a voltage that changes over time.

A filter is ``low-pass" if it allows low-frequency signals to pass from $V_{in}$ to $V_{out}$ unchanged, but it reduces the amplitude of high-frequency signals.

By applying the laws of circuit analysis, we can derive a differential equation that describes the behavior of this system.  By solving the differential equation, we can predict the effect of this circuit on any input signal.

Suppose we are given $V_{in}$ and $V_{out}$ at a particular instant in time.  By Ohm's law, which is a simple model of the behavior of resistors, the instantaneous current through the resistor is:
%
\[ I_R = (V_{in} - V_{out}) / R \]
%
where $R$ is resistance in ohms (\si{\ohm}).

Assuming that no current flows through the output of the circuit, Kirchhoff's current law implies that the current through the capacitor is:
%
\[ I_C = I_R \]
%
According to a simple model of the behavior of capacitors, current through the capacitor causes a change in the voltage across the capacitor:
%
\[ I_C = C \frac{d V_{out}}{dt} \]
%
where $C$ is capacitance in farads (\si{\farad}).  Combining these equations yields a differential equation for $V_{out}$:
%
\[ \frac{d V_{out}}{dt} = \frac{V_{in} - V_{out}}{R C} \]
%
In the repository for this book, you will find a notebook, \py{filter.ipynb}, which contains starter code for this case study.   Follow the instructions to simulate the low-pass filter for input signals like this:
%
\[ V_{in}(t) = A \cos (2 \pi f t) \]
%
where $A$ is the amplitude of the input signal, say \SI{5}{\volt}, and $f$ is the frequency of the signal in \si{\hertz}.

In the repository for this book, you will find a notebook, \py{filter.ipynb}, which contains starter code for this case study.  Read the notebook, run the code, and work on the exercises.



\section{Thermal behavior of a wall}

This case study is based on a paper by Gori, et~al\footnote{Gori, Marincioni, Biddulph, Elwell, ``Inferring the thermal resistance and effective thermal mass distribution of a wall from in situ measurements to characterise heat transfer at both the interior and exterior surfaces", {\it Energy and Buildings}, Volume 135, pages 398-409, \url{http://modsimpy.com/wall2}.
    
The authors put their paper under a Creative Commons license, and make their data available at \url{http://modsimpy.com/wall }.  I thank them for their commitment to open, reproducible science, which made this case study possible.} that models the thermal behavior of a brick wall, with the goal of understanding the ``performance gap between the expected energy use of buildings and their measured energy use".

The following figure shows the scenario and their model of the wall:

\vspace{0.1in}
\centerline{\includegraphics[height=1.3in]{figs/wall_model.pdf}}

On the interior and exterior surfaces of the wall, they measure temperature and heat flux over a period of three days.  They model the wall using two thermal masses connected to the surfaces, and to each other, by thermal resistors.

The primary methodology of the paper is a Bayesian method for inferring the parameters of the system (two thermal masses and three thermal resistances).

The primary result is a comparison of two models: the one shown here with two thermal masses, and a simpler model with only one thermal mass.  They find that the two-mass model is able to reproduce the measured fluxes substantially better.

For this case study we will implement their model and run it with the estimated parameters from the paper, and then use \py{fit_leastsq} to see if we can find parameters that yield lower errors.

In the repository for this book, you will find a notebook, \py{wall.ipynb} with the code and results for this case study.


\chapter{Projectiles}
\label{chap20}

So far the differential equations we've worked with have been {\bf first order}, which means they involve only first derivatives.   In this chapter, we turn our attention to second order ODEs, which can involve both first and second derivatives.  

\index{first order ODE}
\index{second order ODE}

We'll revisit the falling penny example from Chapter~\ref{chap01}, and use \py{odeint} to find the position and velocity of the penny as it falls, with and without air resistance.


\section{Newton's second law of motion}

First order ODEs can be written
%
\[ \frac{dy}{dx} = G(x, y) \]
%
where $G$ is some function of $x$ and $y$ (see \url{http://modsimpy.com/ode}).  Second order ODEs can be written
%
\[ \frac{d^2y}{dx^2} = H(x, y, \frac{dy}{dt}) \]
%
where $H$ is a function of $x$, $y$, and $dy/dx$.

In this chapter, we will work with one of the most famous and useful second order ODE, Newton's second law of motion:
%
\[ F = m a \]
%
where $F$ is a force or the total of a set of forces, $m$ is the mass of a moving object, and $a$ is its acceleration.

\index{Newton's second law of motion}
\index{differential equation}
\index{acceleration}
\index{velocity}
\index{position}

Newton's law might not look like a differential equation, until we realize that acceleration, $a$, is the second derivative of position, $y$, with respect to time, $t$.  With the substitution
%
\[ a = \frac{d^2y}{dt^2} \]
%
Newton's law can be written
%
\[ \frac{d^2y}{dt^2} = F / m \]
%
And that's definitely a second order ODE.  In general, $F$ can be a function of time, position, and velocity.

Of course, this ``law" is really a model, in the sense that it is a simplification of the real world.  Although it is often approximately true:

\begin{itemize}

\item It only applies if $m$ is constant.  If mass depends on time, position, or velocity, we have to use a more general form of Newton's law (see \url{http://modsimpy.com/varmass}).

\index{variable mass}

\item It is not a good model for very small things, which are better described by another model, quantum mechanics.

\index{quantum mechanics}

\item And it is not a good model for things moving very fast, which are better described by yet another model, relativistic mechanics.

\index{relativity}

\end{itemize}

However, for medium-sized things with constant mass, moving at medium-sized speeds, Newton's model is phenomenally useful.  If we can quantify the forces that act on such an object, we can predict how it will move.


\section{Dropping pennies}

As a first example, let's get back to the penny falling from the Empire State Building, which we considered in Section~\ref{penny}.  We will implement two models of this system: first without air resistance, then with.

\index{falling penny}
\index{air resistance}

Given that the Empire State Building is \SI{381}{\meter} high, and assuming that the penny is dropped with velocity zero, the initial conditions are:

\index{State object}

\begin{python}
init = State(y=381 * m, 
             v=0 * m/s)
\end{python}

where \py{y} is height above the sidewalk and \py{v} is velocity.  The units \py{m} and \py{s} are from the \py{UNITS} object provided by Pint:

\index{unit}
\index{Pint}

\begin{python}
m = UNITS.meter
s = UNITS.second
\end{python}

The only system parameter is the acceleration of gravity:

\begin{python}
g = 9.8 * m/s**2
\end{python}

In addition, we'll specify the duration of the simulation:

\begin{python}
t_end = 10 * s
\end{python}

We need a \py{System} object to contain the system parameters:

\index{System object}

\begin{python}
system = System(init=init, g=g, t_end=t_end)
\end{python}

Now we need a slope function, and here's where things get tricky.  As we have seen, \py{run_ode_solver} can solve systems of first order ODEs, but Newton's law is a second order ODE.  However, if we recognize that

\index{slope function}
\index{function!slope}

\begin{enumerate}

\item Velocity, $v$, is the derivative of position, $dy/dt$, and

\item Acceleration, $a$, is the derivative of velocity, $dv/dt$,

\end{enumerate}

we can rewrite Newton's law as a system of first order ODEs:
%
\[ \frac{dy}{dt} = v \]
%
\[ \frac{dv}{dt} = a \]
%
And we can translate those equations into a slope function:

\index{system of equations}
\index{unpack}

\begin{python}
def slope_func(state, t, system):
    y, v = state
    unpack(system)    

    dydt = v
    dvdt = -g
    
    return dydt, dvdt
\end{python}

The first parameter, \py{state}, contains the position and velocity of the penny.  The last parameter, \py{system}, contains the system parameter \py{g}, which is the magnitude of acceleration due to gravity.

\index{State object}

The second parameter, \py{t}, is time.  It is not used in this slope function because none of the factors of the model are time dependent (see Section~\ref{glucose}).  I include it anyway because this function will be called by \py{run_ode_solver}, which always provides the same arguments, whether they are needed or not.

\index{time dependent}

The rest of the function is a straightforward translation of the differential equations, with the substitution $a = -g$, which indicates that acceleration is due to gravity, in the direction of decreasing $y$.  \py{slope_func} returns a sequence containing the two derivatives.

Before calling \py{run_ode_solver}, it is a good idea to test the slope function with the initial conditions:

\begin{python}
dydt, dvdt = slope_func(init, 0, system)
\end{python}

The result is \SI{0}{\meter\per\second} for velocity and \SI{9.8}{\meter\per\second\squared} for acceleration.  Now we can call \py{run_ode_solver} like this:

\begin{python}
results, details = run_ode_solver(system, slope_func,
                                  max_step=0.5*s)
\end{python}

The optional argument \py{max_step} determines the largest step size \py{run_ode_solver} can use.  Specifying \py{max_step} makes the simulation take longer, but it makes the results look better when plotted.  It has little or no effect on accuracy.

\py{results} in a \py{TimeFrame} with two columns: \py{y} contains the height of the penny; \py{v} contains its velocity.
 
\index{TimeFrame object}
\index{\py{run_ode_solver}}

We can plot the results like this:

\begin{python}
def plot_position(results):
    plot(results.y)
    decorate(xlabel='Time (s)',
             ylabel='Position (m)')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap09-fig01.pdf}}
\caption{Height of the penny versus time, with no air resistance.}
\label{chap09-fig01}
\end{figure}

Hình~\ref{chap09-fig01} shows the result.  Since acceleration is constant, velocity increases linearly and position decreases quadratically; as a result, the height curve is a parabola.

\index{parabola}

The last value of \py{results.y} is \SI{-109}{\meter}, which means we ran the simulation too long.  One way to solve this problem is to use the results to estimate the time when the penny hits the sidewalk.

The \py{modsim} library provides \py{crossings}, which takes a \py{TimeSeries} and a value, and returns a sequence of times when the series passes through the value.  We can find the time when the height of the penny is \py{0} like this:

\begin{python}
t_crossings = crossings(results.y, 0)
\end{python}

The result is an array with a single value, \SI{8.818}{s}.  Now, we could run the simulation again with \py{t_end = 8.818}, but there's a better way.

\section{Events}
\label{events}

As an option, \py{run_ode_solver} can take an {\bf event function}, which detects an ``event", like the penny hitting the sidewalk, and ends the simulation.

Event functions take the same parameters as slope functions, \py{state}, \py{t}, and \py{system}.  They should return a value that passes through \py{0} when the event occurs.  Here's an event function that detects the penny hitting the sidewalk:

\begin{python}
def event_func(state, t, system):
    y, v = state
    return y
\end{python}

The return value is the height of the penny, \py{y}, which passes through \py{0} when the penny hits the sidewalk.

We pass the event function to \py{run_ode_solver} like this:

\begin{python}
results, details = run_ode_solver(system, slope_func,
                                  events=event_func)
\end{python}

\py{events} can also be a sequence of event functions, if there is more than one event that might occur.

\py{run_ode_solver} uses Brent's method to estimate the time of the event precisely (see \url{http://modsimpy.com/brent}).

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap20.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.




\chapter{Air resistance}
\label{chap21}

In the previous chapter we simulated a penny falling in a vacuum, that is, without air resistance.  But the computational framework we used is very general; it is easy to add additional forces, including drag.

In this chapter, I present a model of drag force and add it to the simulation.


\section{Drag force}
\label{drag}

As an object moves through a fluid, like air, the object applies force to the air and, in accordance with Newton's third law of motion, the air applies an equal and opposite force to the object (see \url{http://modsimpy.com/newton}).

\index{air resistance}
\index{drag force}
\index{force!drag}
\index{drag equation}

The direction of this {\bf drag force} is opposite the direction of travel, and its magnitude is given by the drag equation (see \url{http://modsimpy.com/drageq}):
%
\[ F_d = \frac{1}{2}~\rho~v^2~C_d~A \]
%
where

\begin{itemize}

\item $F_d$ is force due to drag, in newtons (\si{\newton}).

\item $\rho$ is the density of the fluid in \si{\kg\per\meter\cubed}.
\index{density}

\item $v$ is the magnitude of velocity in \si{\meter\per\second}.
\index{velocity}

\item $A$ is the {\bf reference area} of the object, in \si{\meter\squared}.  In this context, the reference area is the projected frontal area, that is, the visible area of the object as seen from a point on its line of travel (and far away).

\index{reference area}

\item $C_d$ is the {\bf drag coefficient}, a dimensionless quantity that depends on the shape of the object (including length but not frontal area), its surface properties, and how it interacts with the fluid.

\index{drag coefficient}

\end{itemize}

For objects moving at moderate speeds through air, typical drag coefficients are between 0.1 and 1.0, with blunt objects at the high end of the range and streamlined objects at the low end (see \url{http://modsimpy.com/dragco}).

For simple geometric objects we can sometimes guess the drag coefficient with reasonable accuracy; for more complex objects we usually have to take measurements and estimate $C_d$ from the data.

Of course, the drag equation is itself a model, based on the assumption that $C_d$ does not depend on the other terms in the equation: density, velocity, and area.  For objects moving in air at moderate speeds (below 45 mph or \SI{20}{\meter\per\second}), this model might be good enough, but we should remember to revisit this assumption.

For the falling penny, we can use measurements to estimate $C_d$.   In particular, we can measure {\bf terminal velocity}, $v_{term}$, which is the speed where drag force equals force due to gravity:
%
\[ \frac{1}{2}~\rho~v_{term}^2~C_d~A = m g \]
%
where $m$ is the mass of the object and $g$ is acceleration due to gravity.  Solving this equation for $C_d$ yields:
%
\[ C_d = \frac{2~m g}{\rho~v_{term}^2~A} \]
%
According to {\it Mythbusters}, the terminal velocity of a penny is between 35 and 65 mph (see \url{http://modsimpy.com/mythbust}).  Using the low end of their range, 40 mph or about \SI{18}{\meter\per\second}, the estimated value of $C_d$ is 0.44, which is close to the drag coefficient of a smooth sphere.

\index{Mythbusters}
\index{terminal velocity}

Now we are ready to add air resistance to the model.


\section{Implementation}
\label{penny_drag}

As the number of system parameters increases, and as we need to do more work to compute them, we will find it useful to define a \py{Params} object to contain the quantities we need to make a \py{System} object.  \py{Params} objects are similar to \py{System} and \py{State} objects; in fact, all three have the same capabilities.  I have given them different names to document the different roles they play.

\index{Params object}

Here's the \py{Params} object for the falling penny:

\begin{python}
params = Params(height = 381 * m,
                v_init = 0 * m / s,
                g = 9.8 * m/s**2,
                mass = 2.5e-3 * kg,
                diameter = 19e-3 * m,
                rho = 1.2 * kg/m**3,
                v_term = 18 * m / s)
\end{python}

The mass and diameter are from \url{http://modsimpy.com/penny}.  The density of air depends on temperature, barometric pressure (which depends on altitude), humidity, and composition (\url{http://modsimpy.com/density}).  I chose a value that might be typical in New York City at \SI{20}{\celsius}.

\index{System object}
\index{\py{make_system}}

Here's a version of \py{make_system} that takes a \py{Params} object and returns a \py{System}:

\index{unpack}

\begin{python}
def make_system(params):
    unpack(params)
    
    area = np.pi * (diameter/2)**2
    C_d = 2 * mass * g / (rho * area * v_term**2)
    init = State(y=height, v=v_init)
    t_end = 30 * s
    
    return System(params, area=area, C_d=C_d, 
                  init=init, t_end=t_end)
\end{python}

The first argument of \py{System} is \py{params}, so the result contains all of the parameters in \py{params}, plus \py{init}, \py{area}, and \py{C_d}.

It might not be obvious why we need \py{Params} objects, but they will turn out to be useful soon.

We can make a \py{System} like this:

\begin{python}
system = make_system(params)
\end{python}

Now here's a version of the slope function that includes drag:

\index{slope function}
\index{function!slope}
\index{unpack}

\begin{python}
def slope_func(state, t, system):
    y, v = state
    unpack(system)
    
    f_drag = rho * v**2 * C_d * area / 2
    a_drag = f_drag / mass
    
    dydt = v
    dvdt = -g + a_drag
    
    return dydt, dvdt
\end{python}

\py{f_drag} is force due to drag, based on the drag equation.  \py{a_drag} is acceleration due to drag, based on Newton's second law.

\index{gravity}

To compute total acceleration, we add accelerations due to gravity and drag. \py{g} is negated because it is in the direction of decreasing \py{y}, and \py{a_drag} is positive because it is in the direction of increasing \py{y}.  In the next chapter we will use \py{Vector} objects to keep track of the direction of forces and add them up in a less error-prone way.

To stop the simulation when the penny hits the sidewalk, we'll use the event function from Section~\ref{events}:

\begin{python}
def event_func(state, t, system):
    y, v = state
    return y
\end{python}

Now we can run the simulation like this:

\index{\py{run_ode_solver}}

\begin{python}
results, details = run_ode_solver(system, slope_func,
                       events=event_func, max_step=0.5*s)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap09-fig02.pdf}}
\caption{Height of the penny versus time, with air resistance.}
\label{chap09-fig02}
\end{figure}

Hình~\ref{chap09-fig02} shows the result.  It only takes a few seconds for the penny to accelerate up to terminal velocity; after that, velocity is constant, so height as a function of time is a straight line.

\index{terminal velocity}

In the notebook for this chapter, you'll have a chance to extend this model.


\section{Bungee jumping}
\label{bungee}

Suppose you want to set the world record for the highest ``bungee dunk", which is a stunt in which a bungee jumper dunks a cookie in a cup of tea at the lowest point of a jump.  An example is shown in this video: \url{http://modsimpy.com/dunk}.

Since the record is \SI{70}{\meter}, let's design a jump for \SI{80}{\meter}.  We'll start with the following modeling assumptions:

\begin{itemize}

\item  Initially the bungee cord hangs from a crane with the attachment point \SI{80}{\meter} above a cup of tea.

\item Until the cord is fully extended, it applies no force to the jumper.  It turns out this might not be a good assumption; we will revisit it.

\item After the cord is fully extended, it obeys Hooke's Law; that is, it applies a force to the jumper proportional to the extension of the cord beyond its resting length.  See \url{http://modsimpy.com/hooke}. 

\item The mass of the jumper is \SI{75}{\kilogram}.

\item The jumper is subject to drag force, as in the previous model, so that their terminal velocity is \SI{60}{\meter \per \second}.

\end{itemize}

Our objective is to choose the length of the cord, \py{L}, and its spring constant, \py{k}, so that the jumper falls all the way to the tea cup, but no farther!

We'll start with the length of the bungee cord, \py{L} at \SI{25}{\meter} and spring constant, \py{k} at \SI{40}{\newton \per \meter}.  Here's a \py{Params} object with all of these parameters:

\begin{python}
params = Params(y_attach = 80 * m,
                v_init = 0 * m / s,
                g = 9.8 * m/s**2,
                mass = 75 * kg,
                area = 1 * m**2,
                rho = 1.2 * kg/m**3,
                v_term = 60 * m / s,
                L = 25 * m,
                k = 40 * N / m)
\end{python}

And here's a version of \py{make_system} that uses \py{v_term} to compute \py{C_d}:

\begin{python}
def make_system(params):
    unpack(params)
    
    C_d = 2 * mass * g / (rho * area * v_term**2)
    init = State(y=y_attach, v=v_init)
    t_end = 20 * s

    return System(params, C_d=C_d, 
                  init=init, t_end=t_end)
\end{python}

We can run it like this:

\begin{python}
system = make_system(params)
\end{python}

We need a function to compute spring force based on the altitude of the jumper, \py{y}:

\begin{python}
def spring_force(y, system):
    unpack(system)
    distance_fallen = y_attach - y
    if distance_fallen <= L:
        return 0 * N
    
    extension = distance_fallen - L
    f_spring = k * extension
    return f_spring
\end{python}

\py{distance_fallen} is the distance of the jumper from the attachment point.  If the cord is not fully extended, the spring force is 0.  Otherwise we compute the extension of the cord, \py{extension}, and the spring force, \py{f_spring}.

I'll also define a function to compute drag force:

\begin{python}
def drag_force(v, system):
    unpack(system)
    f_drag = -np.sign(v) * rho * v**2 * C_d * area / 2
    return f_drag
\end{python}

\py{drag_force} uses the NumPy function \py{sign}, which returns 1 if the argument is positive, -1 if it is negative, and 0 if it is 0.  This ensures that the drag force is always in the opposite direction of velocity.

\index{NumPy}
\index{sign}

Now here's the slope function:

\begin{python}
def slope_func(state, t, system):
    y, v = state
    unpack(system)
    
    a_drag = drag_force(v, system) / mass
    a_spring = spring_force(y, system) / mass
    dvdt = -g + a_drag + a_spring
    
    return v, dvdt
\end{python}

\py{slope_func} uses \py{spring_force} and \py{drag_force} to compute forces, then divides by \py{mass} to get accelerations.

We can run the simulation like this:

\begin{python}
ts = linspace(0, system.t_end, 301)
results, details = run_ode_solver(system, slope_func,
                                  max_step=0.3*s)
\end{python}

Again, I use \py{max_step} so the results look better when plotted.
Hình~\ref{chap09-fig03} shows the results.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap09-fig03.pdf}}
\caption{Position and velocity of the bungee jumper.}
\label{chap09-fig03}
\end{figure}

We can find the altitude of the jumper at the lowest point like this:

\begin{python}
min(results.y)
\end{python}

For the parameters we chose, the jumper bottoms out at about \SI{5}{\meter}, so we need to increase \py{L} or decrease \py{k}.  In the notebook for this chapter, you'll have to a chance to find the best parameters for the bungee dunk.

\section{Getting acceleration}

In fact, there are many combinations of \py{L} or decrease \py{k} that would work.  We might want to find the combination that minimizes the peak acceleration of the jumper, providing the maximum time near the sidewalk to make the dunk.

To do that, we need to know the acceleration of the jumper over time.  Although we compute acceleration in the slope function, it is not included in the results.

It might be tempting to record the acceleration each time the slope function runs, but we should not do that.  The ODE solver calls the slope function many times with different values of \py{state} and \py{t}.  Because of the way the solver works, not all of the states and times are actually part of the solution.  So recording acceleration while the solver is running would not work.

Instead, we can use the computed velocities to estimate acceleration as a function of time.

The \py{modsim} library provides \py{gradient}, which uses NumPy to estimate the derivative of a \py{TimeSeries}.  Here's how it works:

\begin{python}
a = gradient(results.v)
\end{python}

In the notebook for this chapter, \py{chap21.ipynb}, you can finish this problem by finding the combination of \py{L} and \py{k} that allows the jumper to complete the bungee dunk while minimizing the acceleration they experience. Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.



\chapter{Projectiles in 2-D}
\label{chap22}

In the previous chapter we modeled objects moving in one dimension, with and without drag.  Now let's move on to two dimensions, and baseball!

In this chapter we model the flight of a baseball including the effect of air resistance.  In the next chapter we use this model to solve an optimization problem.


\section{Baseball}
\label{baseball}

To model the flight of a baseball, we have to make some modeling decisions.  To get started, we ignore any spin that might be on the ball, and the resulting Magnus force (see \url{http://modsimpy.com/magnus}).  Under this assumption, the ball travels in a vertical plane, so we'll run simulations in two dimensions, rather than three.

\index{Magnus force}

Air resistance has a substantial effect on most projectiles in air, so we will include a drag force.

\index{air resistance}

To model air resistance, we'll need the mass, frontal area, and drag coefficient of a baseball.  Mass and diameter are easy to find (see \url{http://modsimpy.com/baseball}).  Drag coefficient is only a little harder; according to {\it The Physics of Baseball}\footnote{Adair, {\it The Physics of Baseball}, Third Edition, Perennial, 2002}, the drag coefficient of a baseball is approximately 0.33 (with no units).

\index{drag coefficient}

However, this value {\em does} depend on velocity.  At low velocities it might be as high as 0.5, and at high velocities as low as 0.28.  Furthermore, the transition between these regimes typically happens exactly in the range of velocities we are interested in, between \SI{20}{\meter\per\second} and \SI{40}{\meter\per\second}.

Nevertheless, we'll start with a simple model where the drag coefficient does not depend on velocity; as an exercise at the end of this chapter, you will have a chance to implement a more detailed model and see what effect is has on the results.

But first we need a new computational tool, the \py{Vector} object.


\section{Vectors}

Now that we are working in two dimensions, we will find it useful to work with {\bf vector quantities}, that is, quantities that represent both a magnitude and a direction.  We will use vectors to represent positions, velocities, accelerations, and forces in two and three dimensions. 

\index{Vector object}
\index{array}
\index{NumPy}

The \py{modsim} library provides a \py{Vector} object that represents a vector quantity.  A \py{Vector} object is a like a NumPy array; it contains elements that represent the {\bf components} of the vector.  For example, in a \py{Vector} that represents a position in space, the components are the $x$ and $y$ coordinates (and a $z$ coordinate in 3-D).  A \py{Vector} object can also have units, like the quantities we've seen in previous chapters.  

\index{unit}

You can create a \py{Vector} by specifying its components.  The following \py{Vector} represents a point \SI{3}{\meter} to the right (or east) and \SI{4}{\meter} up (or north) from an implicit origin:

\index{component}

\begin{python}
A = Vector(3, 4) * m
\end{python}

You can access the components of a \py{Vector} by name using the dot operator, for example, \py{A.x} or \py{A.y}.  You can also access them by index using brackets, for example, \py{A[0]} or \py{A[1]}.

Similarly, you can get the magnitude and angle using the dot operator, \py{A.mag} and \py{A.angle}.  {\bf Magnitude} is the length of the vector: if the \py{Vector} represents position, magnitude is the distance from the origin; if it represents velocity, magnitude is speed, that is, how fast the object is moving, regardless of direction.

\index{angle}
\index{magnitude}

The {\bf angle} of a \py{Vector} is its direction, expressed as the angle in radians from the positive x-axis.  In the Cartesian plane, the angle \SI{0}{\radian} is due east, and the angle \SI{\pi}{\radian} is due west. 

\index{radian}

\py{Vector} objects support most mathematical operations, including addition and subtraction:

\begin{python}
B = Vector(1, 2) * m
A + B
A - B
\end{python}

For the definition and graphical interpretation of these operations, see \url{http://modsimpy.com/vecops}.

\index{vector operation}

When you add and subtract \py{Vector} objects, the \py{modsim} library uses NumPy and Pint to check that the operands have the same number of dimensions and units.  The notebook for this chapter shows examples for working with \py{Vector} objects.

\index{dimensions}

One note on working with angles: in mathematics, we almost always represent angle in radians, and most Python functions expect angles in radians.  But people often think more naturally in degrees.  It can be awkward, and error-prone, to use both units in the same program.  Fortunately, Pint makes it possible to represent angles using quantities with units.

\index{degree}

As an example, I'll get the \py{degree} unit from \py{UNITS}, and create a quantity that represents 45 degrees:

\begin{python}
degree = UNITS.degree
angle = 45 * degree
\end{python}

If we need to convert to radians we can use the \py{to} function
\index{\py{to}}

\begin{python}
radian = UNITS.radian
rads = angle.to(radian)
\end{python}

If you are given an angle and velocity, you can make a \py{Vector} using \py{pol2cart}, which converts from polar to Cartesian coordinates.  To demonstrate, I'll extract the angle and magnitude of \py{A}:

\index{pol2cart}

\begin{python}
mag = A.mag
angle = A.angle
\end{python}

And then make a new \py{Vector} with the same components:

\begin{python}
x, y = pol2cart(angle, mag)
Vector(x, y)
\end{python}

Another way to represent the direction of \py{A} is a {\bf unit vector}, which is a vector with magnitude 1 that points in the same direction as \py{A}.  You can compute a unit vector by dividing a vector by its magnitude:

\index{unit vector}
\index{hat function}

\begin{python}
A / A.mag
\end{python}

We can do the same thing using the \py{hat} function, so named because unit vectors are conventionally decorated with a hat, like this: $\hat{A}$.

\begin{python}
A.hat()
\end{python}

Now let's get back to the game.


\section{Simulating baseball flight}

Let's simulate the flight of a baseball that is batted from home plate at an angle of \SI{45}{\degree} and initial speed \SI{40}{\meter \per \second}.
Using the center of home plate as the origin, the x-axis is parallel to the ground; the y-axis is vertical.  The initial height is about \SI{1}{\meter}.

As in Section~\ref{penny_drag}, I'll create a \py{Params} object that contains the parameters of the system:

\index{Params object}

\begin{python}
params = Params(x = 0 * m, 
                y = 1 * m,
                g = 9.8 * m/s**2,
                mass = 145e-3 * kg,
                diameter = 73e-3 * m,
                rho = 1.2 * kg/m**3,
                C_d = 0.3,
                angle = 45 * degree,
                velocity = 40 * m / s,
                duration = 6 * s)
\end{python}

The mass, diameter, and drag coefficient of the baseball are from the sources in Section~\ref{baseball}.  The acceleration of gravity, \py{g}, is a well-known quantity, and the density of air, \py{rho}, is based on a temperature of \SI{20}{\celsius} at sea level (see \url{http://modsimpy.com/tempress}).
 I chose the value of \py{duration} to run the simulation long enough for the ball to land on the ground.

\index{density}

The following function uses the \py{Params} object to make a \py{System} object.  This two-step process makes the code more readable and makes it easier to work with functions like \py{fsolve}.

\index{System object}
\index{\py{make_system}}

\begin{python}
def make_system(condition):
    unpack(params)
    
    theta = np.deg2rad(angle)
    vx, vy = pol2cart(theta, velocity)
    init = State(x=x, y=y, vx=vx, vy=vy)
    area = np.pi * (diameter/2)**2
    
    return System(params, init=init, area=area)
\end{python}

\py{make_system} uses \py{np.deg2rad} to convert \py{angle} to radians and \py{pol2cart} to compute the $x$ and $y$ components of the initial velocity.  Then it makes the initial \py{State} object, computes \py{area}, and creates the \py{System} object, which contains all of the variables in \py{params} plus \py{init} and \py{area}.

\index{deg2rad}
\index{State object}

Next we need a function to compute drag force:

\begin{python}
def drag_force(v, system):
    unpack(system)
    mag = rho * v.mag**2 * C_d * area / 2
    direction = -v.hat()
    f_drag = direction * mag
    return f_drag
\end{python}

This function differs from the one in Section~\ref{bungee} because it takes \py{v} as a \py{Vector} and returns \py{f_drag} as a \py{Vector}.  It uses the drag equation to compute the magnitude of the drag force, and the \py{hat} function to compute the direction.  \py{-v.hat()} computes a unit vector pointing in the opposite direction of \py{v}.

\index{unit vector}
\index{slope function}
\index{function!slope}

Now we're ready for a slope function:

\begin{python}
def slope_func(state, t, system):
    x, y, vx, vy = state
    unpack(system)

    v = Vector(vx, vy)    
    a_drag = drag_force(v, system) / mass
    a_grav = Vector(0, -g)
    
    a = a_grav + a_drag
    
    return vx, vy, a.x, a.y
\end{python}

As usual, the parameters of the slope function are a \py{State} object, time, and a \py{System} object.  In this example, we don't use \py{t}, but we can't leave it out because when \py{run_ode_solver} calls the slope function, it always provides the same arguments, whether they are needed or not.

The \py{State} object contains four state variables: \py{x} and \py{y} are the components of position; \py{vx} and \py{vy} are the components of velocity.

\index{state variable}

The return values from the slope function are the derivatives of these components.  The derivative of position is velocity, so the first two return values are just \py{vx} and \py{vy}, the values we extracted from the \py{State} object.  The derivative of velocity is acceleration, and that's what we have to compute.

\index{acceleration}
\index{velocity}
\index{position}

The total acceleration of the baseball is the sum of accelerations due to gravity and drag.  These quantities have both magnitude and direction, so they are represented by vectors \py{Vector} objects.

We already saw how \py{a_drag} is computed.  \py{a_grav} is a \py{Vector} with magnitude \py{g} pointed in the negative \py{y} direction.

Using vectors to represent forces and accelerations makes the code concise, readable, and less error-prone.  In particular, when we add \py{a_grav} and \py{a_drag}, the directions are likely to be correct, because they are encoded in the \py{Vector} objects.  And the units are certain to be correct, because otherwise Pint would report an error.
\index{Pint}

As always, we can test the slope function by running it with the initial conditions:

\begin{python}
slope_func(system.init, 0, system)
\end{python}

We can use an event function to stop the simulation when the ball hits the ground.

\begin{python}
def event_func(state, t, system):
    x, y, vx, vy = state
    return y
\end{python}

The event function takes the same parameters as the slope function, and returns the y coordinate.  When the y coordinate passes through 0, the simulation stops.

Now we're ready to run the simulation:

\begin{python}
ts = linspace(0, system.t_end, 101)
results, details = run_ode_solver(system, slope_func,
                       events=event_func, max_step=0.2*s)
\end{python}

\py{results} is a \py{TimeFrame} object with one column for each of the state variables, \py{x}, \py{y}, \py{vx}, and \py{vy}.

\index{TimeFrame object}

We can get the flight time like this:

\begin{python}
flight_time = get_last_label(results) * s
\end{python}

And the final \py{x} coordinate like this:

\begin{python}
x_dist = get_last_value(results.x) * m
\end{python}

Notice that the results don't have units; if we want these values to have the correct units, we have to apply them.


\section{Trajectories}

We can plot the $x$ and $y$ components of position like this:

\begin{python}
plot(results.x, label='x')
plot(results.y, label='y')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap10-fig01.pdf}}
\caption{Simulated baseball flight, $x$ and $y$ components of position as a function of time.}
\label{chap10-fig01}
\end{figure}

Hình~\ref{chap10-fig01} shows the result.  As expected, the $x$ component increases monotonically, with decreasing velocity.  The $y$ position climbs initially and then descends, falling slightly below \SI{0}{\meter} after \SI{5.1}{\second}.

\index{monotonic}

Another way to view the same data is to plot the $x$ component on the x-axis and the $y$ component on the y-axis, so the plotted line follows the trajectory of the ball through the plane:

\begin{python}
plot(results.x, results.y, label='trajectory')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap10-fig02.pdf}}
\caption{Simulated baseball flight, trajectory plot.}
\label{chap10-fig02}
\end{figure}

Hình~\ref{chap10-fig02} shows this way of visualizing the results, which is called a {\bf trajectory plot} (see \url{http://modsimpy.com/trajec}).

\index{trajectory plot}

A trajectory plot can be easier to interpret than a time series plot, because it shows what the motion of the projectile would look like (at least from one point of view).  Both plots can be useful, but don't get them mixed up!  If you are looking at a time series plot and interpreting it as a trajectory, you will be very confused.

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap22.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.



\chapter{Optimization}
\label{chap23}

In the previous chapter we developed a model of the flight of a baseball, including gravity and a simple version of drag, but neglecting spin, Magnus force, and the dependence of the coefficient of drag on velocity.

In this chapter we apply that model to an optimization problem.

\section{The Manny Ramirez problem}
\label{manny}

Manny Ramirez is a former member of the Boston Red Sox (an American baseball team) who was notorious for a relaxed attitude and a taste for practical jokes that his managers did not always appreciate.  Our objective in this chapter is to solve the following Manny-inspired problem:

{\it What is the minimum effort required to hit a home run in Fenway Park?}

Fenway Park is a baseball stadium in Boston, Massachusetts.  One of its most famous features is the ``Green Monster", which is a wall in left field that is unusually close to home plate, only 310 feet away.  To compensate for the short distance, the wall is unusually high, at 37 feet (see \url{http://modsimpy.com/wally}).

\index{Ramirez, Manny}
\index{Fenway Park}
\index{baseball}
\index{Green Monster}
\index{velocity}

We want to find the minimum velocity at which a ball can leave home plate and still go over the Green Monster.  We'll proceed in the following steps:

\begin{enumerate}

\item For a given velocity, we'll find the optimal {\bf launch angle}, that is, the angle the ball should leave home plate to maximize its height when it reaches the wall.

\index{launch angle}

\item Then we'll find the minimal velocity that clears the wall, given that it has the optimal launch angle.

\end{enumerate}

We'll use the same model as in the previous chapter, with this \py{Params} object:

\begin{python}
params = Params(x = 0 * m, 
                y = 1 * m,
                g = 9.8 * m/s**2,
                mass = 145e-3 * kg,
                diameter = 73e-3 * m,
                rho = 1.2 * kg/m**3,
                C_d = 0.3,
                angle = 45 * degree,
                velocity = 40 * m / s,
                t_end = 20 * s)
\end{python}
  
This version of \py{make_system}:

\begin{python}
def make_system(condition):
    unpack(params)
    
    theta = np.deg2rad(angle)
    vx, vy = pol2cart(theta, velocity)
    init = State(x=x, y=y, vx=vx, vy=vy)
    area = np.pi * (diameter/2)**2
    
    return System(params, init=init, area=area)
\end{python}
    
This slope function:

\begin{python}
def slope_func(state, t, system):
    x, y, vx, vy = state
    unpack(system)

    V = Vector(vx, vy)    
    a_drag = drag_force(V, system) / mass
    a_grav = Vector(0, -g)
    
    a = a_grav + a_drag
    
    return vx, vy, a.x, a.y
\end{python}

And this event function:

\begin{python}
def event_func(state, t, system):
    x, y, vx, vy = state
    return y
\end{python}


\section{Finding the range}

Suppose we want to find the launch angle that maximizes {\bf range}, that is, the distance the ball travels in the air before landing.   We'll use a function in the \py{modsim} library, \py{max_bounded}, which takes a function and finds its maximum.

The function we pass to \py{max_bounded} should take launch angle and a \py{params} object, and return range:

\begin{python}
def range_func(angle, params):  
    params = Params(params, angle=angle)
    system = make_system(params)
    results, details = run_ode_solver(system, slope_func, 
                                      events=event_func)
    x_dist = get_last_value(results.x) * m
    return x_dist
\end{python}

\py{range_func} makes a new \py{Params} object with the given value of \py{angle}.  Then it makes a \py{System} object, calls \py{run_ode_solver}, and returns the final value of \py{x} from the results.  

We can call \py{range_func} directly like this:

\begin{python}
range_func(45, params)
\end{python}

And we can sweep a sequence of angles like this:

\index{parameter sweep}
\index{SweepSeries object}

\begin{python}
angles = linspace(20, 80, 21)
sweep = SweepSeries()

for angle in angles:
    x_dist = range_func(angle, params)
    print(angle, x_dist)
    sweep[angle] = x_dist
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap10-fig03.pdf}}
\caption{Distance from home plate as a function of launch angle, with fixed velocity.}
\label{chap10-fig03}
\end{figure}

Hình~\ref{chap10-fig03} shows the results.  It looks like the optimal angle is between \SI{40}{\degree} and \SI{45}{\degree}.

We can find the optimal angle more precisely and more efficiently using \py{max_bounded}, like this:

\begin{python}
res = max_bounded(range_func, [0, 90], params)
\end{python}

The first parameter is the function we want to maximize.  The second is the range of values we want to search; in this case it's the range of angles from \SI{0}{\degree} to \SI{90}{\degree}.  The third argument can be any object; it gets passed along as an argument when \py{max_bounded} calls \py{range_func}.

\index{Params object}

The return value from \py{max_bounded} is an \py{ModSimSeries} that contains the results, including \py{x}, which is the angle that yielded the highest range, and \py{fun}, which is the value of \py{range_func} when it's evaluated at \py{x}, that is, range when the baseball is launched at the optimal angle.

For these parameters, the optimal angle is \SI{41.1}{\degree}, which yields a range of \SI{103.4}{\meter}.

\index{ModSimSeries}




\section{Finishing off the problem}

In the notebook for this chapter, \py{chap22.ipynb}, you'll have to chance to finish off the Manny Ramirez problem.  There are a few things you'll have to do:

\begin{itemize}

\item In the previous section the ``optimal" launch angle is the one that maximizes range, but that's not what we want.  Rather, we want the angle that maximizes the height of the ball when it gets to the wall (310 feet from home plate).  So you'll have to write a height function to compute it, and then use \py{max_bounded} to find the revised optimum.

\item Once you can find the optimal angle for any velocity, you have to find the minimum velocity that gets the ball over the wall.  You'll write a function that takes a velocity as a parameter, computes the optimal angle for that velocity, and returns the height of the ball, at the wall, using the optimal angle.

\item Finally, you'll use \py{fsolve} to find the velocity that makes the optimal height at the wall just barely 37 feet.
  
\index{\py{fsolve}}

\end{itemize}

The notebook provides some additional hints, but at this point you should have everything you need.  Good luck!

If you enjoy this exercise, you might be interested in this paper: ``How to hit home runs: Optimum baseball bat swing parameters for maximum range trajectories", by Sawicki, Hubbard, and Stronge, at \url{http://modsimpy.com/runs}.


\chapter{Rotation}
\label{chap24}

In this chapter we model systems that involve rotating objects.  In general, rotation is complicated:  in three dimensions, objects can rotate around three axes; objects are often easier to spin around some axes than others; and they may be stable when spinning around some axes but not others.

\index{rotation}

If the configuration of an object changes over time, it might become easier or harder to spin, which explains the surprising dynamics of gymnasts, divers, ice skaters, etc.

And when you apply a twisting force to a rotating object, the effect is often contrary to intuition.  For an example, see this video on gyroscopic precession \url{http://modsimpy.com/precess}.

\index{gyroscopic precession}

In this chapter, we will not take on the physics of rotation in all its glory.  Rather, we will focus on simple scenarios where all rotation and all twisting forces are around a single axis.  In that case, we can treat some vector quantities as if they were scalars (in the same way that we sometimes treat velocity as a scalar with an implicit direction).

\index{scalar}

This approach makes it possible to simulate and analyze many interesting systems, but you will also encounter systems that would be better approached with the more general toolkit.

The fundamental ideas in this chapter and the next are {\bf angular velocity}, {\bf angular acceleration}, {\bf torque}, and {\bf moment of inertia}.  If you are not already familiar with these concepts, I will define them as we go along, and I will point to additional reading.

At the end of the next chapter, you will use these tools to simulate the behavior of a yo-yo (see \url{http://modsimpy.com/yoyo}).  But we'll work our way up to it gradually, starting with toilet paper.



\section{The physics of toilet paper}
\label{paper}

As a simple example of a system with rotation, we'll simulate the manufacture of a roll of toilet paper.  Starting with a cardboard tube at the center, we will roll up \SI{47}{\meter} of paper, the typical length of a roll of toilet paper in the U.S. (see \url{http://modsimpy.com/paper}).

\index{toilet paper}

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/paper_roll.pdf}}
\caption{Diagram of a roll of toilet paper, showing change in paper length as a result of a small rotation, $d\theta$.}
\label{paper_roll}
\end{figure}

Hình~\ref{paper_roll} shows a diagram of the system: $r$ represents the radius of the roll at a point in time.  Initially, $r$ is the radius of the cardboard core, $R_{min}$.  When the roll is complete, $r$ is $R_{max}$.

I'll use $\theta$ to represent the total rotation of the roll in radians.  In the diagram, $d\theta$ represents a small increase in $\theta$, which corresponds to a distance along the circumference of the roll of $r~d\theta$.

\index{radian}

Finally, I'll use $y$ to represent the total length of paper that's been rolled.  Initially, $\theta=0$ and $y=0$.  For each small increase in $\theta$, there is a corresponding increase in $y$:
%
\[ dy = r~d\theta \]
%
If we divide both sides by a small increase in time, $dt$, we get a differential equation for $y$ as a function of time.
%
\[ \frac{dy}{dt} = r \frac{d\theta}{dt} \]
%
As we roll up the paper, $r$ increases, too.  Assuming that $r$ increases by a fixed amount per revolution, we can write
%
\[ dr = k~d\theta \]
%
Where $k$ is an unknown constant we'll have to figure out.  Again, we can divide both sides by $dt$ to get a differential equation in time:
%
\[ \frac{dr}{dt} = k \frac{d\theta}{dt} \]
%
Finally, let's assume that $\theta$ increases at a constant rate of \SI{10}{\radian\per\second} (about 95 revolutions per minute):
%
\[ \frac{d\theta}{dt} = 10  \]
%
This rate of change is called an {\bf angular velocity}.  Now we have a system of three differential equations we can use to simulate the system.

\index{angular velocity}
\index{differential equation}


\section{Implementation}
\label{papersim}

At this point we have a pretty standard process for writing simulations like this.  First, we'll get the units we need from Pint:
\index{Pint}

\begin{python}
radian = UNITS.radian
m = UNITS.meter
s = UNITS.second
\end{python}

And create a \py{Params} object with the parameters of the system:

\index{Params object}

\begin{python}
params = Params(Rmin = 0.02 * m,
                Rmax = 0.055 * m,
                L = 47 * m,
                t_end = 130 * s)
\end{python}

\py{Rmin} and \py{Rmax} are the initial and final values for the radius, \py{r}.  \py{L} is the total length of the paper, and \py{t_end} is the length of the simulation in time.

Then we use the \py{Params} object to make a \py{System} object:

\index{System object}
\index{\py{make_system}}

\begin{python}
def make_system(params):
    unpack(params)
    
    init = State(theta = 0 * radian,
                 y = 0 * m,
                 r = Rmin)
    
    k = estimate_k(params)
    
    return System(init=init, k=k, t_end=t_end)
\end{python}

The initial state contains three variables, \py{theta}, \py{y}, and \py{r}.

\index{unpack}

To get started, we'll estimate a reasonable value for \py{k}; then in Section~\ref{paper_analysis} we'll figure it out exactly.  Here's how we compute the estimate:

\begin{python}
def estimate_k(params):
    unpack(params)
    
    Ravg = (Rmax + Rmin) / 2
    Cavg = 2 * pi * Ravg
    revs = L / Cavg
    rads = 2 * pi * revs
    k = (Rmax - Rmin) / rads
    return k
\end{python}

\py{Ravg} is the average radius, half way between \py{Rmin} and \py{Rmax}, so \py{Cavg} is the circumference of the roll when \py{r} is \py{Ravg}.

\py{revs} is the total number of revolutions it would take to roll up length \py{L} if \py{r} were constant at \py{Ravg}.  And \py{rads} is just \py{revs} converted to radians.

Finally, \py{k} is the change in \py{r} for each radian of revolution.  For these parameters, \py{k} is about \py{2.8e-5} \si{\meter\per\radian}.

Now we can use the differential equations from Section~\ref{paper} to write a slope function:

\index{slope function}
\index{Function!slope}

\begin{python}
def slope_func(state, t, system):
    theta, y, r = state
    unpack(system)
    
    omega = 10 * radian / s
    dydt = r * omega
    drdt = k * omega
    
    return omega, dydt, drdt
\end{python}

\begin{figure}[t]
\centerline{\includegraphics[height=4.5in]{figs/chap11-fig01.pdf}}
\caption{Results from paper rolling simulation, showing rotation, length, and radius over time.}
\label{chap11-fig01}
\end{figure}

As usual, the slope function takes a \py{State} object, a time, and a \py{System} object.  The \py{State} object contains hypothetical values of \py{theta}, \py{y}, and \py{r} at time \py{t}.  The job of the slope function is to compute the time derivatives of these values.  The time derivative of \py{theta} is angular velocity, which is often denoted \py{omega}.

\index{State object}

We'd like to stop the simulation when the length of paper on the roll is \py{L}.  We can do that with an event function that passes through 0 when \py{y} equals \py{L}:

\begin{python}
def event_func(state, t, system):
    theta, y, r = state
    unpack(system)
    return y - L
\end{python}

Now we can run the simulation like this:

\begin{python}
results, details = run_ode_solver(system, slope_func,
                       events=event_func, max_step=1*s)
\end{python}


Hình~\ref{chap11-fig01} shows the results.  \py{theta} grows linearly over time, as we should expect.  As a result, \py{r} also grows linearly.  But since the derivative of \py{y} depends on \py{r}, and \py{r} is increasing, \py{y} grows with increasing slope.

Because this system is so simple, it is almost silly to simulate it.  As we'll see in the next section, it is easy enough to solve the differential equations analytically.  But it is often useful to start with a simple simulation as a way of exploring and checking assumptions.

In order to get the simulation working, we have to get the units right, which can help catch conceptual errors early.  And by plugging in realistic parameters, we can detect errors that cause unrealistic results.  For example, in this system we can check:

\begin{itemize}

\item The total time for the simulation is about 2 minutes, which seems plausible for the time it would take to roll \SI{47}{\meter} of paper.

\item The final value of \py{theta} is about \SI{1250}{\radian}, which corresponds to about 200 revolutions, which also seems plausible.

\item The initial and final values for \py{r} are consistent with \py{Rmin} and \py{Rmax}, as we intended when we chose \py{k}.

\end{itemize}

But now that we have a working simulation, it is also useful to do some analysis.


\section{Analysis}
\label{paper_analysis}

The differential equations in Section~\ref{paper} are simple enough that we can just solve them.  Since angular velocity is constant:
%
\[ \frac{d\theta}{dt} = \omega  \]
%
We can find $\theta$ as a function of time by integrating both sides:
%
\[ \theta(t) = \omega t + C_1 \]
%
With the initial condition $\theta(0)=0$,  we find $C_1=0$.  Similarly,
%
\begin{equation}
\frac{dr}{dt} = k \omega                    \label{eqn1}
\end{equation}
%
So
%
\[ r(t) = k \omega t + C_2 \]
%
With the initial condition $r(0)=R_{min}$,  we find $C_2=R_{min}$.  Then we can plug the solution for $r$ into the equation for $y$:
%
\begin{align}
\frac{dy}{dt} & = r \omega                    \label{eqn2}   \\
              & = \left[ k \omega t + R_{min} \right] \omega \nonumber
\end{align}
%
%
Integrating both sides yields:
%
\[ y(t) = \left[ k \omega t^2 / 2 + R_{min} t \right] \omega + C_3\]
%
So $y$ is a parabola, as you might have guessed.  With initial condition $y(0)=0$, we find $C_3=0$.

\index{analysis}
\index{integration}

We can also use these equations to find the relationship between $y$ and $r$, independent of time, which we can use to compute $k$.  Using a move we saw in Section~\ref{contact}, I'll divide Equations~\ref{eqn1} and \ref{eqn2}, yielding
%
\[ \frac{dr}{dy} = \frac{k}{r}\]
%
Separating variables yields
%
\[ r~dr = k~dy\]
%
Integrating both sides yields
%
\[ r^2 / 2 = k y + C \]
%
When $y=0$, $r=R_{min}$, so
%
\[ C = \frac{1}{2} R_{min}^2 \]
%
Solving for $y$, we have
%
\begin{equation}
y = \frac{1}{2k} (r^2 - R_{min}^2)                 \label{eqn3}
\end{equation}
%
When $y=L$, $r=R_{max}$; substituting in those values yields
%
\[ L = \frac{1}{2k} (R_{max}^2 - R_{min}^2) \]
%
Solving for $k$ yields
%
\begin{equation}
k =  \frac{1}{2L} (R_{max}^2 - R_{min}^2)           \label{eqn4}
\end{equation}
%
Plugging in the values of the parameters yields \py{2.8e-5} \si{\meter\per\radian}, the same as the ``estimate" we computed in Section~\ref{papersim}.  In this case the estimate turns out to be exact.

In the next chapter, we'll run the simulation the other way, unrolling the paper.

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap24.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Torque}
\label{chap25}

In the previous chapter we modeled a scenario with constant angular velocity.  In this chapter we make it more complex; we'll model a teapot, on a turntable, revolving with constant angular acceleration and deceleration.


\section{Angular acceleration}

\index{angular acceleration}
\index{torque}

Just as linear acceleration is the derivative of velocity, {\bf angular acceleration} is the derivative of angular velocity.  And just as linear acceleration is caused by force, angular acceleration is caused by the rotational version of force, {\bf torque}.  If you are not familiar with torque, you can read about it at \url{http://modsimpy.com/torque}.

In general, torque is a vector quantity, defined as the {\bf cross product} of $\vec{r}$ and $\vec{F}$, where $\vec{r}$ is the {\bf lever arm}, a vector from the point of rotation to the point where the force is applied, and $\vec{F}$ is the vector that represents the magnitude and direction of the force.

\index{vector}
\index{lever arm}
\index{cross product}

However, for the problems in this chapter, we only need the {\em magnitude} of torque; we don't care about the direction.  In that case, we can compute
%
\[ \tau = r F \sin \theta \]
%
where $\tau$ is torque, $r$ is the length of the lever arm, $F$ is the magnitude of force, and $\theta$ is the angle between $\vec{r}$ and $\vec{F}$.  

\index{magnitude}

Since torque is the product of a length and a force, it is expressed in newton meters (\si{\newton\meter}).


\section{Moment of inertia}

In the same way that linear acceleration is related to force by Newton's second law of motion, $F=ma$, angular acceleration is related to torque by another form of Newton's law:
%
\[ \tau = I \alpha \]
%
Where $\alpha$ is angular acceleration and $I$ is {\bf moment of inertia}.  Just as mass is what makes it hard to accelerate an object\footnote{That might sound like a dumb way to describe mass, but its actually one of the fundamental definitions.}, moment of inertia is what makes it hard to spin an object.

\index{mass}
\index{moment of inertia}

In the most general case, a 3-D object rotating around an arbitrary axis, moment of inertia is a tensor, which is a function that takes a vector as a parameter and returns a vector as a result.

\index{tensor}

Fortunately, in a system where all rotation and torque happens around a single axis, we don't have to deal with the most general case.  We can treat moment of inertia as a scalar quantity.

\index{scalar}

For a small object with mass $m$, rotating around a point at distance $r$, the moment of inertia is $I = m r^2$, in SI units \si{\kilogram\meter\squared}.  For more complex objects, we can compute $I$ by dividing the object into small masses, computing moments of inertia for each mass, and adding them up.

However, for most simple shapes, people have already done the calculations; you can just look up the answers.  For example, see \url{http://modsimpy.com/moment}.


\section{Teapots and turntables}

Tables in Chinese restaurants often have a rotating tray or turntable
that makes it easy for customers to share dishes. These turntables are
supported by low-friction bearings that allow them to turn easily and
glide. However, they can be heavy, especially when they are loaded with
food, so they have a high moment of inertia.

\index{teapot}
\index{turntable}

Suppose I am sitting at a table with a pot of tea on the turntable
directly in front of me, and the person sitting directly opposite asks
me to pass the tea. I push on the edge of the turntable with \SI{1}{\newton} of force until it has turned \SI{0.5}{\radian}, then let go. The turntable glides until it comes to a stop \SI{1.5}{\radian} from the starting position. How much force should I apply for a second push so the teapot glides to a
stop directly opposite me?

\index{force}
\index{Newton}
\index{friction}

We'll answer this question in these steps:

\begin{enumerate}

\item
  I'll use the results from the first push to estimate the coefficient
  of friction for the turntable.

\item
  As an exercise, you'll use that coefficient of friction to estimate the force needed to rotate the turntable through the remaining angle.

\end{enumerate}

Our simulation will use the following parameters:

\begin{enumerate}
\item
  The radius of the turntable is \SI{0.5}{\meter}, and its weight is \SI{7}{\kg}.
\item
  The teapot weights \SI{0.3}{\kg}, and it sits \SI{0.4}{\meter} from the center of
  the turntable.
\end{enumerate}

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/teapot.pdf}}
\caption{Diagram of a turntable with a teapot.}
\label{teapot}
\end{figure}

Hình~\ref{teapot} shows the scenario, where $F$ is the force I apply to the turntable at the perimeter, perpendicular to the moment arm, $r$, and $\tau$ is the resulting torque. The blue circle near the bottom is the teapot.

Here's a \py{Params} object with these values

\begin{python}
params = Params(radius_disk=0.5*m,
                mass_disk=7*kg,
                radius_pot=0.4*m,
                mass_pot=0.3*kg,
                force=1*N,
                torque_friction=0.2*N*m,
                theta_end=0.5*radian)
\end{python}

\index{Params object}

\py{make_system} creates the initial state, \py{init}, and
computes the total moment of inertia for the turntable and the teapot.

\begin{python}
def make_system(params):
    unpack(params)
    
    init = State(theta=0, omega=0)
    
    I_disk = mass_disk * radius_disk**2 / 2
    I_pot = mass_pot * radius_pot**2
    
    return System(params, init=init, t_end=20*s,
                  I=I_disk+I_pot)
\end{python}

%\index{make_system}

\py{theta} represents the initial angle of the table, in \si{\radian}; \py{omega} represents the angular velocity in \si{\radian\per\second}.

\py{I_disk} is the moment of inertia of the turntable, which is based on the moment of inertia for a horizontal disk revolving around a vertical axis through its center:
%
\[ I_{disk} = m r^2 / 2 \]
%
\py{I_pot} is the moment of inertia of the teapot, which I treat as a point mass with:
%
\[ I_{point} = m r^2 \]
%
Now we can make a \py{System} object:

\begin{python}
system1 = make_system(params)
\end{python}

\index{System object}

Here's a slope that takes the current state, which contains angle and angular velocity, and returns the derivatives, angular velocity and angular acceleration:

\begin{python}
def slope_func(state, t, system):
    theta, omega = state
    unpack(system)
    
    torque = radius_disk * force - torque_friction
    alpha = torque / I
    
    return omega, alpha 
\end{python}

\index{slope function}

In this scenario, the force I apply to the turntable is always perpendicular to the lever arm, so $\sin \theta = 1$ and the torque due to force is $\tau = r F$.

In a more detailed model, I might quantify force due to friction and the moment arm of that force, but that's not really necessary; instead, I chose to quantify torque due to friction, leaving out the details.

\index{friction}

Now we are ready to run the simulation, but first there's a problem we have to address.

When I stop pushing on the turntable, the angular acceleration changes
abruptly. We could implement the slope function with an \py{if}
statement that checks the value of \py{theta} and sets
\py{force} accordingly. And for a coarse model like this one, that
might be fine. But we will get more accurate results if we simulate the
system in two phases:

\begin{enumerate}
\item
  During the first phase, force is constant, and we run until
  \py{theta} is 0.5 radians.
\item
  During the second phase, force is 0, and we run until \py{omega}
  is 0.
\end{enumerate}

Then we can combine the results of the two phases into a single
\py{TimeFrame}.

\index{two-phase simulation}

Here's the event function I'll use for Phase 1; it stops the simulation when \py{theta} reaches \py{theta_end}, which is when I stop pushing:

\begin{python}
def event_func1(state, t, system):
    theta, omega = state
    unpack(system)
    return theta - theta_end 
\end{python}

Now we can run the first phase.

\begin{python}
results1, details1 = run_ode_solver(system1, slope_func,
                         events=event_func1, max_step=0.1*s)
\end{python}

%\index{run_ode_solver}
%\index{max_step}

Again, I specify \py{max_step} so the results look smoother when I plot them, at the cost of some extra computation.

\begin{figure}
\centerline{\includegraphics[height=4.0in]{figs/chap25-fig01.pdf}}
\caption{Angle and angular velocity of a turntable with applied force and friction.}
\label{chap25-fig01}
\end{figure}

Before we run the second phase, we have to extract the final time and
state of the first phase.

\begin{python}
t_0 = get_last_label(results1) * s
theta, omega = get_last_value(results1)
init2 = State(theta=theta*radian, omega=omega*radian/s)
\end{python}

Now we can make a \py{System} object for Phase 2, with the initial state from Phase 1, and with \py{force=0}.

%\index{get_last_label}
%\index{get_last_value}

\begin{python}
system2 = System(system1, t_0=t_0, init=init2, force=0)
\end{python}

For the second phase, we need an event function that stops when the turntable stops; that is, when angular velocity is 0.

\begin{python}
def event_func2(state, t, system):
    theta, omega = state
    return omega
\end{python}

Now we can run the second phase.

\begin{python}
results2, details2 = run_ode_solver(system2, slope_func,
                         events=event_func2, max_step=0.1*s)
\end{python}

Pandas provides \py{combine_first}, which combines
\py{results1} and \py{results2}.

\index{Pandas}

\begin{python}
results = results1.combine_first(results2)
\end{python}

Hình~\ref{chap25-fig01} shows the results.  Angular velocity, \py{omega}, increases linearly while I am pushing, and decreases linearly after I let go.  The angle, \py{theta}, is the integral of angular velocity, so it forms a parabola during each phase.

In the next section, we'll use this simulation to estimate the torque due to friction.


\section{Estimating friction}

Let's take the code from the previous section and wrap it in a function.

\index{function}

\begin{python}
def run_two_phases(force, torque_friction, params):
    params = Params(params, force=force, 
                    torque_friction=torque_friction)

    # run phase 1
    system1 = make_system(params)
    results1, _ = run_ode_solver(system1, slope_func,
                      events=event_func1, max_step=0.1*s)

    # get the final state from phase 1
    t_0 = get_last_label(results1) * s
    theta, omega = get_last_value(results1)
    init2 = State(theta=theta, omega=omega)
    
    # run phase 2
    system2 = System(system1, t_0=t_0, init=init2, force=0)
    results2, _ = run_ode_solver(system2, slope_func,
                      events=event_func2, max_step=0.1*s)
    
    # combine and return the results
    results = results1.combine_first(results2)
    return results
\end{python}

Now we can use \py{run_two_phases} to write an error function we can use, with \py{fsolve}, to find the torque due to friction that yields the observed results from the first push, a total rotation of \SI{1.5}{\radian}.

\index{\py{fsolve}}
\index{error function}

\begin{python}
def error_func1(torque_friction, params):
    force = 1
    results = run_two_phases(force, torque_friction, params)
    theta_final = get_last_value(results.theta)
    print(torque_friction, theta_final)
    return theta_final - 1.5
\end{python}

But before we call \py{fsolve}, we have to deal with a problem.  In order to support computation with units, the \py{modsim} library uses a certain amount of black magic.  With most units, the magic works pretty well, but some units are problematic, including Newtons.

\index{\py{fsolve}}

However, now that we have a working simulation, and some confidence that it is correct, it is less important to carry units through the computation.

We can drop them by creating a new \py{Params} object with the same values and no units.  The \py{modsim} library provides \py{remove_unit}, which does just that.

\begin{python}
params_nodim = remove_units(params)
\end{python}

%\index{remove_units}

The rest of the code works without modification, in part because I designed it to keep almost all of the units in one place.

Now we can use \py{fsolve} to estimate torque due to friction.

\index{torque}
\index{friction}
\index{\py{fsolve}}

\begin{python}
guess = 0.2
res = fsolve(error_func1, guess, params_nodim)
\end{python}

The result is \SI{0.166}{\newton\meter}, a little less than the initial guess.

Now that we know the torque due to friction, we can compute the force needed to rotate the turntable through the remaining angle, that is, from \SI{1.5}{\radian} to \SI{3.14}{\radian}.

In the notebook for this chapter, \py{chap25.ipynb}, you will have a chance to finish off the exercise.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Case studies}
\label{chap26}

\section{Computational tools}

In Chapter~\ref{chap20} we rewrote a second order differential equation as a system of first order equations, and solved them using a slope function like this:

\begin{python}
def slope_func(state, t, system):
    y, v = state
    unpack(system)    

    dydt = v
    dvdt = -g
    
    return dydt, dvdt
\end{python}

We used the \py{crossings} function to search for zero-crossings in the simulation results.

Then we used an event function like this:

\begin{python}
def event_func(state, t, system):
    y, v = state
    return y
\end{python}

To stop the simulation when an event occurs.  Notice that the event function takes the same parameters as the slope function.

In Chapter~\ref{chap21} we developed a model of air resistance and used a  \py{Params} object, which is a collection of parameters:

\begin{python}
params = Params(height = 381 * m,
                v_init = 0 * m / s,
                g = 9.8 * m/s**2,
                mass = 2.5e-3 * kg,
                diameter = 19e-3 * m,
                rho = 1.2 * kg/m**3,
                v_term = 18 * m / s)
\end{python}

And we saw a new way to create a \py{System} object, copying the variables from a \py{Params} object and adding or changing variables:

\begin{python}
    return System(params, area=area, C_d=C_d, 
                  init=init, t_end=t_end)
\end{python}

We also used the \py{gradient} function to estimate acceleration, given velocity:

\begin{python}
a = gradient(results.v)
\end{python}

Chapter~\ref{chap22} introduces \py{Vector} objects, which can represent vector quantities, like position, velocity, force, and acceleration, in 2 or 3 dimensions.

\begin{python}
A = Vector(3, 4) * m
\end{python}

It also introduces trajectory plots, which show the path of an object in two dimensions:

\begin{python}
plot(results.x, results.y, label='trajectory')
\end{python}

In Chapter~\ref{chap23} we define a range function that computes the distance a baseball flies as a function of launch angle:

\begin{python}
def range_func(angle, params):  
    params = Params(params, angle=angle)
    system = make_system(params)
    results, details = run_ode_solver(system, slope_func, 
                                      events=event_func)
    x_dist = get_last_value(results.x) * m
    return x_dist
\end{python}

Then we use \py{max_bounded} to find the launch angle that maximizes range:

\begin{python}
res = max_bounded(range_func, [0, 90], params)
\end{python}

With that, your toolkit is complete.  Chapter~\ref{chap24} and Chapter~\ref{chap25} introduce the physics of rotation, but no new computational tools.


\section{Under the hood}

The \py{crossings} function uses \py{InterpolatedUnivariateSpline} from SciPy, which provides a \py{roots} function that finds zero-crossings.  It uses a cubic spline to interpolate between the time steps of the ODE solution.

\index{crossings}

The \py{Params} object is identical to the \py{System} object in all but name, and based on a Pandas \py{Series}.  I sometimes find it useful to use \py{Params} objects to create \py{System} objects, but it is not necessary.

\index{Params}

The \py{Vector} object is a \py{Quantity}, as defined by Pint, so it normally has units.  It contains a NumPy array that contains the coordinates.  So most vector arithmetic is really array arithmetic.

\index{Vector}

\py{max_bounded} uses the SciPy function \py{minimize_scalar}, which uses Brent's method.  You can read about it at \url{http://modsimpy.com/minimize}).

\index{\py{max_bounded}}
\index{SciPy}
\index{\py{minimize_scalar}}
\index{Brent's method}


\section{Bungee dunk revisited}

In Chapter~\ref{chap21}, we simulated a bungee jump with a model that took into account gravity, air resistance, and the spring force of the bungee cord, but we ignored the weight of the cord.

\index{bungee jump}
\index{bungee cord}

It is tempting to say that the cord has no effect because it falls along with the jumper, but that intuition is incorrect.  As the cord falls, it transfers energy to the jumper.

At \url{http://modsimpy.com/bungee} you'll find a paper\footnote{Heck, Uylings, and Kędzierska, ``Understanding the physics of bungee jumping", Physics Education, Volume 45, Number 1, 2010.} that explains this phenomenon and derives the acceleration of the jumper, $a$, as a function of position, $y$, and velocity, $v$:
%
\[ a = g + \frac{\mu v^2/2}{\mu(L+y) + 2L} \] 
%
where $g$ is acceleration due to gravity, $L$ is the length of the cord, and $\mu$ is the ratio of the mass of the cord, $m$, and the mass of the jumper, $M$.

If you don't believe that their model is correct, this video might convince you: \url{http://modsimpy.com/drop}.

Modify the code from Chapter~\ref{chap21} to model this effect.  How does the behavior of the system change as we vary the mass of the cord?  When the mass of the cord equals the mass of the jumper, what is the net effect on the lowest point in the jump?


\section{Spider-Man}

In this case study we'll develop a model of Spider-Man swinging from a
springy cable of webbing attached to the top of the Empire State
Building.  Initially, Spider-Man is at the top of a nearby building, as
shown in Hình~\ref{spiderman}.

\index{Spider-man}
\index{Empire State Building}

\begin{figure}
\centerline{\includegraphics[height=2.8in]{figs/spiderman.pdf}}
\caption{Diagram of the initial state for the Spider-Man case study.}
\label{spiderman}
\end{figure}

The origin, \texttt{O}, is at the base of the Empire State Building. The
vector \py{H} represents the position where the webbing is attached
to the building, relative to \py{O}. The vector \py{P} is the
position of Spider-Man relative to \py{O}. And \py{L} is the
vector from the attachment point to Spider-Man.

\index{vector}

By following the arrows from \py{O}, along \py{H}, and along
\py{L}, we can see that

\begin{code}
H + L = P
\end{code}

So we can compute \py{L} like this:

\begin{code}
L = P - H
\end{code}

The goals of this case study are:

\begin{enumerate}

\item
  Implement a model of this scenario to predict Spider-Man's trajectory.
\index{trajectory}

\item
  Choose the right time for Spider-Man to let go of the webbing in order
  to maximize the distance he travels before landing.
\index{range}

\item
  Choose the best angle for Spider-Man to jump off the building, and let
  go of the webbing, to maximize range.
\index{optimization}  
  
\end{enumerate}

We'll use the following parameters:
\index{parameter}

\begin{enumerate}

\item According to the Spider-Man Wiki\footnote{\url{http://modsimpy.com/spider}}, Spider-Man weighs \SI{76}{\kg}.

\item
  Let's assume his terminal velocity is \SI{60}{\meter\per\second}.
\index{terminal velocity}

\item
  The length of the web is \SI{100}{\meter}.

\item
  The initial angle of the web is \SI{45}{\degree} to the left of straight
  down.

\item
  The spring constant of the web is \SI{40}{\newton\per\meter} when the cord is stretched, and 0 when it's compressed.

\end{enumerate}

In the repository for this book, you will find a notebook, \py{spiderman.ipynb}, which contains starter code.   Read through the notebook and run the code.  It uses \py{minimize}, which is a SciPy function that can search for an optimal set of parameters (as contrasted with \py{min_bounded}, which can only search along a single axis).


\section{Kittens}

Let's simulate a kitten unrolling toilet paper.  As reference material, see this video: \url{http://modsimpy.com/kitten}.

\index{kitten}

The interactions of the kitten and the paper roll are complex.  To keep things simple, let's assume that the kitten pulls down on the free end of the roll with constant force.  Also, we will neglect the friction between the roll and the axle.  

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/kitten.pdf}}
\caption{Diagram of a roll of toilet paper, showing a force, lever arm, and the resulting torque.}
\label{kitten}
\end{figure}

Hình~\ref{kitten} shows the paper roll with $r$, $F$, and $\tau$.  As a vector quantity, the direction of $\tau$ is into the page, but we only care about its magnitude for now.

Here's the \py{Params} object with the parameters we'll need:

\index{Params object}

\begin{python}
params = Params(Rmin = 0.02 * m,
                Rmax = 0.055 * m,
                Mcore = 15e-3 * kg,
                Mroll = 215e-3 * kg,
                L = 47 * m,
                tension = 2e-4 * N,
                t_end = 180 * s)
\end{python}

As before, \py{Rmin} is the minimum radius and \py{Rmax} is the maximum.  \py{L} is the length of the paper.  \py{Mcore} is the mass of the cardboard tube at the center of the roll; \py{Mroll} is the mass of the paper.  \py{tension} is the force applied by the kitten, in \si{\newton}.  I chose a value that yields plausible results.

At \url{http://modsimpy.com/moment} you can find moments of inertia for simple geometric shapes.  I'll model the cardboard tube at the center of the roll as a ``thin cylindrical shell", and the paper roll as a ``thick-walled cylindrical tube with open ends".

\index{cylinder}

The moment of inertia for a thin shell is just $m r^2$, where $m$ is the mass and $r$ is the radius of the shell.

For a thick-walled tube the moment of inertia is
%
\[ I = \frac{\pi \rho h}{2} (r_2^4 - r_1^4) \]
%
where $\rho$ is the density of the material, $h$ is the height of the tube, $r_2$ is the outer diameter, and $r_1$ is the inner diameter.

Since the outer diameter changes as the kitten unrolls the paper, we have to compute the moment of inertia, at each point in time, as a function of the current radius, \py{r}.  Here's the function that does it:

\index{unpack}

\begin{python}
def moment_of_inertia(r, system):
    unpack(system)
    Icore = Mcore / 2 * Rmin**2
    Iroll = pi * rho_h / 2 * (r**4 - Rmin**4)
    return Icore + Iroll
\end{python}

\py{rho_h} is the product of density and height, $\rho h$, which is the mass per area.  \py{rho_h} is computed in \py{make_system}:

\index{density}
\index{\py{make_system}}

\begin{python}
def make_system(params):
    unpack(params)
    
    init = State(theta = 0 * radian,
                 omega = 0 * radian/s,
                 y = L)
    area = pi * (Rmax**2 - Rmin**2)
    rho_h = Mroll / area
    k = (Rmax**2 - Rmin**2) / 2 / L / radian    
    
    return System(init=init, k=k, rho_h=rho_h,
                  Rmin=Rmin, Rmax=Rmax,
                  Mcore=Mcore, Mroll=Mroll, 
                  t_end=t_end)
\end{python}

\py{make_system} also computes \py{k} using Equation~\ref{eqn4}.

In the repository for this book, you will find a notebook, \py{kitten.ipynb}, which contains starter code for this case study.   Use it to implement this model and check whether the results seem plausible.


\section{Simulating a yo-yo}

Suppose you are holding a yo-yo with a length of string wound around its axle, and you drop it while holding the end of the string stationary.  As gravity accelerates the yo-yo downward, tension in the string exerts a force upward.  Since this force acts on a point offset from the center of mass, it exerts a torque that causes the yo-yo to spin.

\index{yo-yo}
\index{torque}
\index{lever arm}

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/yoyo.pdf}}
\caption{Diagram of a yo-yo showing forces due to gravity and tension in the string, the lever arm of tension, and the resulting torque.}
\label{yoyo}
\end{figure}

Hình~\ref{yoyo} is a diagram of the forces on the yo-yo and the resulting torque.  The outer shaded area shows the body of the yo-yo.  The inner shaded area shows the rolled up string, the radius of which changes as the yo-yo unrolls.

\index{system of equations}

In this model, we can't figure out the linear and angular acceleration independently; we have to solve a system of equations:
%
\begin{align*}
\sum F &= m a \\
\sum \tau &= I \alpha
\end{align*}
%
where the summations indicate that we are adding up forces and torques.

As in the previous examples, linear and angular velocity are related because of the way the string unrolls:
%
\[ \frac{dy}{dt} = -r \frac{d \theta}{dt} \]
%
In this example, the linear and angular accelerations have opposite sign.  As the yo-yo rotates counter-clockwise, $\theta$ increases and $y$, which is the length of the rolled part of the string, decreases.

Taking the derivative of both sides yields a similar relationship between linear and angular acceleration:
%
\[ \frac{d^2 y}{dt^2} = -r \frac{d^2 \theta}{dt^2} \]
%
Which we can write more concisely:
%
\[ a = -r \alpha \]
%
This relationship is not a general law of nature; it is specific to scenarios like this where there is rolling without stretching or slipping.

\index{rolling}

Because of the way we've set up the problem, $y$ actually has two meanings: it represents the length of the rolled string and the height of the yo-yo, which decreases as the yo-yo falls.  Similarly, $a$ represents acceleration in the length of the rolled string and the height of the yo-yo.

We can compute the acceleration of the yo-yo by adding up the linear forces:
%
\[ \sum F = T - mg = ma \]
%
Where $T$ is positive because the tension force points up, and $mg$ is negative because gravity points down.

Because gravity acts on the center of mass, it creates no torque, so the only torque is due to tension:
%
\[ \sum \tau = T r = I \alpha \]
%
Positive (upward) tension yields positive (counter-clockwise) angular acceleration.

\index{SymPy}

Now we have three equations in three unknowns, $T$, $a$, and $\alpha$, with $I$, $m$, $g$, and $r$ as known quantities.  It is simple enough to solve these equations by hand, but we can also get SymPy to do it for us:

\begin{python}
T, a, alpha, I, m, g, r = symbols('T a alpha I m g r')
eq1 = Eq(a, -r * alpha)
eq2 = Eq(T - m*g, m * a)
eq3 = Eq(T * r, I * alpha)
soln = solve([eq1, eq2, eq3], [T, a, alpha])
\end{python}

The results are
%
\begin{align*}
T      &= m g I / I^*   \\
a      &= -m g r^2 / I^* \\
\alpha &= m g r / I^*    \\
\end{align*}
%
where $I^*$ is the augmented moment of inertia, $I + m r^2$.
To simulate the system, we don't really need $T$; we can plug $a$ and $\alpha$ directly into the slope function.

In the repository for this book, you will find a notebook, \py{yoyo.ipynb}, which contains the derivation of these equations and starter code for this case study.   Use it to implement and test this model.


%\section{Rigid pendulum}

%\section{LRC circuit}

% Pendulum:

% Springy pendulum

% Stiff problem as k increases

% Add drag

% Rigid pendulum: solve those constraints

% Generalized coordinates


\backmatter
\printindex

\afterpage{\blankpage}


\end{document}

\end{itemize}


\section{Under the hood}

Throughout this book, we'll use functions defined in the \py{modsim} library.  You don't have to know how they work, but you might be curious.  So at the end of some chapters I'll provide additional information.  If you are an experienced programmer, you might be interested by the design decisions I made.  If you are a beginner, and you feel like you have your hands full already, feel free to skip these sections.

\index{modsim}

Most of the functions in \py{modsim} are based on other Python libraries; the libraries we have used so far include:

\begin{itemize}

\item {\bf Pint}, which provides units like meters and seconds, as we saw in Section~\ref{penny}.

\item {\bf NumPy}, which provides mathematical operations like \py{sqrt}, which we saw in Section~\ref{computation}.

\item {\bf Pandas}, which provides the \py{Series} object, which is the basis of the \py{State} object in Section~\ref{modeling}.

\item {\bf Pyplot}, which provides plotting functions, as we saw in Section~\ref{plotting}.

\end{itemize}

You could use these libraries directly, and when you have more experience, you probably will.  But the functions in \py{modsim} are meant to be easier to use; they provide some additional capabilities, including error checking; and by hiding details you don't need to know about, they let you focus on more important things.

However, there are drawbacks.  One is that it can be hard to understand the error messages.  I'll have more to say about this in later chapters, but for now I have a suggestion.  When you are getting started, you should practice making errors.

\index{debugging}

For each new function you learn, you should deliberately make as many mistakes as possible so you can see what happens.  When you see what the errors messages are, you will understand what they mean.  And that should help later, when you make errors accidentally.


