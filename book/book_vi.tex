% LaTeX source for ``Modeling and Simulation in Python''
% Copyright 2017  Allen B. Downey.
% Bản tiếng Việt 2019: Nguyễn Quang Chiến 

% License: Creative Commons Attribution-NonCommercial 4.0 Unported License.
% https://creativecommons.org/licenses/by-nc/4.0/
%

\documentclass[12pt]{book}

%%%% Both LATEX and PLASTEX

\usepackage{graphicx}
\usepackage{hevea}
\usepackage{makeidx}
\usepackage{setspace}
\usepackage{upquote}
\usepackage{xcolor}
\usepackage[listings]{tcolorbox}
\usepackage[utf8]{vietnam}

\title{Mô hình hoá và mô phỏng bằng Python}
\author{Allen B. Downey}

\newcommand{\thetitle}{Mô hình hoá và mô phỏng bằng Python}
\newcommand{\thesubtitle}{}
\newcommand{\theauthors}{Allen B. Downey}
\newcommand{\theversion}{2.3}


% to get siunitx
% sudo apt-get install texlive-science
\usepackage{siunitx}
\sisetup{per-mode=symbol}

\definecolor{light-gray}{gray}{0.95}

\newtcblisting{python}{
  skin=standard,
  boxrule=0.4pt,
  colback=light-gray,
  listing only,
  top=0pt,
  bottom=0pt,
  left=0pt,
  right=0pt,
  boxsep=2pt,
  listing options={
    basicstyle=\ttfamily,
    language=python,
    showstringspaces=false,
  },
}
 
\newtcblisting{result}{
  skin=standard,
  boxrule=0.0pt,
  colback=white,
  listing only,
  top=0pt,
  bottom=0pt,
  left=0pt,
  right=0pt,
  boxsep=2pt,
  listing options={
    basicstyle=\ttfamily,
    language=python,
    showstringspaces=false,
  },
}
 
\makeindex

% automatically index glossary terms
\newcommand{\term}[1]{%
\item[#1:]\index{#1}}

\usepackage{amsmath}
\usepackage{amsthm}

% format end of chapter excercises
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

\usepackage{afterpage}

\newcommand\blankpage{%
    \null
    \thispagestyle{empty}%
    \addtocounter{page}{-1}%
    \newpage}

\newif\ifplastex
\plastexfalse

%%%% PLASTEX ONLY
\ifplastex

\usepackage{localdef}

\usepackage{url}

\newcount\anchorcnt
\newcommand*{\Anchor}[1]{%
  \@bsphack%
    \Hy@GlobalStepCount\anchorcnt%
    \edef\@currentHref{anchor.\the\anchorcnt}%
    \Hy@raisedlink{\hyper@anchorstart{\@currentHref}\hyper@anchorend}%
    \M@gettitle{}\label{#1}%
    \@esphack%
}

% code listing environments:
% we don't need these for plastex because they get replaced
% by preprocess.py
%\newenvironment{code}{\begin{code}}{\end{code}}
%\newenvironment{stdout}{\begin{code}}{\end{code}}

% inline syntax formatting
\newcommand{\py}{\verb}%}

%%%% LATEX ONLY
\else

\input{latexonly}

\fi

%%%% END OF PREAMBLE
\begin{document}

\frontmatter

%%%% PLASTEX ONLY
\ifplastex

\maketitle

%%%% LATEX ONLY
\else

\begin{latexonly}

%-half title--------------------------------------------------
%\thispagestyle{empty}
%
%\begin{flushright}
%\vspace*{2.0in}
%
%\begin{spacing}{3}
%{\huge \thetitle}
%\end{spacing}
%
%\vspace{0.25in}
%
%Version \theversion
%
%\vfill
%
%\end{flushright}

%--verso------------------------------------------------------

%\afterpage{\blankpage}

%\newpage
%\newpage
%\clearemptydoublepage
%\pagebreak
%\thispagestyle{empty}
%\vspace*{6in}

%--title page--------------------------------------------------
\pagebreak
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

\begin{spacing}{3}
{\huge \thetitle}
\end{spacing}

\vspace{0.25in}

Phiên bản \theversion

\vspace{1in}


{\Large
\theauthors \\
}


\vspace{0.5in}

{\Large Green Tea Press (NXB)}

{\small Needham, Massachusetts, Hoa Kỳ}

%\includegraphics[width=1in]{figs/logo1.eps}
\vfill

\end{flushright}



%--bản quyền--------------------------------------------------
\pagebreak
\thispagestyle{empty}

Bản quyền \copyright ~2017 \theauthors.



\vspace{0.2in}

\begin{flushleft}
Green Tea Press (NXB)       \\
9 Washburn Ave \\
Needham MA 02492, Hoa Kỳ
\end{flushleft}

Cho phép sao chép, phân phối, truyền tin và chỉnh sửa tác phẩm này theo Giấy phép Quốc tế Creative Commons Attribution-NonCommercial-ShareAlike 4.0: \url{http://modsimpy.com/license}.

% TODO: đảm bảo URL vắn tắt hoạt động được với https

Nếu bạn quan tâm đến việc phân phối một phiên bản thương mại của tác phẩm này, hãy liên hệ với tác giả.

Mã nguồn \LaTeX\ và mã lệnh của cuốn sách này có sẵn ở

\begin{code}
https://github.com/AllenDowney/ModSimPy
\end{code}

Bản dịch tiếng Việt: Nguyễn Quang Chiến \url{nguyenquangchien@gmail.com}

Năm 2020-2021.

%--table of contents------------------------------------------

\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

\end{latexonly}


% trang tiêu đề HTML ------------------------------------------

\begin{htmlonly}

\vspace{1em}

{\Large \thetitle}

{\large \theauthors}

Version \theversion

\vspace{1em}

Copyright \copyright ~2017 \theauthors.

Cho phép sao chép, phân phối, truyền tin và chỉnh sửa tác phẩm này theo Giấy phép Quốc tế Creative Commons Attribution-NonCommercial-ShareAlike 4.0, vốn sẵn có ở \url{http://modsimpy.com/license}.

\vspace{1em}

\setcounter{chapter}{-1}

\end{htmlonly}

% END OF THE PART WE SKIP FOR PLASTEX
\fi

\chapter{Mở đầu}
\label{preface}


\section{Phương pháp mô hình hoá có thể dạy được không?}

Những kĩ năng thiết yếu của mô hình hoá --- trừu tượng hoá, phân tích, mô phỏng, và kiểm định --- luôn là then chốt trong ngành kĩ thuật, khoa học tự nhiên, khoa học xã hội, y tế, và nhiều ngành khác. Một số sinh viên ngầm học được những kĩ năng trên, nhưng đa số trường không dạy riêng những môn này, và sinh viên ít được thực tập. Đó là vấn đề mà cuốn sách này tập trung hướng đến.

Tại trường đại học Olin, chúng tôi sử dụng quyển sách này trong lớp học có tên `Modeling and Simulation' (Mô hình hoá và mô phỏng), trong đó các sinh viên đăng ký học trong năm thứ nhất. Những đồng nghiệp của tôi, John Geddes và Mark Somerville, cùng tôi đã lập nên lớp này và dạy nó vào năm đầu tiên là 2009.

Chúng tôi tin rằng việc mô hình hoá cần được giảng dạy quy củ, từ sớm, và trong suốt chương trình học. Chúng tôi cũng tin rằng tính toán là khâu thiết yếu trong quá trình này. 

Nếu sinh viên bị hạn chế trong phạm vi các phép toán tính được bằng tay, thì họ sẽ bị gò bó trong một nhóm ít các hệ thống tự nhiên đơn giản, kiểu như tên lửa chuyển động trong chân không hoặc một khối vật thể chuyển động trên mặt phẳng không ma sát.

Và họ chỉ làm việc với các mô hình tồi -- những mô hình quá đơn giản cho mục tiêu ban đầu của họ. Ở gần như mọi hệ thống cơ học, sức cản không khí và ma sát là những yếu tố thiết yếu; nếu ta bỏ qua chúng thì các dự đoán sẽ bị sai và những thiết kế của ta không hoạt động được.

Trong đa số các lớp vật lý cho sinh viên năm thứ nhất, người học không được ra quyết định về mô hình hoá; đôi khi họ còn không nhận thức được về những quyết định đã được làm hộ. Mục đích của tác giả là giảng dạy toàn bộ quá trình mô hình hoá và dành cho sinh viên cơ hội để thực tập quá trình này.


\section{Tôi cần phải lập trình bao nhiêu?}

Nếu bạn chưa từng lập trình thì bạn cũng có thể đọc hiểu quyển sách này, và làm các bài tập. Tôi sẽ cố gắng hết sức để giải thích mọi thứ bạn cần biết; cụ thể là tôi đã chọn kĩ từ vựng được giới thiệu, và đã cố gắng định nghĩa từng thuật ngữ được dùng lần đầu. Nếu bạn bắt gặp tôi đùng một thuật ngữ mà chưa định nghĩa nó, hãy báo tôi biết.

Nếu đã từng lập trình rồi, bạn sẽ khởi đầu dễ dàng hơn, nhưng đôi chỗ bạn có thể sẽ cảm thấy lúng túng. Tôi chọn cách tiếp cận lập trình mà có thể trước đây bạn chưa từng gặp.

Đa số các lớp lập trình\footnote{Gồm cả nhiều lớp mà tôi từng dạy.} có hai vấn đề lớn:

\begin{enumerate}

\item Lớp đi theo hướng ``từ dưới lên", nghĩa là khởi đầu bằng các yếu tố ngôn ngữ đơn giản và dần bổ sung các công cụ mạnh hơn. Kết quả là sẽ mất nhiều thời gian trước khi người học làm được điều gì đó ý nghĩa hơn là việc quy đổi từ thang nhiệt độ Fahrenheit sang độ C.

\index{từ dưới lên | bottom up}

\item Học mà không có bối cảnh. Người học lập trình mà trong suy nghĩ không có một định hướng cụ thể, bởi vậy, các bài tập rải rác khắp các chủ đề không có kết nối gì với nhau cả; và những bài tập này thường không có ``động cơ'' phát sinh.

\end{enumerate}

Trong cuốn sách này, bạn học lập trình với một mục tiêu ngay trong ý tưởng: đó là lập nên các mô phỏng cho các hệ vật lý. Và ta đi theo hướng ``từ trên xuống"; ý của tôi là ta sẽ dùng ngay những cấu trúc dữ liệu và yếu tố ngôn ngữ lập trình một cách chuyên nghiệp. Cụ thể, chúng ta sử dụng các {\bf thư viện} Python sau đây:

\index{từ trên xuống | top down}

\begin{itemize}

\item NumPy cho tính toán số cơ bản (xem \url{https://www.numpy.org/}).

\index{NumPy}

\item SciPy cho tính toán khoa học (xem \url{https://www.scipy.org/}).

\index{SciPy}

\item Matplotlib cho hiển thị (xem \url{https://matplotlib.org/}).

\index{Matplotlib}

\item Pandas để làm việc với dữ liệu (xem  url{https://pandas.pydata.org/}).

\index{Pandas}

\item SymPy cho tính toán với biểu tượng, (xem \url{https://www.sympy.org}).

\index{SymPy}

\item Pint để tính cho các đơn vị như kg hay mét (xem \url{https://pint.readthedocs.io}).

\index{Pint}

\item Jupyter để đọc, chạy, và phát triển mã lệnh (xem \url{https://jupyter.org}).

\index{Jupyter}

\end{itemize}

Những công cụ này cho phép bạn sớm làm việc với các bài toán thú vị, nhưng cũng có những hạn chế: chúng có thể khó sử dụng, và có thể rất khó theo dõi xem thư viện nào làm công việc gì và các thư viện tương tác như thế nào.

Tôi đã cố gắng giảm thiểu những vấn đề này bằng cách cung cấp một thư viện có tên \py{modsim}, để bạn dễ làm quen những công cụ lập trình nêu trên, và cung cấp thêm một số tính năng khác nữa.

\index{modsim (thư viện)}

Vài yếu tố trong thư viện \py{modsim} giống như các bánh xe tập; đến một lúc nào đó bạn sẽ không dùng đến chúng nữa và bắt đầu làm việc trực tiếp với các thư viện bên trong. Những yếu tố khác, bạn có thể sẽ thấy hữu ích xuyên suốt quyển sách.

Tôi khuyến khích bạn đọc mã lệnh thư viện \py{modsim}. Hầu hết chúng không phức tạp gì, và tôi đã cố gắng viết chúng để dễ đọc. Đặc biệt, nếu bạn đã có kinh nghiệm lập trình rồi, bạn có thể học thêm vài điều bằng cách dùng kỹ nghệ đảo ngược phân tích khâu thiết kế của tôi.


\section{Tôi cần bao nhiêu kiến thức toán và khoa học?} 

Tôi sẽ coi như bạn đã biết về đạo hàm và tích phân, và chỉ cần thế thôi. Cụ thể hơn, bạn không cần biết (hoặc nhớ) nhiều quy tắc lấy đạo hàm và tích phân như trong môn giải tích. Nếu bạn biết đạo hàm của $x^2$ và lấy tích phân của $2x~dx$, vậy là tốt rồi\footnote{Và nếu nhận ra được là câu hỏi này là đáp án cho câu hỏi kia thì càng tốt.}.  Điều quan trọng là bạn hiểu được {\em ý nghĩa} của những khái niệm đạo hàm và tích phân; nếu chưa hiểu, quyển sách này sẽ giúp bạn hình dung được.

\index{giải tích}

Bạn không cần biết gì về các phương trình vi phân.

Về mặt khoa học, chúng ta sẽ đi qua rất nhiều lĩnh vực bao gồm dân số, dịch bệnh, y tế, nhiệt động lực học, và cơ học. Đa phần, tôi không yêu cầu bạn phải biết gì về những môn học trên. Thật ra, một trong những kĩ năng mà bạn cần để mô hình hóa là khả năng học được những lĩnh vực mới, ở mức đủ để phát triển các mô hình và mô phỏng.

Khi đến lĩnh vực cơ học, tôi như bạn đã hiểu được mối liên hệ giữa vị trí, vận tốc, gia tốc, và bạn nắm được các định luật Newton vè chuyển động, đặc biệt là định luật thứ hai, vốn thường được biểu diễn theo dạng $F = ma$ (lực bằng tích khối lượng với gia tốc).

\index{khoa học}
\index{cơ học}

Tôi nghĩ rằng đó là tất cả mọi thứ bạn cần biết; nhưng nếu bạn thấy có điểm gì tôi bỏ quên mất thì hãy cho tôi biết.


\section{Bắt đầu vào cuộc}
\label{code}

Để chạy được các ví dụ và thao tác được những bài tập trong cuốn sách này, bạn cần phải:

\begin{enumerate}

\item Cài đặt Python lên máy tính, cùng với các thư viện ta sẽ sử dụng.

\item Sao chép các file của tôi lên máy tính của bạn.

\item Chạy Jupyter, vốn là một công cụ dùng để chạy và viết các chương trình, rồi tải một {\bf notebook}, vốn là một file có chứa mã lệnh và văn bản.

\end{enumerate}

Ba mục tiếp theo sẽ trình bày chi tiết của các bước trên. Tôi mong rằng có một cách dễ dàng hơn để nhập cuộc; thật tiếc là bạn phải thao tác khá nhiều trước khi viết nên chương trình đầu tiên của mình. Hãy kiên nhẫn!


\section{Cài đặt Python}

Bạn có thể đã cài sẵn Python lên máy tính của mình, nhưng bạn có thể không có được phiên bản mới nhất. Để dùng được mã lệnh trong cuốn sách này, bạn cần đến Python 3.6 hoặc mới hơn. Ngay cả khi bạn có phiên bản mới nhất nhưng có thể bạn vẫn chưa có đầy đủ thư viện mà chúng ta cần.

\index{cài đặt Python}

Bạn có thể cập nhật Python và cài những thư viện đó, nhưng tôi thật sự khuyên bạn đừng làm vậy. Theo tôi bạn sẽ dễ dàng hơn nhiều khi dùng {\bf Anaconda}, vốn là một phiên bản Python tự do, trong đó chứa tất cả các thư viện cần cho cuốn sách này (và kể cả thư viện khác nữa).

\index{Anaconda}

Anaconda có sẵn cho các hệ điều hành Linux, macOS, và Windows.  Mặc định là nó sẽ đặt tất cả các file trong thư mục cá nhân (home) của bạn, bởi vậy bạn sẽ không cần quyền quản trị (admin hay root) để cài nó. Và nếu bạn đã có cài một phiên bản Python rồi, thì Anaconda sẽ không gỡ bỏ hay chỉnh sửa gì nó cả.

Hãy bắt đầu từ \url{https://www.anaconda.com/download}.  Tải về bộ cài cho hệ điều hành của bạn và chạy nó. Bạn không cần quyền admin để cài Anaconda, vì vậy tôi khuyên bạn cài đặt với vai trò người dùng thông thường chứ không phải admin (hay root).

Tôi đề nghị bạn chấp nhận các lựa chọn mặc định khi cài đặt. Trong Windớ, bạn được lựa chọn cài Visual Studio Code hay không. Đây là một môi trường tương tác để viết các chương trình. Bạn không cần nó trong khuôn khổ cuốn sách này, nhưng có thể vẫn muốn dùng cho các dự án khác. 

Theo mặc định, Anaconda sẽ cài đặt hầu hết các gói mà bạn cần, nhưng vẫn còn một vài gói mà bạn có thể phải bổ sung. Một khi việc cài đặt đã hoàn thành, bạn hãy mở một cửa sổ dòng lệnh. Nếu dùng macOS hoặc Linux, bạn có thể dùng Terminal.  Đối với Windows, hãy mở Anaconda Prompt vốn sẽ xuất hiện trong Start menu.

Chạy dòng lệnh sau (hoặc nếu có thể thì copy và paste nó, để tránh lỗi gõ phím):

\begin{code}
conda install jupyterlab pandas seaborn sympy beautifulsoup4 lxml
\end{code}

Trong số trên có thể một vài gói đã được cài rối. Sau cùng, chạy lệnh này:

\begin{code}
conda install -c unidata pint
\end{code}

Đó sẽ là tất cả những gì bạn cần đến.


\section{Copy các file của tôi}

Mã lệnh của cuốn sách này có thể lấy về từ 
\url{https://github.com/AllenDowney/ModSimPy}, vốn là một {\bf Git repository}.  Git là một công cụ phần mềm giúp bạn theo dõi các chương trình cùng những file khác tạo nên một dự án. Một tập hợp các file dưới sự kiểm soát của Git thì được gọi là một repository (với tên gọi thân quen là ``repo").  GitHub là một dịch vụ hosting cung cấp dung lượng lưu trữ các Git repository cùng với một giao diện web tiện lợi.

\index{repository}
\index{Git}
\index{GitHub}

Trước khi bạn tải về những file này, tôi khuyên bạn sao chép repository của tôi ở GitHub, có tên là {\bf forking}.  Nếu chưa có sẵn tài khoản GitHub, bạn sẽ cần phải tạo một cái.  
Dùng một trình duyệt để xem trang chủ của repository của tôi tại \url{https://github.com/AllenDowney/ModSimPy}.   Bạn sẽ thấy một nút màu xám ở góc bên phải phía trên, ghi chữ {\sf Fork}.  Nếu ấn vào nó, GitHub sẽ tạo ra một bản sao cho repository của tôi nhưng thuộc về bạn.

Bây giờ, cách tốt nhất để tải các file về là dùng một {\bf Git client}, vốn là một chương trình để quản lý các git repository.  Bạn có thể nhận những hướng dẫn cài đặt vào Windows, macOS, và Linux tại \url{http://modsimpy.com/getgit}. 

Trên nền Windows, tôi đề nghị bạn chấp nhận các tùy chọn mà trình cài đặt đã gợi ý, nhưng có hai ngoại lệ sau:

\begin{itemize}

\item Về trình biên tập mặc định, hãy chọn \py{nano} thay vì \py{vim}.

\item Ở ``Configuring line ending conversions", chọn ``Check out as is, commit as is".

\end{itemize}

Đối với macOS và Linux, tôi khuyên bạn chấp nhận tất cả tùy chọn được gợi ý.

Một khi việc cài đặt thành công, hãy mở một cửa sổ dòng lệnh. Trên Windows, hãy mở Git Bash, vốn sẽ xuất hiện trong Start menu của bạn.  Trên macOS hoặc Linux, bạn có thể dùng Terminal.  

Để biết hiện bạn đang ở thư mục nào, hãy gõ \py{pwd}, vốn là chữ viết tắt của ``print working directory".  Trên nền Windows, có nhiều khả năng là bạn ở \py{Users\\yourusername}.  Với MacOS hoặc Linux, có thể bạn đang ở thư mục home của mình, \py{/home/yourusername}.  

Bước tiếp theo là copy các file từ repository của bạn trên GitHub về máy tính; theo thuật ngữ Git, quá trình này được gọi là {\bf clone}.  Hãy chạy lệnh sau:

\begin{python}
git clone https://github.com/YourGitHubUserName/ModSimPy
\end{python}

Dĩ nhiên, bạn phải thay thế \py{YourGitHubUserName} bằng tên người dùng GitHub của bạn. Sau khi clone xong, bạn sẽ có một thư mục mới tên là \py{ModSimPy}.

Nếu bạn không muốn dùng Git, bạn có thể tải về các file của tôi dưới dạng nén Zip từ  \url{http://modsimpy.com/zip}.  Bạn sẽ cần có một chương trình như WinZip hoặc gzip để giải nén file Zip này.  Hãy ghi lại chỗ mà bạn vừa tải các file về.


\section{Chạy Jupyter}

Mã lệnh cho từng chương, và mã lệnh bắt đầu cho các bài tập, đều ở dạng tập Jupyter (Jupyter notebook). Nếu bạn chưa từng sử dụng Jupyter before, bạn có thể đọc về nó ở \url{https://jupyter.org}.

\index{Jupyter}

Để khởi động Jupyter trên nền macOS hoặc Linux, hãy mở một Terminal; còn trên Windows, mở Git Bash. Dùng lệnh \py{cd} để chuyển vào thư mục có chứa mã lệnh của repository:

\begin{code}
cd ModSimPy/code
\end{code}

Sau đó hãy khởi động server tập Jupyter:

\begin{code}
jupyter notebook
\end{code}

Lúc này Jupyter mở một cửa sổ trình duyệt, và bạn thấy một danh sách các tập (notebook) trong repository của tôi.  Kích chuột vào tập đầu tiên, \py{chap01.ipynb} rồi làm theo các chỉ đẫn để chạy vài ô (``cell'') đầu tiên. Lần đầu tiên bạn chạy một tập, có thể sẽ mất vài giây để khởi động, trong khi chờ một số file Python được khởi tạo. Sau đó, nó sẽ chạy nhanh hơn.

Hãy thoải mái đọc qua hết các notebook này, nhưng có thể chúng chưa có nhiều ý nghĩa trước khi bạn đọc Chương~\ref{chap01}.

Bạn cũng có thể bật Jupyter từ Start của Windows, thanh Dock trên macOS, hay Anaconda Navigator ở hệ điều hành bất kì. Nếu bạn làm vậy, Jupyter sẽ khởi động từ thư mục home của bạn hoặc từ một thư mục nào đó trong hệ thống file, khi này bạn phải di chuyển đến thư mục \py{ModSimPy}.


\section*{Danh sách người đóng góp}

Nếu bạn có gợi ý hoặc sửa chữa nào, hãy gửi về 
{\tt downey@allendowney.com}.  Hoặc nếu bạn là người dùng Git, hãy gửi tôi một yêu cầu ``pull''!

Nếu tôi thực hiện bất kì chỉnh sửa nào theo ý kiến phản hồi của bạn, tôi sẽ đề tên bạn vào danh sách người đóng góp, trừ phi bạn đề nghị tôi không làm vậy.
\index{contributors}

Nếu bạn bao gồm ít nhất là một phần câu văn trong sách mà có lỗi, thì sẽ tạo điều kiện để tôi tìm kiếm dễ dàng hơn. Còn nếu bạn chỉ ghi số trang hay số đề mục thì cũng tạm được nhưng không hay bằng. Xin cám ơn!

\begin{itemize}

\item Xin chân thành cảm ơn John Geddes và Mark Somerville về những cộng tác với tôi từ sớm để hình thành `Modeling and Simulation' (Mô hình hoá và Mô phỏng), lớp họp tại Olin College mà nội dung cuốn sách này dựa theo.

\item Bản thảo ban đầu của cuốn sách này hưởng lợi từ những cuộc đối thoại với các đồng nghiệp tuyệt vời của tôi tại trường Olin College, bao gồm John Geddes, Alison Wood, Chris Lee, và Jason Woodard.

\item Tôi cám ơn Lisa Downey và Jason Woodard đã chuyên tâm rà soát bản thảo cẩn thận.

\item Cám ơn Alessandra Ferzoco, Erhardt Graeff, Emily Tow, Kelsey Houston-Edwards, Linda Vanasupa, Matt Neal, Joanne Pratt, và Steve Matsumoto đã có những gợi ý hữu ích.

% ENDCONTRIB

\end{itemize}



\normalsize

\cleardoublepage

% TABLE OF CONTENTS
\begin{latexonly}

% \tableofcontents

\cleardoublepage

\end{latexonly}

% START THE BOOK
\mainmatter


\chapter{Mô hình hoá}
\label{chap01}

Cuốn sách này là về mô hình hoá và mô phỏng các hệ thống vật lý.
Sơ đồ sau đây cho thấy tôi có ý gì khi nhắc đến ``mô hình hoá'':

\index{modeling}

\vspace{0.2in}
\centerline{\includegraphics[height=3in]{figs/modeling_framework.pdf}}

Bắt đầu từ góc trái phía dưới, {\bf hệ thống} là sự vật có ở thế giới thực, mà ta quan tâm. Thông thường, nó là thứ phức tạp, vì vậy mà ta phải quyết định xem cần phải bỏ qua những chi tiết gì. Việc bỏ qua chi tiết được gọi là {\bf trừu tượng hoá}.

\index{hệ thống}

Kết quả của việc trừu tượng hoá là một {\bf mô hình}, vốn là hình thức mô tả cho hệ thống, ở đó chỉ gồm những yếu tố mà ta coi là thiết yếu. Một mô hình có thể được biểu diễn đưới hình thức các sơ đồ và phương trình, mà ta có thể dùng cho {\bf phân tích} toán học. Song nó cũng có thể được thực thi dưới dạng một chương trình máy tính, vốn có thể chạy những {\bf mô phỏng}.

\index{mô hình}
\index{trừu tượng hoá}
\index{phân tích}

Kết quả của phân tích và mô phỏng có thể là một {\bf dự đoán} về những gì mà hệ thống sẽ diễn ra, {\bf giải thích} tại sao nó biểu hiện như vậy, hoặc một  {\bf thiết kế} nhằm đạt được mục đích cụ thể.

\index{dự đoán}
\index{giải thích}
\index{thiết kế}

Chúng ta có thể {\bf kiểm định} các dự đoán và kiểm tra các thiết kế bằng cách tiến hành {\bf đo đạc} từ thế giới thực và đem so sánh {\bf dữ liệu} thu được với các kết quả từ phân tích và mô phỏng.

\index{kiểm định}
\index{dữ liệu}

Với bất kì hệ thống vật lý nào, đều có thể đưa ra nhiều mô hình; mỗi mô hình đưa vào hoặc loại trừ các yếu tố riêng, hoặc có những mức chi tiết khác nhau. Mục tiêu của quá trình mô hình hoá là tìm mô hình phù hợp nhất cho mục đích của nó (dự đoán, giải thích hoặc thiết kế).

\index{mô hình hoá lặp}

Đôi khi mô hình tốt nhất là mô hình chi tiết nhất. Nếu ta bao gồm thêm các yếu tố, mô hình sẽ chân thực hơn, và chúng ta đều trông đợi những dự đoán từ mô hình sẽ chính xác hơn.

\index{chủ nghĩa hiện thực}

Nhưng thường thì mô hình đơn giản lại tốt hơn. Nếu chúng ta chỉ bao gồm những yếu tố thiết yếu nhất và bỏ qua những yếu tố khác, ta sẽ có mô hình dễ thao tác hơn, và những lời giải thích thu được từ mô hình có thể rõ ràng hơn và có tính thuyết phục hơn.

\index{tính đơn giản}

Lấy ví dụ, giả sử có người hỏi bạn tại sao quỹ đạo Trái đất lại có dạng gần như đường elip. Nếu bạn mô hình hóa Trái đất và Mặt trời như những chất điểm (bỏ qua kích thước thực của chúng) rồi tính lực hấp dẫn giữa chúng bằng định luật vạn vật hấp dẫn, sau đó tính kết quả quỹ đạo bằng định luật chuyển động của Newton, thì bạn sẽ có thể cho thấy được kết quả là một đường elip.

\index{quỹ đạo}
\index{elip}

Dĩ nhiên, quỹ đạo thực của Trái đất không phải là một đường elip hoàn hảo, vì có lực hấp dẫn của Mặt trăng, sao Mộc, cùng các thiên thể khác trong hệ mặt trời; và vì định luật Newton về chuyển động chỉ là gần đúng (không xét đến các hiệu ứng tương đối).

\index{Newton}
\index{thuyết tương đối}

Nhưng bổ sung các yếu tố trên đây vào mô hình chẳng thể cải thiện được lời giải thích; thêm các chi tiết chỉ gây nhiễu quanh nguyên nhân cơ bản. Tuy vậy, nếu mục đích là nhằm dự đoán vị trí Trái đất với độ chính xác cao, thì việc bổ sung thêm chi tiết có thể lại cần thiết. 

Việc chọn mô hình tốt nhất tuỳ thuộc vào mô hình để làm gì. Thường thì việc bắt đầu với mô hình đơn giản là một ý hay, ngay cả khi mô hình dường như quá đơn giản, và rồi thử xem mô hình có đủ tốt cho mục đích dự kiến chưa. Sau đó, bạn có thể dần bổ sung các yếu tố, bắt đầu từ yếu tố mà bạn nghĩ là thiết yếu nhất. Quy trình này được gọi là {\bf mô hình hoá lặp}.

Việc so sánh kết quả của các mô hình liên tiếp sẽ cho ta một dạng {\bf kiểm định bên trong}, nhờ vậy bạn có thể bắt các lỗi về khái niệm, toán học, và lập trình. Và qua việc bổ sung và lược bớt các yếu tố, bạn sẽ chỉ ra được yếu tố nào có ảnh hưởng lớn nhất đến kết quả, và yếu tố nào có thể bỏ qua được.

\index{kiểm định bên trong}
\index{kiểm định bên ngoài}

Việ có sánh kết quả với dữ liệu cung cấp từ hiện thực là hình thức {\bf kiểm định bên ngoài}, vốn thường là phép thử mạnh nhất.


\section{Chuyện hoang đường về đồng xu rơi}
\label{penny}

Hãy cùng xem một ví dụ về cách dùng mô hình như thế nào. Có thể bạn đã từng nghe về câu chuyện đồng xu được thả từ trên nóc nhà Empire State Building (Mỹ) sẽ rơi nhanh đến nỗi khi đập vào vỉa hè sẽ cắm sâu vào bê tông; hay nếu rơi trúng ai thì sẽ làm bể sọ.

\index{Empire State Building}
\index{đồng xu}
\index{chuyện hoang đường}

Ta có thể kiểm chứng câu chuyện này bằng cách thiết lập và phân tích một mô hình. Từ đầu, ta sẽ coi rằng ảnh hưởng của sức cản không khí là rất nhỏ. Sau này ta sẽ thấy giả thiết như vậy là rất dở, nhưng hãy kiên nhẫn đã.

Nếu như lực cản không khí là bỏ qua được thì lực cơ bản tác dụng lên đồng xu là trọng lực, vốn khiến cho đồng xu tăng tốc hướng xuống. 
\index{sức cản không khí}

Nếu như vận tốc ban đầu bằng 0, thì vận tốc sau $t$ giây là $a t$, và khoảng cách đồng xu đã rơi là:
%
\[ h = a t^2 / 2 \]
%
Ta có thể dùng đại số để giải ra $t$:
%
\[ t = \sqrt{ 2 h / a} \]
%
Lắp vào biểu thức gia tốc trọng trường, $a = \SI{9.8}{\meter\per\second\squared}$, và chiều cao toà nhà Empire State Building, $h=\SI{381}{\meter}$, ta có được $t = \SI{8.8}{\second}$.  Sau đó, tính $v = a t$ ta có vận tốc tiếp đất $\SI{86}{\meter\per\second}$, tức là 310 km/h.  Xem ra rơi trúng người sẽ nguy hiểm lắm đây.

Dĩ nhiên, những kết quả này đều không chính xác vì mô hình được lập nên dựa theo các sự giản hoá. Chẳng hạn, ta đã giả thiết rằng gia tốc trọng trường là một hằng số. Thực ra, trọng lực sẽ thay đổi ở những nơi khác nhau trên Trái đất, và trọng lực càng yếu hơn khi ta lên cao. Nhưng sự khác biệt này là quá nhỏ, bởi vậy bỏ qua điều đó có lẽ là lựa chọn hợp lý trong trường hợp này.
\index{trọng lực}

Mặt khác, việc bỏ qua sức cản không khí lại là một lựa chọn không hay. Một khi đồng xu đạt tốc độ khoảng \SI{18}{\meter\per\second}, lực cản không khí hướng lên trên sẽ cân bằng với trọng lực hướng xuống, vì vậy mà đồng xu sẽ không tiếp tục tăng tốc nữa. Từ đó trở đi, không phụ thuộc đồng xu sẽ rơi tiếp bao nhiêu nữa, nó sẽ đập vào vỉa hè (hay ai đó) với vận tốc khoảng \SI{18}{\meter\per\second}, nhỏ hơn nhiều so với trị số \SI{86}{\meter\per\second}, mà mô hình đơn giản đã ước tính ra.

Nhà thống kê học George Box có câu nói nổi tiếng ``Tất cả mô hình đều sai, nhưng một vài trong số đó lại hữu ích."  Dù ông đã nói về các mô hình thống kê, song câu nói đậm trí tuệ này áp dụng được cho mọi loại mô hình. Mô hình đầu tiên của chúng ta, vốn bỏ qua sức cản không khí, là rất sai, và có thể không hữu ích gì. Trong tập notebook của chương này, bạn sẽ thấy một mô hình khác, trong đó coi rằng gia tốc là một hằng số đến tận khi đồng xu đạt một vận tốc tới hạn. Mô hình này cũng vẫn sai, nhưng nó hay hơn, và đủ hợp lý để phản bác lại câu chuyện hoang đường kể trên.

\index{Box, George}

Chương trình TV {\it Mythbusters} đã kiểm tra câu chuyện hoang đường trên một cách cẩn thận hơn; bạn có thể xem kết quả tại \url{http://modsimpy.com/myth}.  Nghiên cứu của họ được dựa trên một mô hình toán học về chuyển động, các thí nghiệm đo đạc nhằm xác định lực cản của không khí lên đồng xu, và một mô hình vật lý mô phỏng đầu người.

\index{Mythbusters}


\section{Tính toán}
\label{computation}

Có (ít nhất là) hai cách làm việc với mô hình toán: {\bf phân tích} và {\bf mô phỏng}.  Phân tích thường gắn với phép tính đại số và biến đổi các biểu thức. Mô phỏng thường gắn với máy tính.
\index{phân tích}
\index{mô phỏng}

Trong cuốn sách này chúng ta phân tích một chút và mô phỏng rất nhiều; xuyên suốt nội dung tôi sẽ thảo luận cả ưu điểm lẫn nhược điểm của từng cách. Các công cụ cơ bản mà tôi dùng cho mô phỏng là ngôn ngữ lập trình Python và Jupyter, vốn là một môi trường để viết và chạy các chương trình.

Ví dụ đầu tiên, tôi sẽ cho bạn thấy tôi đã tính kết quả từ mục trước bằng Python như thế nào. 

Thứ nhất, tôi tạo ra một {\bf biến} để biểu diễn gia tốc.

\index{biến}
\index{giá trị}

\begin{python}
a = 9.8 * meter / second**2
\end{python}

Một biến là một tên tương ứng với một giá trị. Trong ví dụ này, cái tên đó là \py{a} và giá trị là con số \py{9.8} nhân với đơn vị \py{meter / second**2}.  Ví dụ này đã cho thấy một số kí hiệu mà Python sử dụng để thực hiện các phép toán:
\index{toán tử}

\begin{tabular}{l|c}
{\bf Phép toán} & {\bf Kí hiệu} \\ 
\hline 
Cộng & \py{+} \\ 
Trừ & \py{-} \\ 
Nhân & \py{*} \\ 
Chia & \py{/} \\ 
Luỹ thừa & \py{**}  \\ 
\end{tabular} 

Tiếp theo, ta có thể tính thời gian cần thiết để đồng xu rơi được  \SI{381}{\meter}, chiều cao của toà nhà Empire State Building.

\begin{python}
h = 381 * meter
t = sqrt(2 * h / a)
\end{python}

Các dòng này tạo ra thêm hai biến nữa: \py{h} nhận chiều cao của toàn nhà tính theo mét; \py{t} nhận thời gian, tính theo giây, để đồng xu rơi xuống vỉa hè.  \py{sqrt} là một {\bf hàm} để tính căn bậc hai. Python theo dõi đơn vị, và do đó, \py{t}, có đơn vị đúng, là giây.
\index{đơn vị}
\index{hàm}
\index{sqrt}

Cuối cùng, ta có thể tính vận tốc của đồng xu sau $t$ giây:

\begin{python}
v = a * t
\end{python}

Kết quả là khoảng \SI{86}{\meter\per\second}, một lần nữa với đơn vị đúng. 

Ví dụ này đã cho thấy các khâu phân tích và tính toán bằng Python.  Tiếp theo, ta sẽ thấy một ví dụ mô phỏng.

Trước khi bạn đọc tiếp, có thể bạn sẽ muốn xem tập notebook cho chương này, \py{chap01.ipynb}, và làm bài tập. Hướng dẫn tải về và chạy mã lệnh có ở Mục~\ref{code}.


\chapter{Dùng chung xe}
\label{chap02}

Chương này trình bày một mô hình đơn giản của hệ thống dùng chung xe đạp, đồng thời giới thiệu các đặc điểm Python mà ta sẽ dùng để phát triển các mô phỏng cho hệ thống ngoài đời thực.

Cũng trong quá trình đọc, bạn sẽ ra quyết định về cách mô phỏng hệ thống. Ở chương tiếp theo ta sẽ điểm lại những quyết định này và dần dần cải thiện mô hình.


\section{Mô hình hoá}
\label{modeling}

Hãy tưởng tượng một hệ thống dùng chung xe đạp cho các sinh viên đi lại giữa hai trường Olin College và Wellesley College; hai trường này cách nhau khoảng 3 dặm (5 km) trên miền Đông bang Massachusetts.

\index{Wellesley College}
\index{Olin College}

Coi rằng hệ thống có 12 xe đạp và hai dãy xe, một ở Olin và một ở Wellesley, mỗi dãy chứa được 12 xe.

\index{hệ thống dùng chung xe}

Khi các sinh viên tới nơi, để lấy xe và đạp đến trường kia, thì số xe ở mỗi nơi sẽ thay đổi. Trong mô phỏng này, chúng ta sẽ cần dõi theo các xe đang ở đâu. Để làm điều này, tôi sẽ tạo ra một đối tượng \py{State}, vốn được định nghĩa trong thư viện \py{modsim}.  

\index{State - đối tượng}

Trước khi ta có thể sử dụng thư viện này, ta phải nhập nó bằng lệnh \py{import}:

\begin{python}
from modsim import *
\end{python}

Dòng lệnh này là một {\bf câu lệnh import} để bảo Python đọc file {\tt modsim.py} và làm các hàm mà nó định nghĩa trở nên sẵn có để dùng.

\index{import - câu lệnh}

Các hàm trong thư viện \py{modsim.py} bao gồm \py{sqrt}, mà ta đã dùng ở mục trước, và \py{State}, mà ta sẽ dùng ngay đây.  \py{State} tạo nên một đối tượng \py{State}, vốn là một tập hợp các {\bf biến trạng thái}.  

\index{biến trạng thái}

\begin{python}
bikeshare = State(olin=10, wellesley=2)
\end{python}

Các biến trạng thái, \py{olin} và \py{wellesley}, biểu diễn số xe đạp ở mỗi nơi. Các giá trị ban đầu là 10 và 2, thể hiện rằng có 10 xe tại Olin và 2 tại Wellesley.  Đối tượng \py{State} tạo bởi \py{State} được gán cho một biến mới có tên là \py{bikeshare}.

\index{chấm - toán tử}
\index{toán tử!chấm}

Chúng ta có thể đọc các biến bên trong một đối tượng \py{State} bằng cách dùng một {\bf toán tử chấm}, kiểu như sau:

\begin{python}
bikeshare.olin
\end{python}

Kết quả là trị số 10.  Tương tự, với:

\begin{python}
bikeshare.wellesley
\end{python}

kết quả là 2.  Nếu bạn quên mất trong đối tượng trạng thái có những biến gì, thì bạn chỉ cần gõ mỗi tên:

\begin{python}
bikeshare
\end{python}

Kết quả trông giống như một cái bảng gồm tên các biến cùng giá trị của chúng:

\begin{tabular}{lr}
 & {\bf \sf value} \\ 
\hline 
{\bf \sf olin} & 10 \\ 
{\bf \sf wellesley} & 2 \\ 
\end{tabular} 

Các biến trạng thái và giá trị của chúng hợp thành {\bf trạng thái } của hệ thống. Ta có thể cập nhật hệ thống bằng cách gán những giá trị mới cho các biến. Chẳng hạn, nếu một sinh viên đưa một xe từ Olin đến Wellesley, ta có thể hình dung ra những giá trị mới và gán chúng:

\index{state}

\begin{python}
bikeshare.olin = 9
bikeshare.wellesley = 3
\end{python}

Hoặc ta có thể dùng các {\bf toán tử cập nhật}, \py{-=} và \py{+=}, để trừ 1 từ \py{olin} và cộng 1 vào \py{wellesley}:

\index{cập nhật - toán tử}
\index{toán tử!cập nhật}

\begin{python}
bikeshare.olin -= 1
bikeshare.wellesley += 1
\end{python}

Kết quả thì như nhau dù làm theo cách nào, song cách thứ hai thì linh hoạt hơn.


\section{Định nghĩa hàm}

Đến giờ ta đã dùng các hàm đã được định nghĩa trong \py{modsim} và các thư viện khác. Tiếp theo ta sẽ định nghĩa các hàm ta tự lập ra.

\index{hàm}
\index{định nghĩa hàm}

Khi bạn viết chương trình trong Jupyter, thường bạn chỉ viết vài 
dòng lệnh là được, rồi kiểm tra để chắc chúng hoạt động theo dự tính,
sau đó sẽ dùng chúng để định nghĩa một hàm mới. Chẳng hạn,
những dòng lệnh sau để di chuyển xe từ Olin đến Wellesley:

\begin{python}
bikeshare.olin -= 1
bikeshare.wellesley += 1
\end{python}

Thay vì việc lặp lại mỗi lần di chuyển một xe, ta có thể định nghĩa một
hàm mới:

\begin{python}
def bike_to_wellesley():
    bikeshare.olin -= 1
    bikeshare.wellesley += 1
\end{python}

\py{def} là một từ đặc biệt trong Python để chỉ rằng ta đang định nghĩa một hàm mới. Tên hàm này là \py{bike_to_wellesley}.  Cặp ngoặc tròn trong đó để trống thể hiện rằng hàm này không cần thêm thông tin nào khi nó chạy. Dấu hai chấm thể hiện sự bắt đầu một 
{\bf khối lệnh}.
\index{def}
\index{khối lệnh}
\index{thân}
\index{thụt đầu dòng}

Hai dòng tiếp theo là phầm {\bf thân} của hàm. Chúng phải được thụt đầu dòng, theo quy định là thụt dòng 4 dấu cách.

Khi bạn định nghĩa một hàm, nó không có hiệu ứng tức thì nào. Phần thân của hàm không được chạy đến khi bạn {\bf gọi} hàm đó. Sau đây là cách gọi hàm này:
\index{gọi}

\begin{python}
bike_to_wellesley()
\end{python}

Khi bạn gọi hàm, nó chạy các câu lệnh trong phần thân, vốn cập nhật các biến của đối tượng {\tt bikeshare}; bạn có thể kiểm tra bằng cách hiển thị hoặc vẽ trạng thái mới.

Khi bạn gọi một hàm, bạn phải kèm theo cặp ngoặc tròn. Nếu bạn bỏ quên chúng, kiểu như sau:
\index{đối số}
\index{cặp ngoặc tròn}

\begin{python}
bike_to_wellesley
\end{python}

thì Python sẽ tra tìm tên của hàm và hiển thị:

\begin{python}
<function __main__.bike_to_wellesley>
\end{python}

Kết quả cho thấy rằng \py{bike_to_wellesley} là một hàm. Bạn không cần phải biết \py{__main__} nghĩa là gì, nhưng nếu bạn đọc thấy chữ gì kiểu như thế này, thì có thể bạn đã chiếu đến một hàm nhưng chưa thực sự gọi nó. Bởi vậy đừng quên cặp ngoặc tròn.

Cũng như \py{bike_to_wellesley}, ta có thể định nghĩa một hàm để di chuyển một xe đạp từ Wellesley đến Olin:

\begin{python}
def bike_to_olin():
    bikeshare.wellesley -= 1
    bikeshare.olin += 1
\end{python}

Và gọi nó như sau:

\begin{python}
bike_to_olin()
\end{python}

Một lợi ích của việc định nghĩa hàm là bạn có thể tránh việc gọi một cụm câu lệnh, và nhờ đó làm chương trình nhỏ gọn hơn. Một lợi ích khác là tên của ạn đặt cho hàm thì mô tả công dụng của nó, điều này khiến cho chương trình dễ đọc hơn.


\section{Câu lệnh print}

Khi bạn viết các chương trình phức tạp hơn, rất dễ mất dấu việc ban đang làm. Một trong những công cụ quan trọng nhất để gỡ lỗi là {\bf câu lệnh print}, vốn để hiển thị chữ trong quyển Jupyter.
\index{print - câu lệnh}
\index{câu lệnh!print}

Thông thường khi Jupyter chạy mã lệnh trong một ô (cell), nó hiển thị giá trị của dòng lệnh cuối cùng. Chẳng hạn, nếu bạn chạy:

\begin{python}
bikeshare.olin
bikeshare.wellesley
\end{python}

thì Jupyter chạy cả hai dòng lệnh, nhưng nó chỉ hiển thị giá trị của dòng thứ hai. Nếu bạn muốn hiển thị nhiều hơn một dòng, bạn có thể dùng câu lệnh print:

\begin{python}
print(bikeshare.olin)
print(bikeshare.wellesley)
\end{python}

\py{print} là một hàm, vì vậy nó nhận một đối số trong cặp ngoặc tròn. Nó cũng có thể nhận một dãy các  đối số phân tách bởi dấu phẩy, như sau:

\begin{python}
print(bikeshare.olin, bikeshare.wellesley)
\end{python}

Ở ví dụ này, hai giá trị sẽ xuất hiện trên một dòng, giữa chúng là một dấu cách.

Các lệnh print cũng hữu ích với chức năng gỡ lỗi. Chẳng hạn, ta có thể bổ sung một lệnh print vào \py{move_bike}, như sau:

\begin{python}
def bike_to_wellesley():
	print('Moving a bike to Wellesley')
    bikeshare.olin -= 1
    bikeshare.wellesley += 1
\end{python}

Mỗi lần ta gọi hàm này, nó sẽ hiển thị một dòng thông báo, vốn có thể giúp ta theo dõi được chương trình đang làm gì.

\index{chuỗi}

Đối số của lệnh \py{print} này là một {\bf chuỗi}, vốn là một dãy các chữ cái và kí hiệu đặt trong cặp dấu nháy.



\section{Câu lệnh if}

Thư viện \py{modsim} cung cấp một hàm có tên \py{flip}; nó nhận vào một đối số là một giá trị xác suất từ 0 đến 1:

\begin{python}
flip(0.7)
\end{python}

Kết quả là một trong hai giá trị: \py{True} với xác suất 0.7 hoặc \py{False} với xác suất 0.3.  Nếu bạn chạy hàm này 100 lần, bạn sẽ nhận được \py{True} khoảng 70 lần và \py{False} khoảng 30 lần. Nhưng kết quả đều là ngẫu nhiên và do vậy có thể khác với hai con số được trông đợi nêu trên.
\index{flip}
\index{True}
\index{False}

\py{True} và \py{False} là các giá trị đặc biệt được định nghĩa bởi Python. Chú ý rằng chúng không phải các chuỗi. Có sự khác nhau giữa \py{True}, vốn là giá trị đặc biệt, với \py{'True'}, vốn là một chuỗi.
\index{chuỗi}
\index{kiểu boole}

\py{True} và \py{False} được gọi là các giá trị {\bf kiểu boole} vì chúng có liên hệ với môn đại số Boole (\url{http://modsimpy.com/boolean}).

Ta có thể dùng các giá trị boole để kiểm soát hành vi của chương trình, bằng một {\bf câu lệnh if}:
\index{if - câu lệnh}
\index{câu lệnh!if}

\begin{python}
if flip(0.5):
    print('heads')
\end{python}

Nếu kết quả từ \py{flip} là \py{True}, chương trình sẽ hiển thị chuỗi \py{'heads'}.  Ngược lại, nó sẽ không làm gì cả.

Cách chấm câu lệnh if cũng giống như ở lời định nghĩa hàm: dòng đầu tiên phải được kết thúc bởi dấu hai chấm, còn các dòng bên trong lệnh if phải được thụt đầu dòng. 
\index{thụt đầu dòng}
\index{else - vế câu lệnh}

Bạn có quyền lựa chọn bổ sung một {\bf vế lệnh else} để quy định điều gì sẽ xảy ra nếu kết quả là \py{False}:

\begin{python}
if flip(0.5):
    print('heads')
else:
    print('tails')    
\end{python}

Bây giờ ta có thể dùng \py{flip} để mô phỏng sự xuất hiện của những sinh viên muốn mượn xe đạp. Coi rằng sinh viên đến trạm Olin trung bình 2 phút một lượt. Trong trường hợp này, xác suất để có sinh viên đến trong mỗi thời đoạn từng phút là 50\%, và ta có thể mô phỏng như sau:

\begin{python}
if flip(0.5):
    bike_to_wellesley()
\end{python}

Nếu các sinh viên đến trạm Wellesley trung bình là 3 phút một lượt, thì xác suất để có sinh viên đến trong mỗi thời đoạn từng phút là 33\%, và ta có thể mô phỏng như sau:

\begin{python}
if flip(0.33):
    bike_to_olin()
\end{python}

Ta có thể kết hợp những đoạn lệnh này vào một hàm để mô phỏng một {\bf bước thời gian}, hay là một thời khoảng, ở đây là một phút:

\index{bước thời gian}

\begin{python}
def step():
    if flip(0.5):
        bike_to_wellesley()
    
    if flip(0.33):
        bike_to_olin()
\end{python}

Khi đó ta có thể mô phỏng một bước thời gian như sau:

\begin{python}
step()
\end{python}



\section{Tham số}

Phiên bản trước của hàm \py{step} là phù hợp nếu như xác suất sinh viên đến là không đổi, nhưng trong thực tế, những xác suất này có thay đổi theo thời gian.

Bởi vậy thay vì đặt các hằng số 0.5 và 0.33 vào \py{step}, ta có thể thay chúng bằng các {\bf tham số}.  Tham số là các biến số mà giá trị của chúng được gán khi một hàm được gọi.

Sau đây là một phiên bản của \py{step} nhận vào hai tham số, \py{p1} và \py{p2}:

\index{xác suất}

\begin{python}
def step(p1, p2):
    if flip(p1):
        bike_to_wellesley()
    
    if flip(p2):
        bike_to_olin()
\end{python}

Các giá trị \py{p1} và \py{p2} không được đặt trong hàm này; mà sẽ được cung cấp khi hàm được gọi, như sau:

\begin{python}
step(0.5, 0.33)
\end{python}

Các giá trị mà bạn cung cấp khi gọi hàm thì là các {\bf đối số}.
Các đối số, \py{0.5} và \py{0.33}, được gán cho các tham số, lần lượt là \py{p1} và \py{p2}. Bởi vậy việc chạy hàm này sẽ có hiệu quả tương tự như:

\begin{python}
p1 = 0.5
p2 = 0.33

if flip(p1):
    bike_to_wellesley()
    
if flip(p2):
    bike_to_olin()
\end{python}

Lợi ích của việc dùng tham số là bạn có thể gọi cùng một hàm nhiều lần, mỗi lần lại cung cấp các đối số khác nhau. Việc bổ sung các tham số vào cho một hàm được gọi là sự {\bf khái quát hóa}, vì nó làm cho hàm tổng quát hơn, hay bớt cụ thể đi.

\index{khái quát hóa}


\section{Vòng lặp for}
\label{forloop}

Đến một lúc nào đó bạn sẽ chán ngấy việc chạy đi chạy lại một ô nhiều lần. Thật may là có một cách đơn giản để lặp lại một đoạn lệnh, đó là dùng {\bf vòng lặp for}.  Sau đây là một ví dụ:
\index{for - vòng lặp}
\index{vòng lặp}

\begin{python}
for i in range(4):
    bike_to_wellesley()
\end{python}

Cách chấm câu lệnh ở đây cũng quen thuộc: dòng đầu tiên kết thúc bởi dấu hai chấm, và các dòng bên trong vòng lặp for thì được thụt đầu dòng. Các đặc điểm khác của vòng lặp for này bao gồm:
\index{range}

\begin{itemize}

\item \py{for} và \py{in} là những từ đặc biệt mà ta phải dùng trong một vòng lặp for.

\item \py{range} là một hàm Python mà ta dùng ở đây để ta kiểm soát số lần mà vòng lặp chạy.
\index{range}

\item \py{i} là một {\bf biến lặp} được tạo ra khi vòng lặp for chạy.
\index{biến lặp}

\end{itemize}

Trong ví dụ này, thực ra ta không dùng đến \py{i}; sau này ta sẽ thấy các ví dụ dùng đến biến lặp bên trong vòng lặp.

Khi vòng lặp này chạy, nó chạy những câu lệnh bên trong vòng lặp 4 lần, mỗi lần thực hiện chuyển một xe đạp từ Olin đến Wellesley.


\section{TimeSeries: chuỗi thời gian}
\label{timeseries}

Khi chạy một mô phỏng, ta thường muốn lưu kết quả để về sau phân tích. Thư viện \py{modsim} cung cấp một đối tượng \py{TimeSeries} (tạm gọi `chuỗi thời gian') nhằm mục đích này. \py{TimeSeries} chứa một dãy các mốc thời gian cùng một dãy các giá trị tương ứng. Trong ví dụ này, các mốc thời gian là những số nguyên biểu thị các phút, còn những giá trị là số xe đạp tại một địa điểm.

%TODO: index modsim library functions
\index{modsim - thư viện}
\index{TimeSeries}
\index{chuỗi thời gian}

Ta có thể tạo ra một \py{TimeSeries} trống, mới như sau:

\begin{python}
results = TimeSeries()
\end{python}

Và ta có thể thêm một giá trị vào \py{TimeSeries} như sau:

\begin{python}
results[0] = bikeshare.olin
\end{python}

Con số đặt giữa cặp ngoặc vuông là mốc thời gian, còn được gọi là một {\bf nhãn}.
\index{nhãn}

Ta có thể dùng một \py{TimeSeries} bên trong một vòng lặp for để lưu kết quả của mô phỏng:

\begin{python}
for i in range(10):
    step(0.3, 0.2)
    results[i] = bikeshare.olin
\end{python}

Mỗi lần duyệt qua vòng lặp, ta gọi \py{step}, vốn sẽ cập nhật \py{bikeshare}.  Sau đó, ta lưu số xe đạp ở Olin vào \py{results}.  Ta dùng biến lặp, \py{i}, làm mốc thời gian.

\index{lặp}
\index{biến lặp}
\index{mốc thời gian}

Khi vòng lặp thoát ra, \py{results} có chứa 10 bước thời gian, từ 0 đén 9, cùng số xe đạp ở Olin tại thời điểm cuối mỗi bước thời gian.
\index{biến lặp}

\py{TimeSeries} là một phiên bản riêng của \py{Series}, vốn được định nghĩa bởi Pandas, một trong những thư viện mà ta sẽ dùng đến rất nhiều. Đối tượng \py{Series} cung cấp nhiều hàm; một trong số đó là \py{mean}, mà ta sẽ gọi như sau đây:

\begin{python}
results.mean()
\end{python}

Bạn có thể đọc tài liệu hướng dẫn về \py{Series} tại \url{http://modsimpy.com/series}.

\index{Pandas}
\index{Series}
\index{TimeSeries}
\index{chuỗi thời gian}
\index{mean}
\index{trung bình}


\section{Vẽ đồ thị}
\label{plotting}

Thư viện \py{modsim} cung cấp một hàm có tên \py{plot} dùng để vẽ đồ thị kết quả (\py{results}):

\begin{python}
plot(results)
\end{python}

\py{plot} có thể nhận vào thêm một đối số nữa chứa nhãn hiệu cho đường đồ thị; nhãn hiệu này sẽ được ghi ở ô chú giải (Legend) của biểu đồ, nếu ta cho phép tạo ô chú giải.

\begin{python}
plot(results, label='Olin')
\end{python}

\py{label} là một ví dụ về {\bf đối số từ khóa}, so called because we provide a ``keyword'', which is \py{label} in this case, along with its value.  Arguments without keywords are called {\bf positional arguments} because they are assigned to parameters according to their position.  It is good to know these terms because they appear in Python error messages.

\index{đối số từ khóa}
\index{đối số vị trí}
\index{đối số}

Mỗi khi bạn tạo một hình biểu đồ, bạn nên đề tên các trục.  Thư viện \py{modsim} cung cấp \py{decorate}, có chức năng đề tên các trục và cho biểu đồ một tiêu đề cũng như dành ra một ô chú giải:

\begin{python}
decorate(title='Olin-Wellesley Bikeshare',
         xlabel='Time step (min)', 
         ylabel='Number of bikes')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap01-fig01.pdf}}
\caption{Kết quả mô phỏng một hệ thống dùng chung xe tại Olin theo thời gian.}
\label{chap01-fig01}
\end{figure}

Hình~\ref{chap01-fig01} cho thấy kết quả.

\py{plot} và \py{decorate} đều được dựa trên Pyplot, vốn là một thư viện Python để tạo ra các hình biểu đồ. Bạn có thể đọc thêm về \py{plot} cùng các đối số mà nó nhận tại \url{http://modsimpy.com/plot}.

\index{Pyplot}
\index{plot}
\index{đồ thị}
\index{decorate}

Trước khi đọc tiếp, bạn có thể muốn xem các quyển tập lệnh trong chương này, \py{chap02.ipynb}, và làm các bài tập. Hãy xem hướng dẫn tải về và chạy mã lệnh ở Mục~\ref{code}.



\chapter{Mô hình hóa lặp}
\label{chap03}

Để nhắc lại lời của George Box và George Orwell, ``Mọi mô hình đều sai, nhưng một số mô hình thì sai nhiều hơn số khác."  Trong chương này, tôi cho thấy quá trình chúng tôi thực hiện để mô hình bớt sai đi.

\index{Box, George}
\index{Orwell, George}

Lấy một ví dụ, ta xem lại mô hình dùng chung xe từ chương trước, đánh giá ưu nhược điểm của nó, rồi dần dần cải thiện nó. Chúng tôi cũng sẽ xem các cách sử dụng mô hình và hiểu ứng xử của hệ thống cũng như đánh giá các thiết kế dự kiến để mô hình làm việc tốt hơn.

\index{dùng chung xe}


\section{Mô hình hóa lặp}

Mô hình hiện nay thật đơn giản, nhưng nó dựa trên các giả thiết phi thực tế. Trước khi đọc tiếp, bạn hãy dành một phút để điểm lại mô hình từ những chương trước. Mô hình được dựa trên các giả thiết gì? Hãy lập danh sách các điểm khiến cho mô hình trở nên phi thực tế, hay là giữa mô hình và thực tế có những khác biệt gì?

Sau đây là một số điểm khác biệt mà tôi đã lập trong danh sách của mình:

\begin{itemize}

\item Trong mô hình, mỗi sinh viên có thể đến vào một phút bất kì. Còn trong thực tế, xác suất này phụ thuộc vào thời gian trong ngày, ngày trong tuần, v.v.

\index{xác suất}

\item Mô hình không xét đến thời gian di chuyển giữa các trạm.

\item Mô hình không kiểm tra liệu xe đạp có sẵn hay không, bởi vậy nên có khả năng xảy ra số xe âm (như bạn có thể nhận thấy khi thực hiện mô phỏng).

\end{itemize}

Một vài quyết định mô hình hóa trong số này thì hay hơn cái khác. Chẳng hạn, giả thiết thứ nhất có thể hợp lý nếu như ta mô phỏng hệ thống trong khoảng thời gian ngắn như 1 giờ chẳng hạn.

Giả thiết thứ hai thì không thực tế cho lắm, nhưng có thể nó cũng không ảnh hưởng nhiều đến kết quả, tùy theo việc ta dùng mô hình cho mục đích gì.

\index{realism}

Mặt khác, giả thiết thứ ba có vẻ rắc rối, song có thể sửa được khá dễ dàng. Chúng ta sẽ giải quyết vấn đề trong mục ~\ref{negativebikes}.

Quá trình này, bắt đầu từ một mô hình đơn giản, nhận diện những vấn đề quan trọng nhất, rồi cải tiến dần dần, được gọi là {\bf mô hình hóa lặp}.

\index{mô hình hóa lặp}

Với bất kì một hệ thống thực nào, có rất nhiều mô hình khả dĩ, dựa trên các giả thiết và phép giản hóa khác nhau. Thường sẽ phải mất vài lần lặp mới thiết lập được một mô hình đủ tốt cho mục đích đề ra mà không phức tạp quá mức cần thiết.


\section{Nhiều hơn một đối tượng State}

Trước khi ta tiếp tục, tôi muốn sửa đổi vài chỗ mã lệnh từ chương trước. Đầu tiên, tôi sẽ khái quát hóa các hàm đã viêt ra, để chúng nhận một đối tượng \py{State} làm tham số. Sau đó, tôi sẽ làm mã lệnh dễ đọc hơn bằng việc bổ sung đoạn tài liệu chú thích.

\index{tham số}

Sau đây là một trong các hàm từ chương trước, hàm \py{bike_to_wellesley}:

\begin{python}
def bike_to_wellesley():
    bikeshare.olin -= 1
    bikeshare.wellesley += 1
\end{python}

Khi ta gọi hàm này, nó làm thay đổi \py{bikeshare}.  Miễn là khi chỉ có một đối tượng \py{State} duy nhất, mọi việc đều ổn. Nhưng nếu có nhiều hơn một hệ thống đi chung xe thì sao? Hoặc nếu ta muốn chạy mô phỏng thì sao?

Hàm này sẽ trở nên linh hoạt hơn nếu nó nhận một đối tượng \py{State} làm tham số. Sau đây là hàm đó khi có tham số:

\index{State - đối tượng}

\begin{python}
def bike_to_wellesley(state):
    state.olin -= 1
    state.wellesley += 1
\end{python}

Tên của tham số là \py{state} thay vì \py{bikeshare} như để ghi nhớ rằng giá trị của \py{state} có thể là bất kì đối tượng \py{State} nào, chứ không riêng gì \py{bikeshare}.

Phiên bản \py{bike_to_wellesley} này yêu cầu một tham số là đối tượng \py{State}, vì vậy ta phải cung cấp một tham số khi gọi đến hàm:

\begin{python}
bike_to_wellesley(bikeshare)
\end{python}

Một lần nữa, đối số mà ta cung cấp được gán cho tham số, vì vậy lời gọi hàm này có tác dụng giống như:

\begin{code}
state = bikeshare
state.olin -= 1
state.wellesley += 1
\end{code}

Bây giờ ta có thể tạo bao nhiêu đối tượng \py{State} tùy ý:

\begin{python}
bikeshare1 = State(olin=10, wellesley=2)
bikeshare2 = State(olin=2, wellesley=10)
\end{python}

Và rồi cập nhật chúng một cách độc lập:

\begin{python}
bike_to_wellesley(bikeshare1)
bike_to_wellesley(bikeshare2)
\end{python}

Sự thay đổi về \py{bikeshare1} không ảnh hưởng tới \py{bikeshare2}, và ngược lại. Bởi vậy, ta có thể mô phỏng các hệ thống dùng chung xe khác nhau, hoặc chạy nhiều mô phỏng cho cùng một hệ thống.


\section{Tài liệu chú thích mã lệnh}
\label{documentation}

Một vấn đề khác đối với mã lệnh mà ta viết đến giờ là ở chỗ nó không có {\bf tài liệu chú thích mã lệnh} (documentation).  Tài liệu chú thích là phần văn bản mà ta bổ sung vào chương trình để giúp các lập trình viên khác đọc và hiểu được. Nó không có ảnh hưởng gì đến chương trình khi chạy.

\index{tài liệu chú thích mã lệnh}
\index{documentation}
\index{docstring}
\index{chú thích}

Có hai hình thức tài liệu chú thích, đó là các {\bf docstring} và {\bf lời chú thích}.
Một docstring (= doc [tài liệu] + string [chuỗi]) là một chuỗi đặt trong cặp nháy 3 lần và xuất hiện ở đầu một hàm, như sau:

\begin{python}
def run_simulation(state, p1, p2, num_steps):
    """Mô phỏng theo số bước thời gian cho trước.
    
    state: đối tượng State 
    p1: xác suất một người từ Olin đến Wellesley
    p2: xác suất một người từ Wellesley đến Olin 
    num_steps: số các bước thời gian.
    """
    results = TimeSeries()    
    for i in range(num_steps):
        step(state, p1, p2)
        results[i] = state.olin
        
    plot(results, label='Olin')
\end{python}

Docstring thì tuân theo định dạng quy ước sau:

\begin{itemize}

\item Dòng đầu tiên là một câu đơn mô tả công dụng của hàm.

\item Các dòng tiếp theo giải thích mõi tham số là gì.

\end{itemize}

Một docstring của hàm thì cần bao gồm những thông tin mà người ta cần biết để {\em sử dụng} hàm này; nó không nên bao gồm những chi tiết về cách vận hành của hàm. Chuyện đó đã có những dòng chú thích lo liệu.

Một dòng chú thích là dòng chữ bắt đầu bởi dấu thăng, \py{#}. Nó thường xuất hiện bên trong một hàm để giải thích về điều mà không hiển nhiên rõ ràng khi người đọc xem mã lệnh chương trình.

\index{chú thích}
\index{dấu thăng}

Chẳng hạn, sau đây là một phiên bản của \py{bike_to_olin} với một docstring và một chú thích.

\begin{python}
def bike_to_olin(state):
	"""Chuyển một xe từ Wellesley tới Olin.
	
	state: đối tượng State 
	"""
	# Ta giảm một biến trạng thái và tăng biến còn lại,
	# vì vậy tổng số xe đạp là không đổi.
    state.wellesley -= 1
    state.olin += 1
\end{python}

Đến đây ta có nhiều tài liệu chú thích hơn cả mã lệnh, song điều này không hiếm gặp ở những hàm ngắn.

\section{Số xe đạp âm}
\label{negativebikes}

Những thay đổi mà ta thực hiện đến giờ đã cải thiện chất lượng mã lệnh, nhưng ta chưa hề làm gì để cải thiện chất lượng của mô hình. Bây giờ ta hãy làm điều này.

\index{chất lượng mã lệnh}

Hiện giờ mô phỏng không kiểm tra liệu khi có người đến thì còn xe hay không, bởi vậy mà tại một địa điểm số xe có thể âm. Điều này phi thực tế. Sau đây là một phiên bản cập nhật của hàm \py{bike_to_olin} đẻ khắc phục vấn đề:

\begin{python}
def bike_to_olin(state):
    if state.wellesley == 0:
        return
    state.wellesley -= 1
    state.olin += 1
\end{python}

Dòng đầu tiên kiểm tra xem liệu số xe đạp ở Wellesley liệu có bằng không.  Nếu vậy, nó sẽ dùng một {\bf câu lệnh return} (`trả lại'), khiến cho hàm kết thúc lập tức, mà không chạy các câu lệnh còn lại. Bởi vậy nếu không có xe ở Wellesley, ta sẽ ``trở lại" từ \py{bike_to_olin} mà không làm thay đổi trạng thái.

\index{return - câu lệnh}
\index{câu lệnh!return}

Ta có thể cập nhật \py{bike_to_wellesley} theo cách tương tự.


\section{Các toán tử so sánh}

Phiên bản của hàm \py{bike_to_olin} ở mục trước có dùng toán tử bằng, \py{==}, để so sánh hai giá trị và trả lại \py{True} nếu chúng bằng nhau, và \py{False} nếu không phải.

Rất dẽ nhầm lẫn toán tử bằng với toán tử gán, \py{=}, vốn để gán một giá trị vào một biến. Chẳng hạn, câu lệnh sau tạo ra một biến \py{x}, nếu nó chưa tồn tại, và cho nó giá trị là \py{5}.

\index{cân bằng}
\index{gán - toán tử}
\index{toán tử!gán}

\begin{python}
x = 5
\end{python}

Mặt khác, câu lệnh sau đây kiểm tra xem liệu \py{x} có bằng \py{5} và trả lại \py{True} hoặc \py{False}.  Nó không tạo ra \py{x} hoặc thay đổi giá trị biến này.

\begin{python}
x == 5
\end{python}

Bạn có thể sử dụng toán tử bằng trong một câu lệnh \py{if}, như sau:

\index{if - câu lệnh}
\index{câu lệnh!if}

\begin{python}
if x == 5:
    print('yes, x is 5')
\end{python}

Nếu bạn mắc lỗi và dùng dấu \py{=} trong một câu lệnh \py{if}, như thế này:

\begin{python}
if x = 5:
    print('yes, x is 5')
\end{python}

Đó là một {\bf lỗi cú pháp}, nghĩa là cấu trúc của chương trình không hợp lệ. Python sẽ in ra một dòng thông báo lỗi và chương trình sẽ không chạy.

\index{cú pháp - lỗi}
\index{lỗi!cú pháp}

Toán tử bằng là một trong số các {\bf toán tử so sánh}. Các toán tử khác bao gồm:

\index{so sánh - toán tử}
\index{toán tử!so sánh}

\begin{tabular}{l|c}
{\bf Toán tử} & {\bf Kí hiệu} \\ 
\hline 
Nhỏ hơn & \py{<} \\ 
Lớn hơn & \py{>} \\
Nhỏ hơn hoặc bằng & \py{<=}  \\ 
Lớn hơn hoặc bằng & \py{>=} \\ 
Bằng & \py{==} \\ 
Khác & \py{!=} \\ 
\end{tabular} 


\section{Metric: chỉ số đo lường}
\label{metrics}

Trở lại hệ thống dùng chung xe, đến giờ ta có thể mô phỏng ứng xử của hệ thống. Bởi vì việc có người đến lấy xe là chuyện ngẫu nhiên, nên trạng thái của hệ thống là khác nhau mỗi khi ta chạy một mô phỏng. Các mô hình kiểu này được gọi là {\bf ngẫu nhiên}. Còn các mô hình thực hiện cùng một điều mỗi khi chạy mô phỏng thì được gọi là {\bf tất định}.

\index{ngẫu nhiên}
\index{tất định}

Giả sử ta muốn dùng mô hình để dự đoán xem hệ thống dùng chung xe hoạt động tốt ra sao, hoặc để thiết kế một hệ thống làm việc tốt hơn. Trước hết, ta phải quyết định xem ``tốt ra sao" và ``tốt hơn" là như thế nào.

Từ quan điểm của người dùng, có thể ta muốn biết được xác suất để lấy được xe có sẵn. Từ quan điểm của người chủ sở hữu hệ thống, có thể ta muốn giảm thiểu số khách hàng không tìm được xe khi muốn dùng, hoặc muốn tối đa số xe được dùng đến. Những con số thống kê như vậy sẽ lượng hóa việc hệ thống vận hành tốt ra sao, và được gọi là các {\bf metric}.

\index{metric}

Một ví dụ đơn giản, hãy tính số người dùng không hài lòng. Sau đây là một phiên bản của hàm \py{bike_to_olin} để theo dõi số khách hàng đến một trạm mà không có xe:

\begin{python}
def bike_to_olin(state):
    if state.wellesley == 0:
        state.wellesley_empty += 1
        return
    state.wellesley -= 1
    state.olin += 1
\end{python}

Nếu khách hàng đến trạm Wellesley mà ở đó không có xe, thì hàm \py{bike_to_olin} sẽ cập nhật biến \py{wellesley_empty} vốn dùng để đếm số khách hàng không hài lòng.

Hàm này chỉ có tác dụng nếu ta khởi tạo \py{wellesley_empty} khi ta tạo ra đối tượng \py{State}, như sau:

\begin{python}
bikeshare = State(olin=10, wellesley=2, 
                  olin_empty=0, wellesley_empty=0)
\end{python}

Giả thiết rằng ta cập nhật \py{move_to_wellesley} theo cách tương tự, ta có thể chạy mô phỏng như sau (xem Mục~\ref{documentation}):

\begin{python}
run_simulation(bikeshare, 0.4, 0.2, 60)
\end{python}

Sau đó ta có thể kiểm tra các metric:

\begin{python}
print(bikeshare.olin_empty, bikeshare.wellesley_empty)
\end{python}

Bởi vì mô phỏng mang tính ngẫu nhiên, nên kết quả sẽ khác nhau giữa các lần chạy.

Trước khi đọc tiếp, tôi muốn bạn đọc qua những quyển mã lệnh cho chương này, \py{chap03.ipynb}, và làm các bài tập. Để biết cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


%%%%
\chapter{Quét tham số}
\label{chap04}

Ở chương trước ta đã định nghĩa các metric để lượng hoá hiệu năng của hệ thống dùng chung xe đạp. Ở chương này ta xem các metric đó phụ thuộc vào các tham số hệ thống, chẳng hạn mức độ khách đến trạm, là như thế nào.

Ta cũng sẽ thảo luận một chiến lược phát triển chương trình, gọi là phát triển tăng dần, để giúp bạn viết chương trình nhanh hơn và ít tốn thời gian gỡ lỗi.


\section{Các hàm trả lại giá trị}

Ta đã thấy vài hàm trả lại giá trị; chẳng hạn, khi bạn chạy \py{sqrt}, nó trả lại một số để bạn có thể gán vào biến.

\index{giá trị trả lại}

\begin{python}
t = sqrt(2 * h / a)
\end{python}

Khi bạn chạy \py{State}, nó trả lại một đối tượng \py{State} mới:
 
\begin{python}
bikeshare = State(olin=10, wellesley=2)
\end{python}

Không phải mọi hàm đều có giá trị trả lại. Chẳng hạn, khi bạn chạy \py{step}, nó cập nhật một đối tượng \py{State}, nhưng lại không trả lại giá trị nào.

Để viết một hàm trả lại giá trị, ta có thể dùng một dạng thứ hai của câu lệnh \py{return}, như sau:

\index{return - câu lệnh}
\index{câu lệnh!return}

\begin{python}
def add_five(x):
    return x + 5
\end{python}

\py{add_five} nhận vào một tham số, \py{x}, vốn có thể là bất kì số nào. Nó tính ra \py{x + 5} rồi trả lại kết quả. Như vậy, nếu ta chạy như dưới đây, kết quả sẽ là \py{8}:

\begin{python}
add_five(3)
\end{python}

Tiếp theo là ví dụ hữu ích hơn; đây là một phiên bản của hàm \py{run_simulation} có tạo nên một đối tượng \py{State}, chạy một mô phỏng, và sau đó trả lại kết quả là một đối tượng \py{State}:

\begin{python}
def run_simulation():
    p1 = 0.4
    p2 = 0.2
    num_steps = 60
    
    state = State(olin=10, wellesley=2, 
                    olin_empty=0, wellesley_empty=0)
                    
    for i in range(num_steps):
        step(state, p1, p2)
        
    return state
\end{python}

Nếu ta gọi \py{run_simulation} như sau:

\begin{python}
state = run_simulation()
\end{python}

Nó gán đối tượng \py{State} từ \py{run_simulation} đến \py{state}, vốn chứa các metric mà ta quan tâm:

\begin{python}
print(state.olin_empty, state.wellesley_empty)
\end{python}


\section{Hai loại tham số}

Phiên bản này của hàm \py{run_simulation} luôn khởi động với cùng một điều kiện ban đầu: đó là 10 xe đạp tại Olin và 2 xe tại Wellesley, và các giá trị bằng nhau của \py{p1}, \py{p2}, và \py{num_steps}.  Gộp lại, có 5 giá trị {\bf tham số của mô hình}; đó là những giá trị quy định nên động thái của hệ thống.

\index{tham số!của mô hình}
\index{tham số!của hàm}

Rất dễ nhầm các tham số của mô hình với tham số của một hàm. Chúng có khái niệm liên quan mật thiết với nhau. Thực ra, thường thì các tham số mô hình cũng xuất hiện như các tham số của hàm. Chẳng hạn, ta có thể viết một phiên bản khác, tổng quát hơn cho \py{run_simulation} mà nhận vào \py{p1} và \py{p2} như các tham số hàm:

\begin{python}
def run_simulation(p1, p2, num_steps):
    state = State(olin=10, wellesley=2, 
                    olin_empty=0, wellesley_empty=0)
                    
    for i in range(num_steps):
        step(state, p1, p2)
        
    return state
\end{python}

Bây giờ ta có thể chạy nó với các mức độ người đến khác nhau, như thế này:

\begin{python}
state = run_simulation(0.6, 0.3, 60)
\end{python}

Ở ví dụ này, \py{0.6} được gán cho \py{p1}, \py{0.3} gán cho \py{p2}, và \py{60} gán cho \py{num_steps}.

Bây giờ ta có thể gọi \py{run_simulation} với các tham số khác nhau và xem các metric, như số khách không vui, sẽ phụ thuộc vào tham số ra sao. Song trước khi làm vậy, ta cần một phiên bản mới với vòng lặp \py{for}.

\index{metric}


\section{Vòng lặp và mảng}
\label{array}

Ở Mục~\ref{forloop}, ta đã thấy một vòng lặp như thế này:

\begin{python}
for i in range(4):
    bike_to_wellesley()
\end{python}

\py{range(4)} tạo ra một dãy số từ 0 đến 3. Mỗi khi qua vòng lặp, số tiếp theo trong dãy được gán cho biến vòng lặp, \py{i}.

\index{vòng lặp}
\index{vòng lặp!biến}
\index{biến!vòng lặp}

\py{range} chỉ làm việc với số nguyên; để thu được các giá trị số không nguyên, ta có thể dùng \py{linspace}, vốn được định nghĩa trong thư viện \py{modsim}: 

\begin{python}
p1_array = linspace(0, 1, 5)
\end{python}

Các đối số chỉ định dãy sẽ bắt đầu từ đâu và kêết thúc ở đâu, đồng thời nó có bao nhiêu phần tử. Trong ví dụ này, chuỗi có chứa \py{5} số cách đều nhau, bắt đầu từ \py{0} và  kết thúc ở \py{1}. 

\index{linspace}
\index{NumPy}
\index{mảng}

Kết quả là một {\bf mảng} Numpy, vốn là một kiểu đối tượng mới mà ta chưa từng thấy. Một  mảng là thứ dùng để chứa một dãy số.

Ta có thể dùng mảng trong một vòng lặp  \py{for}  như sau:

\begin{python}
for p1 in p1_array:
    print(p1)
\end{python}

Khi vòng lặp này chạy, nó 

\begin{enumerate}

\item Lấy phần tử đầu trong mảng và  gán nó với \py{p1}.

\item Chạy vòng thân vòng lặp, vốn là để in ra \py{p1}.

\item Lấy phần tử tiếp theo từ mảng và gán nó cho \py{p1}.

\item Chạy vòng thân vòng lặp, vốn là để in ra \py{p1}.

\end{enumerate}

Và cứ như vậy cho đến hết mảng. Kết quả là: 

\begin{result}
0.0
0.25
0.5
0.75
1.0
\end{result}

Cách này sẽ trở nên tiện dụng trong mục kế tiếp đây.


\section{Quét tham số}

Nếu ta biết các giá trị thực của tham số kiểu như \py{p1} và \py{p2}, ta có thể dùng chúng để dự đoán cụ thể, chẳng hạn như bao nhiêu chiếc xe đạp sẽ có ở Olin sau một giờ nữa.

\index{dự đoán}
\index{giải thích}

Nhưng dự đoán không phải là mục tiêu duy nhất; những mô hình như thế này cũng được dùng để giải thích tại sao các hệ thống lại vận hành như vậy và để đánh giá những phương án thiết kế khác. Chẳng hạn, nếu ta quan sát hệ thống và nhận thấy rằng ta thường bị hết xe đạp sau một thời gian nhất định, thì ta có thể dùng mô hình để hình dung ra lý do nào dẫn tới điều đó. Và nếu ta đang cân nhắc bổ sung thêm xe đạp, hay thêm một 
trạm nữa, thì ta có thể đánh giá hiệu ứng của những kịch bản ``nếu-thì" khác nhau.
\index{kịch bản nếu-thì}

Một ví dụ, giả sử ta có đủ số liệu để ước tính rằng \py{p2} bằng khoảng \py{0.2}, nhưng ta không có thông tin gì về \py{p1}.  Ta có thể chạy mô phỏng với một khoảng rộng các trị số của \py{p1} và xem kết quả biến đổi như thế nào. Quá trình này được gọi là {\bf quét} tham số, hiểu theo nghĩa là giá trị của tham số được ``quét" qua một khoảng những giá trị khả dĩ.

\index{quét}
\index{tham số ! quét}

Bây giờ khi đã biết về vòng lặp và mảng, ta có thể dùng chúng như sau:

\begin{python}
p1_array = linspace(0, 1, 11)
p2 = 0.2
num_steps = 60

for p1 in p1_array:
    state = run_simulation(p1, p2, num_steps)
    print(p1, state.olin_empty)
\end{python}

Mỗi lần duyệt qua vòng lặp, ta lại chạy mô phỏng với giá trị khác cho \py{p1} và giữ nguyên giá trị \py{p2} bằng \py{0.2}.  Sau đó, ta in ra \py{p1} số khách hàng không hài lòng tại Olin.

Để lưu kết quả và vẽ đồ thị, ta có thể dùng  một đối tượng \py{SweepSeries}, vốn tương tự như \py{TimeSeries}; nhưng khác ở chỗ là các nhãn trong \py{SweepSeries} là các giá trị tham số thay vì thời gian.

Ta có thể tạo ra một \py{SweepSeries} trống như thế này:

\begin{code}
sweep = SweepSeries()
\end{code}

Và thêm vào các giá trị như thế này:

\begin{python}
for p1 in p1_array:
    state = run_simulation(p1, p2, num_steps)
    sweep[p1] = state.olin_empty
\end{python}

Kết quả là một \py{SweepSeries} trong đó gắn từng giá trị của \py{p1} với số khách hàng không hài lòng tương ứng. Sau đó, ta có thể vẽ đồ thị cho kết quả:

\begin{code}
plot(sweep, label='Olin')
\end{code}




\section{Phát triển tăng dần}

Khi bạn bắt đầu viết chương trình kéo dài hơn một số ít dòng, bạn có thể nhận thấy mình phải dành nhiều thời gian hơn để gỡ lỗi. Càng viết nhiều mã lệnh trước khi bắt đầu gỡ lỗi, bạn càng khó tìm ra trục trặc hơn. 

\index{gỡ lỗi}
\index{phát triển tăng dần}

{\bf Phát triển tăng dần} là một cách lập trình cố gắng giảm thiểu khó khăn khi phải gỡ lỗi. Các bước cơ bản bao gồm:

\begin{enumerate}

\item Luôn bắt đầu từ một chương trình chạy được. Nếu bạn có một ví dụ trích từ cuốn sách, hay một chương trình mà bạn đã viết tương tự với bài toán cần giải quyết, thì hãy bắt đầu từ đó. Nếu không, hãy bắt đầu bằng mã lệnh mà bạn {\em biết} là nó đúng, chẳng hạn như {\tt x=5}.  Chạy chương trình và khẳng định rằng nó cho ra kết quả như mong đợi.

\item Mỗi lần chỉ thực hiện một điều chỉnh nhỏ mà có thể kiểm tra được. Một điều chỉnh ``kiểm tra được'' phải hiển thị nội dung gì đó hoặc có thứ hiệu ứng mà bạn nhận biết được. Tốt nhất là bạn biết rõ kết quả đúng là gì, hoặc có thể kiểm tra kết quả bằng việc thực hiện một phép tính khác. 

\index{điều chỉnh kiểm tra được}

\item Chạy chương trình xem điều chỉnh vừa rồi đã phát huy tác dụng chưa. Nếu được, làm tiếp bước 2. Nếu không, bạn phải gỡ lỗi một chút, nhưng nếu sửa đổi nhỏ thì chắc hạn bạn sẽ chẳng mất nhiều thời gian để tìm ra trục trặc. 

\end{enumerate}

Khi quá trình này phát huy tác dụng, những điều chỉnh của bạn thường sẽ chạy được ngay lần đầu tiên, hoặc dù không chạy được thì bạn phát hiện ngay ra vấn đề. Trên thực tế, có hai vấn đề gắn với phát triển tăng dần:

\begin{itemize}

\item Đôi khi bạn phải viết thêm mã lệnh để tạo nên kết quả đầu ra thấy được mà bạn có thể kiểm tra. Việc viết thêm mã lệnh này được goi là {\bf quây dàn giáo} vì bạn dùng nó để xây dựng chương trình và rồi gỡ bỏ nó đi một khi làm xong. Điều này nghe chừng lãng phí, song thời gian bạn dành ra để quây dàn giáo thì gần như sẽ là thời gian bạn tiết kiệm được để gỡ lỗi.

\index{quây dàn giáo}

\item Khi bạn bắt đầu, có thể sẽ không rõ bằng cách nào để đi từ {\tt x=5} đến chương trình mà bạn cố gắn viết. Bạn sẽ thấy thêm những ví dụ về quá trình này khi đọc sách, và bạn sẽ thạo hơn cùng những kinh nghiệm tích lũy được.

\end{itemize}

Nếu bạn thấy mình đang viết nhiều dòng lệnh trước khi bắt đầu kiểm tra, và bạn phải dành nhiều thời gian để gỡ lỗi, thì hãy thử phát triển theo cách tăng dần.

Trước khi tiếp tục, bạn có thể sẽ muốn đọc tập lệnh cho chương này, \py{chap04.ipynb}, và làm các bài tập. Để biết hướng dẫn tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


%\part{Modeling population growth}

\chapter{Dân số thế giới}
\label{chap05}

Vào năm 1968, Paul Erlich đã công bố bài viết {\it The Population Bomb} (Quả bom dân số), trong đó ông dự tính rằng dân số thế giới sẽ tăng trưởng nhanh trong thập niên 1970, rằng nông nghiệp không thể theo kịp được, và nạn đói hàng loạt xảy ra ở hai thập niên tiếp theo là điều không thể tránh khỏi (xem \url{http://modsimpy.com/popbomb}).  Là người lớn lên qua những thập niên đó, tôi thấy hạnh phúc phải nói rằng những dự đoán đó là sai.
  
\index{Erlich, Paul}
\index{Quả bom dân số}

Nhưng tăng trưởng dân số thế giới vẫn là một chủ đề được quan tâm, và nó là một câu hỏi mở, rằng trái đất cưu mang được dân số là bao nhiêu với điều kiện phải duy trì và cải thiện chất lượng cuộc sống.

\index{thế giới - dân số}
\index{dân số}

Ở chương này và chương tiếp theo, chúng ta dùng các công cụ từ các chương trước để giải thích sự tăng trưởng dân số thế giới từ năm 1950 và dự đoán cho 50--100 năm tới.

\index{dự đoán}

Để biết thông tin cơ bản về tăng trưởng dân số, hãy xem video này từ Bảo tàng lịch sử quốc gia Mỹ \url{http://modsimpy.com/human}.

\index{Bảo tàng lịch sử quốc gia Mỹ}


\section{Dữ liệu dân số thế giới}
\label{worldpopdata}

Bài viết trên trang Wikipedia về dân số thế giới bao gồm các bảng chứa con số ước tính số dân trên thế giới từ thời tiền sử đến giờ, cũng như dự báo trong tương lai  (\url{http://modsimpy.com/worldpop}).

\index{Wikipedia}
\index{Pandas}

Để đọc số liệu này, ta sẽ dùng Pandas, vốn cung cấp cá hàm giúp thao tác với số liệu. Hàm mà ta sẽ dùng là \py{read_html}, vốn để đọc một trang web và trích xuất thông tin từ bất kì bảng nào trong trang web đó. Trước khi dùng được hàm này, ta phải nhập nó. Bạn đã thấy câu lệnh import này rồi:

\index{\py{read_html}}
\index{import (câu lệnh)}
\index{câu lệnh!import}

\begin{python}
from modsim import *
\end{python}

vốn để nhập vào tất cả các hàm từ thư viện \py{modsim}. Để nhập \py{read_html}, câu lệnh mà ta cần viết là:

\begin{python}
from pandas import read_html
\end{python}

Bây giờ ta có thể dùng nó như sau:

\begin{python}
filename = 'data/World_population_estimates.html'
tables = read_html(filename,
                   header=0, 
                   index_col=0,
                   decimal='M')
\end{python}

Các tham biến gồm có:
\index{argument}

\begin{itemize}

\item \py{filename}: Tên của file (bao gồm cả thư mục chứa nó) dưới dạng chuỗi. Tham biến cũng có thể là một chuỗi URL bắt đầu bằng \py{http}.

\item \py{header}: Chỉ ra hàng nào của từng bảng được coi là dòng tiêu đề, tức là dòng chứa một tập hợp các nhãn định danh cho các cột. Trong trường hợp này nó là dòng đầu tiên (đánh số 0).

\item \py{index_col}: Chỉ ra cột nào trong từng bảng được coi là cột chỉ số (``{\bf index}''), nghĩa là tập hợp các nhãn dùng để xác định các hàng. Trong trường hợp này đó là cột thứ nhất, vốn chứa các năm.

\item \py{decimal}: Thường thì đây là tham biến dùng để chỉ định kí tự nào sẽ dùng làm ``dấu phẩy'' để phân tác phần thập phân của con số, vì mỗi nước lại quy định riêng (dấu ``chấm'' hoặc ``phẩy''). Ở đây tôi sẽ lạm dụng tính năng này để đặt \py{M} làm ``dấu phẩy'', vì M là kí hiệu cho ``triệu người''.

\end{itemize}

Kết quả, vốn được gán vào \py{tables}, là một dãy có chứa một \py{DataFrame} cho từng bảng. Một \py{DataFrame} là một đối tượng, được Pandas định nghĩa, để biểu thị cho số liệu dạng bảng.

\index{DataFrame}
\index{dãy}

Để chọn một \py{DataFrame} từ \py{tables}, ta có thể dùng toán tử ngoặc vuông như sau:

\begin{python}
table2 = tables[2]
\end{python}

Dòng này thực hiện chọn bảng thứ ba (đánh số 2), vốn có chứa con số ước tính dân cư từ năm 1950 đến 2016.

\index{dấu ngoặc vuông (toán tử)}
\index{toán tử!dấu ngoặc vuông}

Bây giờ ta có thể hiển thị vài dòng đầu tiên như sau:

\begin{python}
table2.head()
\end{python}

Các nhãn hiệu cột đều là những chuỗi dài, vì vậy thật khó thao tác với chúng. Ta có thể thay thế chúng bằng những chuỗi ngắn hơn như sau:

\index{chuỗi}
\index{cột}

\begin{python}
table2.columns = ['census', 'prb', 'un', 'maddison', 
                  'hyde', 'tanton', 'biraben', 'mj', 
                  'thomlinson', 'durand', 'clark']
\end{python}

Bây giờ ta có thể lựa chọn một cột từ \py{DataFrame} bằng cách dùng toán tử dấu chấm, giống như lựa chọn một biến trạng thái từ một đối tượng \py{State}:

\index{dấu chấm (toán tử)}
\index{toán tử!dấu chấm}

\begin{python}
census = table2.census / 1e9
un = table2.un / 1e9
\end{python}

Các dòng này thực hiện lựa chọn các con số ước tính bởi Ban Kinh tế Xã hội Liên hợp quốc (United Nations Department of Economic and Social Affairs, UN DESA) và Cục Thống kê Dân số Hoa Kỳ (the United States Census Bureau).

\index{Liên hợp quốc}
\index{Cục Thống kê Dân số Hoa Kỳ}

Mỗi kế quả là một dãy (\py{Series}) trong Pandas, dãy cũng giống như một \py{DataFrame} nhưng chỉ có một cột.

\index{dãy (Series)}

Số một tỉ viết như là \py{1e9} thì ngắn hơn và cũng đỡ bị mắc lỗi hơn là viết \py{1000000000}.  Khi ta chia một \py{Series} cho một số, nó đem chia tất cả phần tử trong \py{Series} cho số đó. Từ đây trở đi, ta sẽ biểu diễn các ước tính dân số theo tỉ dân.


\section{Vẽ đồ thị}

Bây giờ ta có thể vẽ đồ thị các con số ước tính như sau:

\index{plot}

\begin{python}
plot(census, ':', label='US Census')
plot(un, '--', label='UN DESA')
\end{python}


Hai dòng tiếp theo là để vẽ các đối tượng \py{Series}.  Các {\bf chuỗi định dạng} (format string) gồm \py{':'} và \py{'--'} là để chỉ các đường chấm và đường nét đứt. Để biết thêm về những chuỗi định dạng trong Pyplot, hãy xem \url{http://modsimpy.com/plot}.

\index{chuỗi định dạng}
\index{Pyplot}

Tham biến \py{label} cung cấp chuỗi mà ta muốn nó xuất hiện trên phần chú giải biểu đồ.

\index{label}
\index{chú giải}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig01.pdf}}
\caption{Ước tính dân số thế giới, 1950--2016.}
\label{chap03-fig01}
\end{figure}

Hình~\ref{chap03-fig01} cho thấy kết quả. Hai đường gần như trùng khớip nhau; tại gần như mọi thời điểm, khác biệt giữa hai trị số ước tính này chỉ không đến 1\%.


\section{Mô hình tăng trưởng hằng số}

Giả dụ ta muốn dự tính mức tăng trưởng dân số thế giới trong 50 hay 100 năm tới. Ta có thể làm điều đó bằng cách phát triển một mô hình để miêu tả dân số sẽ tăng thế nào, khớp mô hình này với các số liệu đã có tới hiện nay, rồi sử dụng mô hình để ước tính.

\index{tăng trưởng hằng số}

Trong vài mục tiếp theo, tôi sẽ biểu diễn quá trình này bắt đầu bằng những mô hình đơn giản và rồi dần cải thiện chúng.

\index{mô hình hoá lặp}

Mặc dù vẫn tồn tại độ cong trên đường đồ thị biểu diễn các ước tính nhưng trông như sự tăng trưởng dân số thế giới đã gần như tuyến tính từ khoảng năm 1960. Do vậy, ta sẽ bắt đầu bằng một mô hình có mức tăng trưởng là hằng số.

Để khớp mô hình này với số liệu, ta sẽ tính mức tăng trưởng trung bình hằng năm từ 1950 đến 2016. Vì các số liệu UN và điều tra là gần như nhau, nên ta sẽ sử dụng số liệu điều tra.

Ta có thể lựa chọn một giá trị từ một dãy (\py{Series}) bằng cách dùng toán tử ngoặc vuông:
\index{ngoặc vuông (toán tử)}
\index{toán tử!ngoặc vuông}

\begin{python}
census[1950]
\end{python}

Vậy là ta có thể thu được mức tăng trưởng tổng cộng trong thời đoạn như sau:

\begin{python}
total_growth = census[2016] - census[1950]
\end{python}

Các con số đặt trong cặp ngoặc vuông được gọi là các {\bf nhãn}, vì chúng như các nhãn hiệu gắn với các hàng của dãy (\py{Series}) (đừng nhầm với nhãn ở mục trước; nhãn đó là để gắn cho các đường trong một biểu đồ).

\index{nhãn}

Ở ví dụ này, các nhãn 2016 và 1950 là một phần của số liệu, bởi vậy tốt nhất là ta không viết nó vào chương trình. Việc áp đặt các giá trị như thế vào chương trình được gọi là {\bf viết mã cứng}; và được coi là quy tắc xấu vì nếu số liệu có thay đổi trong tương lai thì ta sẽ phải thay đổi chương trình (xem  \url{http://modsimpy.com/hardcode}).

\index{viết mã cứng}

Tốt hơn là ta lấy các nhãn đầu tiên và nhãn cuối cùng từ  \py{Series} như sau:

\begin{python}
t_0 = get_first_label(census)
t_end = get_last_label(census)
elapsed_time = t_end - t_0
\end{python}

\py{get_first_label} và \py{get_last_label} được định nghĩa trong \py{modsim.py}. Chắc bạn cũng đoán được, chúng có tác dụng lựa chọn các nhãn đầu và cuối từ \py{census}.
Hiệu số giữa chúng là khoảng thời gian.

Thư viện \py{modsim} cũng định nghĩa \py{get_first_value} và \py{get_last_value}, mà ta có thể dùng để tính \py{total_growth}:

\begin{python}
p_0 = get_first_value(census)
p_end = get_last_value(census)
total_growth = p_end - p_0
\end{python}

Sau cùng, ta có thể tính mức tăng trưởng trung bình hằng năm.

\begin{python}
annual_growth = total_growth / elapsed_time
\end{python}

Bước tiếp theo là dùng ước tính này để mô phỏng mức tăng trưởng dân số từ năm 1950.


\section{Mô phỏng}

Mô phỏng của ta sẽ bắt đầu với dân số khảo sát được vào năm 1950, \py{p0}, và bổ sung thêm \py{annual_growth} hằng năm. Để lưu kết quả, ta sẽ dùng một đối tượng \py{TimeSeries}:

\index{TimeSeries}

\begin{python}
results = TimeSeries()
\end{python}

Ta có thể đặt giá trị thứ nhất trong \py{TimeSeries} mới bằng cách sao chép giá trị thứ nhất từ \py{census}:

\begin{python}
results[t_0] = census[p_0]
\end{python}

Sau đó ta đặt phần còn lại của các giá trị bằng cách mô phỏng mức tăng trưởng hằng năm:

\begin{python}
for t in linrange(t_0, t_end):
    results[t+1] = results[t] + annual_growth
\end{python}

\py{linrange} được định nghĩa trong thư viện \py{modsim}. Ở ví dụ này, nó trả lại một mảng NumPy gồm các số nguyên từ \py{t_0} đến \py{t_end}, bao gồm số đầu nhưng loại trừ số cuối.

\index{linrange}
\index{NumPy}
\index{array}

Mỗi lần chạy qua vòng lặp, biến lặp \py{t} lấy giá trị tiếp theo từ mảng. Bên trong vòng lặp, ta tính dân số cho từng năm bằng cách đem dân số năm trước cộng với \py{annual_growth}.  Lần cuối cùng qua vòng lặp, giá trị của \py{t} là 2015, bởi vậy nhãn cuối cùng của \py{results} là 2016, chính là giá trị ta cần.

\index{vòng lặp}
\index{biến vòng lặp}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig02.pdf}}
\caption{Ước tính dân số thế giới, 1950--2016, và một mô hình tăng trưởng hằng số.}
\label{chap03-fig02}
\end{figure}

Hình~\ref{chap03-fig02} cho thấy kết quả. Mô hình không khớp với số liệu lắm trong giai đoạn từ 1950 đến 1990, nhưng sau đó thì khá tốt. Dù vậy, vẫn còn những vấn đề sau:

\begin{itemize}

\item Không có cơ chế hiển nhiên nào khiến cho tăng trưởng dân cư phải là hằng số từ năm này qua năm khác. Sự thay đổi dân số được quyết định bởi tỉ lệ người chết và tỉ lệ người sinh đẻ, bởi vậy ta sẽ lường được các tỉ lệ này phụ thuộc vào số dân hiện tại.

\item Theo mô hình này, ta lường được rằng mô hình sẽ tiếp tục tăng trưởng với cùng tốc độ mãi mãi, mà điều này dường như không hợp lý.

\end{itemize}

Chúng ta sẽ thử vài mô hình khác trong vài mục tiếp theo, song trước hết ta hãy dọn dẹp lại mã lệnh đã.

Trước khi tiếp tục, bạn có thể muốn đọc tập mã lệnh chương này, \py{chap05.ipynb}, và làm bài tập. Để biết hướng dẫn tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Mô hình hoá tăng trưởng}
\label{chap06}
Ở chương trước ta đã mô phỏng một mô hình dân số thế giới với mức tăng trưởng hằng số. Trong chương này ta sẽ xem rằng liệu có thể lập một mô hình tốt hơn với mức tăng trưởng tỉ lệ thuận với dân số.

Nhưng trước hết, ta có thể cải thiện mã lệnh ở chương trước bằng cách gói nói vào một hàm và sử dụng các đối tượng \py{System}.

\section{Các đối tượng System}
\label{nowwithsystem}

Giống như một đối tượng \py{State}, một đối tượng \py{System} có chứa các biến cùng giá trị của chúng. Khác biệt là ở chỗ:

\begin{itemize}

\item Các đối tượng \py{State} chứa những biến trạng thái, vốn biểu diễn trạng thái của hệ thống, được cập nhật trong quá trình mô phỏng.

\item Các đối tượng \py{System} chứa các {\bf biến hệ thống}, vốn biểu diễn cho các tham số của hệ thống và thường không được cập nhật trong quá trình mô phỏng.

\end{itemize}  

Chẳng hạn, trong mô hình dùng chung xe đạp, các biến trạng thái bao gồm số xem đạp tại từng địa điểm, vốn đợc cập nhật mỗi khi người dùng di chuyển một xe. Các biến hệ thống bao gồm số địa điểm, tổng số xe và lưu lượng xe tới từng địa điểm.

Trong mô hình dân số, biến trạng thái duy nhất là số dân. Các biến hệ thống bao gồm tốc độ tăng trưởng hằng năm, thời điểm đầu và dân cư ban đầu, cùng thời điểm cuối. 

Chẳng hạn ta có các biến sau, như đã tính ở chương trước (coi rằng \py{census} là một đối tượng \py{Series}):

\begin{python}
t_0 = get_first_label(census)
t_end = get_last_label(census)
elapsed_time = t_end - t_0

p_0 = get_first_value(census)
p_end = get_last_value(census)
total_growth = p_end - p_0

annual_growth = total_growth / elapsed_time
\end{python}

Trong các biến trên, một vài là tham số mà ta cần để mô phỏng hệ thống; số còn lại chỉ là giá trị tạm thời có thể bỏ đi được. Ta có thể đặt các tham số 
mình cần vào một đối tượng \py{System} như sau:

\index{System object}

\begin{python}
system = System(t_0=t_0, 
                t_end=t_end,
                p_0=p_0,
                annual_growth=annual_growth)
\end{python}

\py{t0} và \py{t_end} là năm đầu và năm cuối; \py{p_0} là dân số ban đầu, còn \py{annual_growth} là tốc độ tăng trưởng ước tính hằng năm.

Tiếp theo ta sẽ gói mã lệnh từ chương trước vào trong một hàm:

\begin{python}
def run_simulation1(system):
    results = TimeSeries()
    results[system.t_0] = system.p_0
    
    for t in linrange(system.t_0, system.t_end):
        results[t+1] = results[t] + system.annual_growth
    
    return results
\end{python}

Khi \py{run_simulation1} chạy, chương trình sẽ lưu kết quả vào một \py{TimeSeries} và trả lại nó.
 
\index{TimeSeries (đối tượng)}

Hàm sau sẽ vẽ đồ thị kết quả cùng với các ước lượng \py{census} và \py{un}:

\begin{python}
def plot_results(census, un, timeseries, title):
    plot(census, ':', label='US Census')
    plot(un, '--', label='UN DESA')
    plot(timeseries, color='gray', label='model')
    
    decorate(xlabel='Year', 
             ylabel='World population (billion)',
             title=title)
\end{python}

\index{vẽ đồ thị}
\index{trang trí}

Đối số \py{color} quy định màu của nét vẽ. Để biết chi tiết về quy định màu trong Pyplot, hãy xem \url{http://modsimpy.com/color}.

\index{Pyplot}
\index{màu}

Sau cùng, ta có thể chạy mô phỏng như sau:

\begin{python}
results = run_simulation1(system)
plot_results(census, un, results, 'Constant growth model')
\end{python}

Kết quả giống hệt như Hình~\ref{chap03-fig02}.

Dường như không dễ thấy rằng việc dùng các hàm và đối tượng \py{System} đã cải thiện được gì đáng kể, và với một mô hình đơn giản mà ta chỉ chạy một lần thì chắc là không. Nhưng khi ta làm việc với những mô hình phức tạp hơn, và khi ta chạy nhiều mô phỏng với các tham số khác nhau thì ta sẽ thấy rằng việc tổ chức mã lệnh sẽ tạo nên khác biệt lớn.

Bây giờ, hãy xem liệu ta có thể cải thiện mô hình không nhé.


\section{Mô hình tăng trưởng tỉ lệ thuận}

Vấn đề lớn nhất đối với mô hình tăng trưởng hằng số là ở chỗ nó không có ý nghĩa gì cả. Thật khó tưởng tượng bằng cách nào mà mọi người trên toàn thế giới có thể kiềm chế để giữ cho dân số có mức tăng trưởng không đổi năm này qua năm khác.

\index{tăng trưởng dân số}

Mặt khác, nếu một phần của dân số chết đi hằng năm, và một phần khác sinh đẻ, thì ta có thể tính được mức thay đổi ròng của dân số như sau:

\begin{python}
def run_simulation2(system):
    results = TimeSeries()
    results[system.t_0] = system.p_0
    
    for t in linrange(system.t_0, system.t_end):
        births = system.birth_rate * results[t]
        deaths = system.death_rate * results[t]
        results[t+1] = results[t] + births - deaths
        
    return results
\end{python}

Bây giờ ta có thể chọn các giá trị cho \py{birth_rate} và \py{death_rate} để cho khớp với số liệu nhất. Không cần phải cố gắng nhiều, tôi đã chọn:

\begin{python}
system.death_rate = 0.01
system.birth_rate = 0.027
\end{python}

Sau đó tôi chạy mô phỏng và vẽ đồ thị kết quả:

\begin{python}
results = run_simulation2(system)
plot_results(census, un, results, 'Proportional model')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig03.pdf}}
\caption{Ước tính dân số thế giới, 1950--2016, và một mô hình tỉ lệ thuận.}
\label{chap03-fig03}
\end{figure}

Hình~\ref{chap03-fig03} thể hiện kết quả. Mô hình tỉ lệ thuận khớp số liệu khá tốt từ năm 1950 đến 1965, nhưng sau đó thì không tốt lắm. Xét tổng thể, {\bf chất lượng khớp} không tốt bằng mô hình tăng trưởng hằng số. Điều này thật ngạc nhiên, vì dường như mô hình tỉ lệ thuận thì đúng thực tế hơn.

Ở chương tiếp theo ta sẽ cố thử một lần nữa để tìm ra mô hình vừa hợp lý lại vừa khớp với số liệu. Song trước hết, tôi muốn cải thiện mã lệnh ở đôi chỗ đã.


\section{Chỉnh sửa hàm cập nhật}

\py{run_simulation1} và \py{run_simulation2} gần giống hệt chỉ trừ phần thân của vòng lặp \py{for}, nơi ta tính dân số cho năm tới. 

\index{cập nhật (hàm)}
\index{hàm!cập nhật}

Thay vì lặp lại mã lệnh giống hệt, ta có thể phân tách các thứ thay đổi riêng ra các thứ không thay đổi. Đầu tiên, tôi sẽ kéo đoạn mã lệnh cập nhật khỏi \py{run_simulation2} và biến nó thành một hàm:

\begin{python}
def update_func1(pop, t, system):
    births = system.birth_rate * pop
    deaths = system.death_rate * pop
    return pop + births - deaths
\end{python}

Hàm này nhận vào các đối số là dân số hiện tại, năm hiện tại, và một đối tượng  \py{System}; nó trả lại dân số tính toán cho năm tiếp theo.

Hàm cập nhật này không dùng \py{t}, bởi vậy ta có thể bỏ nó đi. Nhưng ta sẽ thấy rằng các hàm khác dùng đến nó, vì vậy sẽ tiện hơn nếu quy định các hàm nhận vào những tham số giống nhau, bất kể tham số đó được dùng đến không.

Bây giờ ta có thể viết một hàm có thể chạy bất kì mô hình nào:

\begin{python}
def run_simulation(system, update_func):
    results = TimeSeries()
    results[system.t_0] = system.p_0
    
    for t in linrange(system.t_0, system.t_end):
        results[t+1] = update_func(results[t], t, system)
        
    return results
\end{python}

Hàm này biểu diễn một đặc điểm mà ta chưa thấy trước đây: nó nhận vào một hàm như là một ham số! Khi ta gọi \py{run_simulation}, tham số thứ hai là một hàm, như \py{update_func1}, để tính dân số cho năm tới. 

\index{hàm!như tham số}

Sau đây là cách mà ta gọi nó:

\begin{python}
results = run_simulation(system, update_func1)
\end{python}

Truyền một hàm vào như một đối số cũng giống như truyền bất kì giá trị nào khác. Đối số, vốn là \py{update_func1} ở ví dụ này, được gán vào tham số, vốn có tên \py{update_func}.  Trong \py{run_simulation}, chúng ta có thể chạy  \py{update_func} cũng như bất kì hàm nào khác.

Vòng lặp trong \py{run_simulation} gọi \py{update_func1} một lần cho từng năm giữa \py{t_0} và \py{t_end-1}.  Kết quả cũng giống như Hình~\ref{chap03-fig03}.


\section{Kết hợp sinh trưởng và chết}

Khi đi sâu vào việc, ta cũng có thể đơn giản hoá mã lệnh bằng cách kết hợp sự  sinh trưởng và chết đi, để tính tốc độ tăng trưởng ròng. Thay vì hai tham số, \py{birth_rate} và \py{death_rate}, ta có thể viết hàm cập nhật dưới dạng một tham số duy nhất để biểu diễn hiệu số:

\begin{python}
system.alpha = system.birth_rate - system.death_rate
\end{python}

Tên của tham số này, \py{alpha}, là tên thông dụng đặt cho tốc độ tăng trưởng tỉ lệ thuận.

Sau đây là một phiên bản chỉnh sửa của \py{update_func1}:

\begin{python}
def update_func2(pop, t, system):
    net_growth = system.alpha  * pop
    return pop + net_growth
\end{python}

Và sau đây là cách mà ta chạy nó:

\begin{python}
results = run_simulation(system, update_func2)
\end{python}

Một lần nữa, kết quả cũng giống như Hình~\ref{chap03-fig03}.

Trước khi tiếp tục, bạn có thể muốn đọc tập notebook cho chương này, \py{chap06.ipynb}, và làm các bài tập. Để biết hướng dẫn việc tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.



\chapter{Tăng trưởng bậc hai}
\label{chap07}

Ở chương trước, ta đã phát triển một mô hình dân số trong đó mức tăng trưởng ròng thì tỉ lệ thuận với số dân hiện tại. Mô hình này dường như thực tế hơn mô hình tăng trưởng hằng số, nhưng nó cũng không khớp với số liệu.

Có một vài chỗ mà ta có thể thử cải thiện mô hình này:

\begin{itemize}

\item Có lẽ tốc độ tăng trưởng ròng thay đổi theo thời gian.

\item Có lẽ tốc độ tăng trưởng ròng phụ thuộc vào số dân hiện tại, nhưng mối quan hệ là hàm bậc hai chứ không phải tuyến tính.

\end{itemize}

Trong quyển tập lệnh cho chương này, bạn sẽ có cơ hội thử lựa chọn thứ nhất. Còn trong chương này ta sẽ khám phá lựa chọn thứ hai.


\section{Tăng trưởng bậc hai}
\label{quadratic}

Sẽ có ý nghĩa nếu cho rằng mức tăng trưởng ròng phụ thuộc vào dân số hiện tại, nhưng có thể đó không phải là liên hệ tuyến tính như sau:

\begin{python}
    net_growth = system.alpha * pop
\end{python}

Có lẽ đó là mối quan hệ bậc hai như sau:

\index{tăng trưởng bậc hai}

\begin{python}
    net_growth = system.alpha * pop + system.beta * pop**2
\end{python}

Ta có thể kiểm tra giả thiết đó với một hàm cập nhật mới:

\begin{python}
def update_func_quad(pop, t, system):
    net_growth = system.alpha * pop + system.beta * pop**2
    return pop + net_growth
\end{python}

Bây giờ ta có hai tham số. Tôi chọn các giá trị sau bằng cách thử sai; sau này ta sẽ xem những cách làm tốt hơn.

\index{tham số}

\begin{python}
system.alpha = 0.025
system.beta = -0.0018
\end{python}

Và sau đây là cách ta chạy nó:

\begin{python}
results = run_simulation(system, update_func_quad)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig04.pdf}}
\caption{Ước tính dân số thế giới, 1950--2016, và một mô hình bậc hai.}
\label{chap03-fig04}
\end{figure}

Hình~\ref{chap03-fig04} cho thấy kết quả. Mô hình khớp tốt với các số liệu trong toàn bộ khoảng, chỉ chênh lệnh một chút vào những năm thập kỉ 1960.

Dĩ nhiên, ta lường trước rằng mô hình bậc hai sẽ khớp tốt hơn là các mô hình hằng số và mô hình tỉ lệ thuận vì nó có hai tham số mà ta có thể chọn, trong khi các mô hình kia chỉ có một. Nói chung, khi càng có nhiều tham số để thử nghiệm thì bạn càng trông đợi là mô hình sẽ khớp tốt hơn.

\index{mức độ khớp}
\index{số liệu}
\index{khớp số liệu}

Nhưng khớp số liệu không chỉ là lý do duy nhất để nghĩ rằng mô hình bậc hai có thể là lựa chọn tốt. Nó cũng hợp lý hơn nữa; theo nghĩa là có một lý do hợp lệ để lường được rằng mối liên hệ giữa mức tăng trưởng và dân số có được dạng đó.

Để hiểu được điều này, ta sẽ nhìn vào mức tăng trưởng ròng như một hàm phụ thuộc vào dân số. Sau đây là cách mà ta tính toán nó:

\begin{python}
pop_array = linspace(0, 15, 100)
net_growth_array = (system.alpha * pop_array + 
                    system.beta * pop_array**2)
\end{python}

\py{pop_array} có chứa 100 trị số được giãn cách đều từ 0 đến 15.  \py{net_growth_array} chứa 100 giá trị tương ứng của mức tăng trưởng ròng. Ta có thể vẽ đồ thị kết quả như sau:

\begin{python}
plot(pop_array, net_growth_array)
\end{python}

Trước đây ta đã dùng \py{plot} với các đối tượng \py{Series}.  Ở ví dụ này, ta dùng hai mảng NumPy, tương ứng với các trục x và y.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap03-fig05.pdf}}
\caption{Mức tăng trưởng ròng như một hàm số theo số dân.}
\label{chap03-fig05}
\end{figure}

Hình~\ref{chap03-fig05} cho thấy kết quả. Lưu ý rằng trục x bây giờ không phải thời gian, như với các hình trước, mà là dân số. Ta có thể chia đường cong này thành bốn miền với xu thế riêng:
\index{miền}

\begin{itemize}

\item Khi dân số dưới 3-4 tỉ người, mức tăng trưởng ròng tỉ lệ thuận với dân số, như ở mô hình tỉ lệ thuận. Ở miền này, dân số chỉ tăng chậm vì số dân còn ít.

\item Từ 4 đến 10 tỉ, dân số tăng trưởng nhanh vì có nhiều người.

\item Trên 10 tỉ, dân số tăng chậm hơn; xu thế này mô hình hóa cho hiệu ứng của hạn chế tài nguyên khiến sinh suất giảm hoặc tử suất tăng lên.

\item Trên 14 tỉ, các nguồn tài nguyên bị hạn chế đến nỗi tử suất vượt sinh suất và mức tăng trưởng ròng trở nên âm.

\end{itemize}

Ngay dưới mức 14 tỉ, có một điểm mà tại đó mức tăng trưởng ròng bằng 0, nghĩa là dân số không thay đổi. Tại điểm này, sinh suất và tử suất bằng nhau, vì vậy dân số ở trạng thái {\bf cân bằng}.

\index{cân bằng}


\section{Cân bằng}
\label{equilibrium}

Để tìm điểm cân bằng, ta có thể tìm các nghiệm của phương trình sau:
%
\[ \Delta p = \alpha p + \beta p^2 \]
%
trong đó $\Delta p$ là mức tăng trưởng ròng của dân số, $p$ là đân số hiện tại, còn $\alpha$ và $\beta$ là các tham số của mô hình. Ta có thể viết lại vế phải như sau:
%
\[ \Delta p = p (\alpha + \beta p) \]
%
vốn bằng $0$ khi $p=0$ hay $p=-\alpha/\beta$.  Ở ví dụ này, $\alpha = 0.025$ và $\beta = -0.0018$, bởi vậy $-\alpha/\beta = 13.9$.

Đối với mô hình hóa dân số, mô hình bậc hai được viết lại theo cách tiện lợi như sau:
%
\[ \Delta p = r p (1 - p / K) \]
%
Cũng vẫn là mô hình đó, chỉ là một cách khác để {\bf tham số hóa} nó. Cho trước $\alpha$ và $\beta$, ta có thể tính $r=\alpha$ và $K=-\alpha/\beta$.

\index{tham số hóa}

Trong phiên bản này, ta dễ diễn giải các tham số hơn: $r$ là sinh suất tối đa, quan sát được khi $p$ nhỏ, còn $K$ là điểm cân bằng. $K$ cũng được gọi là {\bf sức chứa}, vì nó thể hiện dân số lớn nhất mà môi trường có thể dung nạp được.

\index{sức chứa}

Ở chương kế tiếp, ta sẽ dùng các mô hình vừa xây dựng để tạo ra kết quả dự đoán.

\section{Sự hoạt động bất thường}

Khi người học làm quen với các hàm, có vài điều khiến họ thường nhầm lẫn. Trong mục này, tôi sẽ trình bày và giải thích một số vấn đề thường gặp.

Lấy ví dụ, chẳng hạn bạn muốn một hàm nhận tham biến là một đối tượng \py{System} với các biến \py{alpha} và \py{beta}, rồi tính sức chứa, \py{-alpha/beta}.  Sau đây là một cách làm hay: 

\begin{python}
def carrying_capacity(system):
    K = -system.alpha / system.beta
    return K
    
sys1 = System(alpha=0.025, beta=-0.0018)
pop = carrying_capacity(sys1)
print(pop)
\end{python}

Bây giờ hãy xem tất cả những cách làm có khả năng sai sót.

Bất thường \#1: Không dùng tham biết. Ở phiên bản sau đây, hàm không nhận vào tham biến nào cả; khi \py{sys1} xuất hiện trong hàm, nó chỉ đến đối tượng mà ta tạo nên bên ngoài hàm.

\begin{python}
def carrying_capacity():
    K = -sys1.alpha / sys1.beta
    return K
    
sys1 = System(alpha=0.025, beta=-0.0018)
pop = carrying_capacity()
print(pop)
\end{python}

Phiên bản này thực ra vẫn hoạt động được, nhưng không linh hoạt như đáng ra nó có thể. Nếu có vài đối tượng \py{System} khác nhau thì hàm này chỉ hoạt động với một trong số chúng, và chỉ hoạt động khi đối tượng đó đặc đặt tên là \py{sys1}.

Bất thường \#2: ``Hành hạ'' các tham số. Khi người học mới làm quen với các tham số, họ thường viết hàm kiểu như sau:

\begin{python}
# SAI
def carrying_capacity(system):
    system = System(alpha=0.025, beta=-0.0018)
    K = -system.alpha / system.beta
    return K
    
sys1 = System(alpha=0.03, beta=-0.002)
pop = carrying_capacity(sys1)
print(pop)
\end{python}

Ở ví dụ này, ta có một đối tượng \py{System} mang tên \py{sys1} được truyền vào làm đối số cho \py{carrying_capacity}. Nhưng khi hàm này chạy thì nó lờ ngay đối số đi và lập tức thay thế bằng một đối tượng \py{System} mới. Hệ quả là hàm này luôn trả về cùng một giá trị, bất kể đối số nào được truyền đến.

Khi bạn viết một hàm, nói chung bạn sẽ không biết các giá trị tham số sẽ là gì. Nhiệm vụ của bạn là viết một hàm hoạt động được với mọi giá trị hợp lệ. Nếu bạn đen gán các giá trị cụ thể vào cho tham số thì bạn đã phá vỡ hết mục đích của hàm rồi.

Bất thường \#3: Không trả về giá trị nào. Sau đây là phiên bản tính giá trị của \py{K} mà không trả lại giá trị này.

\begin{python}
# SAI
def carrying_capacity(system):
    K = -system.alpha / system.beta
    
sys1 = System(alpha=0.025, beta=-0.0018)
pop = carrying_capacity(sys1)
print(pop)
\end{python}

Một hàm mà không có câu lệnh return sẽ luôn trả lại một giá trị đặc biệt gọi là \py{None}, bởi vậy trong ví dụ này giá trị của \py{pop} là \py{None}. Nếu bạn đang gỡ lỗi một chương trình và phát hiện thấy giá trị của một biến là \py{None} trong khi lẽ ra không phải vậy, thì có thể nguyên nhân vì một hàm không có câu lệnh return.
\index{None}

Bất thường \#4: Phớt lờ giá trị được trả lại. Sau cùng, đây là một phiên bản mà hàm đã viết đúng rồi, nhưng cách dùng nó thì sai.

\begin{python}
# SAI
def carrying_capacity(system):
    K = -system.alpha / system.beta
    return K
    
sys1 = System(alpha=0.025, beta=-0.0018)
carrying_capacity(sys1)
print(K)
\end{python}

Ở ví dụ này, \py{carrying_capacity} chạy và trả kết quả \py{K}, nhưng giá trị đó bị đánh rơi mất.

Khi bạn chạy một hàm mà hàm này trả giá trị, bạn cần phải làm gì đó với kết quả. Thường thì bạn sẽ gán nó vào một biến, như ở các ví dụ trước, hoặc bạn cũng có thể dùng nó như một bộ phận trong một biểu thức. Chẳng hạn, bạn có thể triệt tiêu biến tạm thời \py{pop} như sau:

\begin{python}
print(carrying_capacity(sys1))
\end{python}

Hoặc nếu bạn có nhiều hệ thống thì bạn có thể tính tổng sức chứa như sau:

\begin{python}
total = carrying_capacity(sys1) + carrying_capacity(sys2)
\end{python}

Trước khi tiếp tục, có thể bạn sẽ muốn đọc tập mã lệnh cho chương này, \py{chap07.ipynb}, và làm các bài tập. Để biết những hướng dẫn tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.




\chapter{Dự đoán}
\label{chap08}

Ở chương trước, ta đã phát triển một mô hình bậc hai cho sự tăng trưởng dân số thế giới từ 1950 đến 2016. Đây là một mô hình đơn giản, nhưng nó khớp với số liệu và cơ chế hoạt động của nó khá hợp lý.

Trong chương này ta sẽ dùng mô hình bậc hai để phát sinh ra dự phóng về sự tăng trưởng trong tương lai, cũng như so sánh kết quả ta tìm được với những dự phóng thực sự do các nhà dân số học đã nghiên cứu. Chúng ta cũng sẽ trình bày các mô hình từ những chương trước dưới dạng phương trình vi phân và giải chúng theo cách giải tích.

\index{dự đoán}
\index{dự phóng}


\section{Phát sinh các dự phóng}

Ta sẽ bắt đầu bằng mô hình bậc hai từ Mục ~\ref{quadratic}, vốn được dựa trên hàm được ập nhật sau:
\index{tăng trưởng bậc hai}

\begin{python}
def update_func_quad(pop, t, system):
    net_growth = system.alpha * pop + system.beta * pop**2
    return pop + net_growth
\end{python}

Như ta đã thấy từ chương trước, ta có thể lấy ngày bắt đầu, ngày kết thúc và dân số ban đầu từ \py{census}, vốn là một dãy chứa các ước lượng dân số liệt kê bởi Cục Điều tra Hoa Kỳ:

\begin{python}
t_0 = get_first_label(census)
t_end = get_last_label(census)
p_0 = census[t_0]
\end{python}

Bây giờ ta có thể tạo một đối tượng \py{System}:
\index{System (đối tượng)}

\begin{python}
system = System(t_0=t_0, 
                t_end=t_end,
                p_0=p_0,
                alpha=0.025,
                beta=-0.0018)
\end{python}

Rồi chạy mô hình:

\begin{python}
results = run_simulation(system, update_func_quad)
\end{python}

Ta đã thấy kết quả ở Hình~\ref{chap03-fig04}.  Bây giờ, để tạo một dự phóng, cái duy nhất mà ta cần thay đổi là \py{t_end}:

\begin{python}
system.t_end = 2250
results = run_simulation(system, update_func_quad)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap04-fig01.pdf}}
\caption{Mô hình bậc hai cho sự tăng trưởng dân số thế giới, cùng dự phóng từ năm 2016 đến 2250.}
\label{chap04-fig01}
\end{figure}

Hình~\ref{chap04-fig01} cho thấy kết quả, với dự phóng đến tận năm 2250. Theo mô hình này, mức tăng trưởng dân số sẽ tiếp tục gần như tuyến tính trong 50--100 năm tới, và rồi chậm lại trong 100 năm tiếp theo, tiệm cận đến 13.9 tỉ vào năm 2250.

Tôi chủ ý dùng chữ ``dự phóng" thay vì ``dự đoán", với sự khác biệt sau đây: ``dự đoán" ngụ ý rằng ``đây là điều mà chúng ta cần trông đợi sẽ xảy ra, chí ít là gần như vậy"; còn ``dự phóng" ngụ ý rằng ``nếu mô hình này thực sự là cách mô tả sát với những gì đang xảy ra trong hệ thống, và trong tương lai không có gì làm thay đổi các tham số của mô hình, thì kết quả này là những gì sẽ xảy ra."

Bằng cách nói ``dự phóng" sẽ để ngỏ khả năng những thứ quan trọng trên thực tế vẫn chưa được nắm giữ lại trong mô hình. Nó cũng gợi ý rằng, ngay cả khi mô hình đã tốt chăng nữa, thì các tham số mà ta dự đoán dựa theo quá khứ vẫn có thể khác đi trong tương lai.

Mô hình bậc 2 mà ta đang làm việc với được dựa trên giả thiết rằng mức độ tăng trưởng dân số bị giới hạn bởi mức độ sẵn có của tài nguyên. Trong trường hợp này, khi dân số tiệm cận với sức chứa dân cư thì sinh suất sẽ giảm và tử suất tăng vì tài nguyên trở nên hiếm hoi.

\index{sức chứa dân cư}

Nếu giả thiết đó là đúng thì ta có thể sẽ dùng được mức độ tăng trưởng dân số thực tế để ước tính sức chứa dân cư, đặc biệt nếu ta quan sát sự chuyển đổi về tình trạng khi mà sinh suất bắt đầu giảm.

Nhưng trong trường hợp tăng trưởng dân số thế giới, các điều kiện đó không nghiệm đúng. Trong vòng 50 năm qua, tốc độ tăng trưởng ròng đã đi ngang nhưng vẫn chưa hạ, vì vậy ta chưa có đủ số liệu để ước tính sức chứa dân cư một cách đáng tin cậy. Và những hạn chế tài nguyên có lẽ {\em không phải} là nguyên nhân chính dẫn đến sự tăng chậm của dân số. Dẫn chứng ư? Hãy xét xem:

\begin{itemize}

\item Trước hế, tử suất không tăng lên, mà giảm từ 1.9\% năm 1950 xuống còn 0.8\% ở hiện tại (xem \url{http://modsimpy.com/mortality}).  Như vậy sự giảm mức tăng trưởng ròng hoàn toàn do giảm sinh suất.

\index{tử suất}

\item Thứ hai, mối liên hệ giữa tài nguyên và sinh suất trái ngược với những gì mà mô hình giả sử; vì các nước phát triển hơn và người dân giàu có hơn, sinh suất có xu hướng giảm.

\index{sinh suất}

\end{itemize} 

Ta không nên bảo lưu cứng nhắc ý kiến rằng mô hình này có thể ước tính được sức chứa dân cư. Nhưng các dự đoán của mô hình có thể tin cậy được ngay cả khi các giả thiết mô hình không nhất nhất phải đúng. Chẳng hạn, sự tăng trưởng dân cư có thể diễn biến {\em như thể} nó bị hạn chế bởi tài nguyên, dù rằng cơ chế thực sự lại ở chỗ khác.

Thực ra, các nhà nhân khẩu học khi nghiên cứu tăng trưởng dân số cũng dùng những mô hình ta đang xem đây. Trong mục tới, ta sẽ so sánh những dự phóng của ta với của họ.


\section{So sánh các dự phóng}

Bảng 3 lấy từ \url{http://modsimpy.com/worldpop} có chứa các kết quả dự phóng từ Cục điều tra Hoa Kỳ và tổ chức DESA Liên hợp Quốc:

\begin{python}
table3 = tables[3]
\end{python}

Có những năm mà một cơ quan nào đó không công bố một kết quả dự phóng, vì vậy vài phần tử trong  \py{table3} chứa giá trị đặc biệt \py{NaN}, viết tắt từ ``not a number" (không phải một trị số).  \py{NaN} thường được dùng để biểu diễn một giá trị khuyết thiếu.

\index{không phải trị số}
\index{NaN}
\index{giá trị khuyết thiếu}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap04-fig02.pdf}}
\caption{Các dự phóng dân số thế giới phát sinh bởi Cục điều tra Hoa Kỳ, Liên hợp Quốc, và mô hình bậc hai ta đang dùng.}
\label{chap04-fig02}
\end{figure}

Pandas cung cấp các hàm xử lý số liệu khuyết thiếu, bao gồm \py{dropna}, để loại bỏ bất kì phần tử trong dãy có chứa \py{NaN}.  Bằng cách dùng \py{dropna}, ta có thể vẽ đồ thị kết quả dự phóng như sau:

\index{Pandas}
\index{dropna}

\begin{python}
def plot_projections(table):
    census_proj = table.census / 1e9
    un_proj = table.un / 1e9
    
    plot(census_proj.dropna(), 'b:', label='US Census')
    plot(un_proj.dropna(), 'g--', label='UN DESA')
\end{python}

Chuỗi định dạng \py{'b:'} thể hiện một đường nét chấm xanh lam; còn \py{g--} thể hiện đường gạch đứt xanh lục.

\index{chuỗi định dạng}
\index{đồ thị}

Ta có thể chạy mô hình cho cùng thời khoảng đó:

\begin{python}
system.t_end = 2100
results = run_simulation(system, update_func_quad)
\end{python}

Rồi so sánh kết quả dự phóng của ta với của họ. Hình~\ref{chap04-fig02} thể hiện kết quả. Các nhà nhân khẩu học đều dự liệu rằng dân số thế giới sẽ tăng chậm hơn là kết quả chúng ta dự phóng, có thể do mô hình của họ được phân chia áp dụng cho từng miền, từng quốc gia, nơi có điều kiện khác nhau, và họ cũng xét đến yếu tố phát triển kinh tế nữa.

\index{nhân khẩu học}

Dù sao, những dự phóng của họ cũng tương tự về mặt định tính với kết quả chúng ta, và giữa các nhà nhân khẩu cũng có kết quả khác nhau như họ khác chúng ta. Vì vậy kết quả mô hình chúng ta, dù đơn giản, song không hẳn là kết quả bỏ đi.

Trước khi tiếp tục, bạn có thể muốn xem tập lệnh cho chương này, \py{chap08.ipynb}, và làm các bài tập. Để biết chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


% ================


\chapter{Giải tích}
\label{chap09}

Ở chương này, ta diễn đạt những mô hình trong các chương trước dưới dạng phương trình sai phân và phương trình vi phân, giải những phương trình này và thiết lập dạng biểu thức toán cho nghiệm. Ta cũng sẽ thảo luận vai trò bổ trợ của giải tích toán học trong mô phỏng.


\section{Liên hệ lặp lại}

Những mô hình dân số trong chương trước và chương này đơn giản ở mức ta không thực sự cần phải chạy mô phỏng, mà có thể giải bằng toán học. Chẳng hạn, ta viết mô hình tăng trưởng hằng số như sau:

\begin{python}
model[t+1] = model[t] + annual_growth
\end{python}

Bằng kí hiệu toán học, ta có thể viết chính mô hình đó dưới dạng:
%
\[ x_{n+1} = x_n + c \]
%
trong đó $x_n$ là dân số trong năm $n$, $x_0$ là dân số ban đầu đã cho, còn $c$ là hằng số tăng trưởng từng năm.  Cách biểu diễn mô hình như thế này được gọi là {\bf liên hệ lặp lại}; xem \url{http://modsimpy.com/recur}.

\index{liên hệ lặp lại}

Đôi khi ta có thể giải được một liên hệ lặp lại bằng cách một phương trình tính trực tiếp $x_n$, ứng với một giá trị đã biết của $n$; nghĩa là không cần phải tính qua những giá trị trung gian từ $x_1$ đến tận $x_{n-1}$.

Trong trường hợp tăng trưởng hằng số, có thể thấy rằng $x_1 = x_0 + c$, và $x_2 = x_1 + c$.  Kết hợp chúng lại, ta được $x_2 = x_0 + 2c$, và tiếp đó $x_3 = x_0 + 3c$. Không quá khó để kết luận được rằng nói chung
%
\[ x_n = x_0 + nc \]
%
Như vậy, nếu ta muốn biết $x_{100}$ mà không cần để tâm tới các giá trị khác, thì ta có thể tính nó bằng một phép nhân và một phép cộng.

Ta cũng có thể viết mô hình tỉ lệ theo dạng liên hệ lặp lại:
%
\[ x_{n+1} = x_n + \alpha x_n \]
%
Hay một cách quy củ hơn như sau:
%
\[ x_{n+1} = x_n (1 + \alpha) \]
%
Bây giờ ta có thể thấy $x_1 = x_0 (1 + \alpha)$, và $x_2 = x_0 (1 + \alpha)^2$, và nói chung 
%
\[ x_n = x_0 (1 + \alpha)^n \]
%
Kết quả này là một {\bf cấp số nhân}; xem \url{http://modsimpy.com/geom}.  Khi $\alpha$ là số dương, thừa số $1+\alpha$ lớn hơn 1, vì vậy các phần tử trong dãy cứ tăng lên không giới hạn.

\index{cấp số nhân}
\index{tăng trưởng bậc hai}

Sau cùng, ta có thể viết mô hình bậc hai như sau:
%
\[ x_{n+1} = x_n + \alpha x_n + \beta x_n^2 \]
%
hay với cách tham số hoá thường gặp như sau:
%
\[ x_{n+1} = x_n + r x_n (1 - x_n / K) \]
%
Không có nghiệm giải tích nào cho phương trình này, song ta có thể xấp xỉ nó bằng một phương trình sai phân rồi giải, đó là việc ta sẽ làm trong mục tiếp sau.


\section{Phương trình vi phân}
\label{diffeq}

Ta hãy lại bắt đầu từ mô hình tăng trưởng hằng số
%
\[ x_{n+1} = x_n + c \]
%
Nếu định nghĩa $\Delta x$ là mức thay đổi của $x$ từ một bước thời gian tới bước tiếp theo, ta có thể viết:
%
\[ \Delta x = x_{n+1} - x_n = c \]
%
Nếu định nghĩa $\Delta t$ là bước thời gian, vốn bằng 1 năm ở ví dụ này, thì ta có thể viết tốc độ thay đổi trong mỗi bước thời gian như sau:
%
\[ \frac{\Delta x}{\Delta t} = c \]
%
Mô hình này là {\bf rời rạc}, nghĩa là nó chỉ được xác định tại những giá trị nguyên của $n$ chứ không phải giữa những giá trị đó. Song trên thực tế, thế giới luôn có người sinh ra về chết đi liên tục mọi thời điểm chứ không phải mỗi năm chỉ một lần, vì vậy một mô hình {\bf liên tục} có thể sẽ sát thực hơn.

\index{rời rạc}
\index{liên tục}
\index{bước thời gian}

Ta có thể làm cho mô hình này liên tục bằng cách viết tốc theo đổi dưới dạng một đạo hàm:
%
\[ \frac{dx}{dt} = c \]
%
Cách biểu diễn mô hình này là một {\bf phương trình vi phân}; xem \url{http://modsimpy.com/diffeq}.

\index{phương trình vi phân}

Ta có thể giải phương trình vi phân này nếu nhân cả hai vế với $dt$:
%
\[ dx = c dt \]
%
Rồi sau đó lấy tích phân hai vế:
%
\[ x(t) = c t + x_0 \]
%
Tương tự, ta có thể viết mô hình tăng trưởng tỉ lệ như sau:
%
\[ \frac{\Delta x}{\Delta t} = \alpha x \]
%
Và dưới dạng phương trình vi phân như sau:
%
\[ \frac{dx}{dt} = \alpha x \]
%
Nếu nhân cả hai vế với $dt$ và chia cho $x$, ta thu được
%
\[ \frac{1}{x}~dx = \alpha~dt \] 
%
Bây giờ ta lấy tích phân hai vế để nhận được:
%
\[ \ln x = \alpha t + K \]
%
trong đó $\ln$ là loga tự nhiên còn $K$ là hằng số tích phân. Lấy hàm mũ cả hai vế\footnote{Hàm mũ có thể viết là  $\exp(x)$ hay $e^x$.  Trong sách này tôi chọn cách thứ nhất vì nó trông giống mã lệnh Python. }, ta có
%
\[ \exp(\ln(x)) = \exp(\alpha t + K) \]
%
vốn có thể viết lại thành
%
\[ x = \exp(\alpha t) \exp(K) \]
%
Vì $K$ là một hằng số tuỳ ý, $\exp(K)$ cũng là một hằng số tuỳ ý, nên ta có thể viết
%
\[ x = C \exp(\alpha t) \]
%
trong đó $C = \exp(K)$.  Có nhiều nghiệm của phương trình vi phân này, với các giá trị khác nhau của $C$.  Nghiệm riêng mà ta muốn là nghiệm có giá trị bằng $x_0$ khi $t=0$. 

Khi $t=0$, $x(t) = C$, do vậy $C = x_0$ và nghiệm ta có là
%
\[ x(t) = x_0 \exp(\alpha t) \]
%
Nếu bạn muốn thấy cách biến đổi đạo hàm trên một cách kĩ lưỡng thì có thể xem video này: \url{http://modsimpy.com/khan1}.

\index{loga}
\index{hàm mũ}
\index{tích phân}
\index{hằng số tích phân}


\section{Giải tích và mô phỏng}

Một khi bạn đã thiết kế nên mô hình, thường có hai cách tiếp tục: mô phỏng và giải tích. Mô phỏng thường tiến hành dưới dạng một chương trình máy tính nhằm mô hình hóa sự thay đổi diễn ra trong hệ thống theo thời gina, như sự sinh ra và chết đi, hay xe di chuyển giữa các địa điểm. Giải tích được tiến hành dưới dạng đại số: nghĩa là biến đổi các biểu thức toán học với các kí hiệu.

\index{giải tích}
\index{đại số}
\index{phép toán với kí hiệu}

Giải tích và mô phỏng có chức năng khác nhau và với những hạn chế riêng. Nói chung, mô phỏng có tính linh động hơn; ta có thể dễ dàng bổ sung hoặc rút bớt từng phần chương trình và kiểm tra nhiều phiên bản của một mô hình, như đã thực hiện ở những ví dụ trước đây.

Tuy nhiên còn vài điều ta có thể làm bằng giải tích mà sẽ khó hơn, thậm chí không thể, bằng mô phỏng:

\begin{itemize}

\item Bằng giải tích, đôi khi ta có thể tính được một cách chính xác và hiệu quả, một giá trị mà dùng mô phỏng thì chỉ tính được xấp xỉ và kém hiệu quả hơn. Chẳng hạn, trên Hình~\ref{chap03-fig05}, có thể thấy rằng mức tăng trưởng ròng tiến tới 0 khi dân số ở gần 14 tỉ, và ta có thể ước tính sức chứa bằng một thuật toán dò tìm số (sẽ đề cập tới sau này). Nhưng bằng cách giải tích ở Mục~\ref{equilibrium}, ta thu được kết quả tổng quát là $K=-\alpha/\beta$.

\item Giải tích thường cho ta những ``lối tắt tính toán", nghĩa là, khả năng nhảy tới tương lai để tính ra trạng thái của hệ thống ở cách nhiều bước thời gian mà không phải tính những trạng thái trung gian.

\index{bước thời gian}

\item Ta có thể dùng giải tích để phát biểu và chứng minh những lý luận khái quát về mô hình; chẳng hạn ta có thể chứng minh rằng những kết quả nhất định sẽ luôn luôn hoặc không bao giờ xảy ra. Bằng mô phỏng, ta có thể thể hiện những ví dụ và đôi khi tìm ra những phản chứng, song sẽ rất khó để chứng minh được điều gì.

\index{chứng minh}

\item Giải tích có thể cho ta những chi tiết sâu trong mô hình và hệ thống mà chúng miêu tả; chẳng hạn đôi khi ta có thể nhận diện những chế độ mà hệ thống có ứng xử định tính riêng, cùng những tham số mấu chốt kiểm soát những ứng xử đó.

\index{chế độ}

\end{itemize}

Khi người ta thấy được những gì mà giải tích có thể làm được, họ đôi khi say sưa với những khả năng đó, tưởng rằng nó có thể cho những khả năng đặc biệt để vén bức màn thế giới sự vật và khám phá quy luật toán học chi phối vũ trụ. Khi họ phân tích một mô hình của hệ thống vật lý, họ nói về ``phép toán đằng sau nó" như thể thế giới chúng ta chỉ là một hình bóng của thees giới những thực thể toán học lý tưởng\footnote{Tôi không bày đặt ra điều này; hãy xem  \url{http://modsimpy.com/plato}.}.

\index{Plato}

Dĩ nhiên điều này không phải là nhảm nhí. Những kí hiệu toán học là một ngôn ngữ được con người tạo ra nhằm mục đích cụ thể, đặc biệt là để làm phép tính đại số. Tương tự, những ngôn ngữ lập trình được thiết kế nhằm mục đích biểu diễn những ý tưởng tính toán và chạy các chương trình.

\index{kí hiệu toán học}
\index{ngôn ngữ lập trình}

Mỗi loại ngôn ngữ nêu trên đều phù hợp với mục đích mà nó được tạo ra nhưng không phù hợp với những mục đích khác. Song chúng thường bổ trợ cho nhau, và một trong những mục tiêu của cuốn sách này là cho thấy chúng được sử dụng kết hợp như thế nào.


\section{Giải tích dùng WolframAlpha}

Cho đến gần đây, hầu hết phép tính giải tích được thực hiện bằng ngòi bút viết trên giấy\footnote{Hoặc ``mài viên đá phấn trên tảng đá đen'' (rubbing the white rock on the black rock), một dòng chữ mà tôi đã đọc được từ Woodie Flowers, người trích theo Stephen Jacobsen.}, một công việc vất vả và dễ phạm sai sót. Một cách khác là dùng máy tính thực hiện phép toán với kí hiệu. Nếu bạn đã sử dụng một dịch vụ kiểu như WolframAlpha, thì chính bạn đã dùng tính toán với kí hiệu rồi đó.

\index{tính toán kí hiệu}
\index{WolframAlpha}

Chẳng hạn, nếu bạn vào trang web \url{https://www.wolframalpha.com/} và gõ 

\begin{python}
df(t) / dt = alpha f(t)
\end{python}

thì WolframAlpha sẽ suy luận rằng \py{f(t)} là một hàm chứa \py{t} còn \py{alpha} là một tham số; truy vấn (``câu lệnh'') này được liệt vào loại ``phương trình vi phân thường tuyến tính bậc nhất", và nghiệm tổng quát được báo lại là:
%
\[ f(t) = c_1 \exp(\alpha t) \]
%
Nếu bạn thêm một phương trình thứ hai để chỉ định điều kiện ban đầu:

\begin{python}
df(t) / dt = alpha f(t),  f(0) = p_0
\end{python}

thì WolframAlpha sẽ báo lại nghiệm riêng:

\[ f(t) = p_0 \exp(\alpha t) \]

WolframAlpha được dựa trên Mathematica, một ngôn ngữ lập trình mạnh mẽ được thiết kế riêng cho mục đích tính toán kí hiệu.

\index{Mathematica}


\section{Giải tích dùng SymPy}

Python có một thư viện tên là SymPy để cung cấp những công cụ tính toán kí hiệu cũng tương tự như Mathematica.  Chúng không dễ dùng như WolframAlpha, song lại có một số lợi thế khác.

\index{SymPy}

Trước khi sử dụng SymPy, ta phải viết lệnh nhập nó.

\index{import (câu lệnh)}
\index{câu lệnh!import}

\begin{python}
from sympy import *
\end{python}

SymPy định nghĩa nhiều hàm, và một vài trong số chúng trùng tên với các hàm định nghĩa bởi \py{modsim} và những thư viện khác mà ta đang sử dụng. Để tránh những xung đột này, tôi khuyên bạn tính toán kí hiệu bằng SymPy trên một trang sổ tính khác.

SymPy định nghĩa một đối tượng \py{Symbol} để biểu diễn các tên biến, tên hàm và kí hiệu toán học khác.

\index{Symbol (đối tượng)}

Hàm \py{symbols} nhận vào một chuỗi rối trả lại các đối tượng \py{Symbol} objects.  Vì vậy, nếu ta chạy câu lệnh này:

\begin{python}
t = symbols('t')
\end{python}

thì Python sẽ hiểu rằng \py{t} là một kí hiệu, chứ không phải một trị số. Bây giờ, nếu ta chạy lệnh

\begin{python}
expr = t + 1
\end{python}

thì Python sẽ không cố thử làm phép tính cộng. Trái lại, nó tạo một \py{Symbol} mới để biểu diễn tổng của \py{t} và \py{1}.  Ta có thể lượng giá tổng này bằng cách dùng \py{subs}, một phương thức thay thế giá trị cho một kí hiệu. Ví dụ sau sẽ thay thế giá trị 2 cho \py{t}:

\begin{python}
expr.subs(t, 2)
\end{python}

Kết quả sẽ là 3.

Các hàm trong SymPy được biểu diễn bởi một loại \py{Symbol} đặc biệt:

\begin{python}
f = Function('f')
\end{python}

Bây giờ nếu ta viết \py{f(t)}, ta sẽ thu được một đối tượng biểu diễn giá trị của một hàm, $f$, tại một giá trị của $t$. Nhưng một lần nữa, SymPy sẽ không cố thử lượng giá nó.


\section{Phương trình vi phân trong SymPy}

SymPy cung cấp một hàm, \py{diff}, có thể tính vi phân một hàm số. Ta có thể áp dụng nó cho hàm số \py{f(t)} như sau:

\index{phương trình vi phân}
\index{SymPy}

\begin{python}
dfdt = diff(f(t), t)
\end{python}

Kết quả là một \py{Symbol} biểu diễn cho đạo hàm của \py{f} theo \py{t}.  Nhưng một lần nữa, SymPy chưa vội cố gắng tính đạo hàm này.

\index{Symbol (đối tượng)}

Để biểu diễn một phương trình vi phân, ta dùng \py{Eq}:

\begin{python}
alpha = symbols('alpha')
eq1 = Eq(dfdt, alpha*f(t))
\end{python}

Kết quả là một đối tượng biểu diễn cho một phương trình, vốn được hiển thị như sau:
%
\[ \frac{d}{d t} f{\left (t \right )} = \alpha f{\left (t \right )} \]
%
Bây giờ ta có thể dùng \py{dsolve} để giải phương trình vi phân này:

\begin{python}
solution_eq = dsolve(eq1)
\end{python}

Kết quả là phương trình
%
\[ f{\left (t \right )} = C_{1} \exp(\alpha t) \]
%
Đây là {\bf nghiệm tổng quát}, trong đó vẫn chứa một hằng số không xác định, $C_1$.  Để thu được {\bf nghiệm riêng} ứng với $f(0) = p_0$, ta thay thế \py{p0} cho \py{C1}.  Trước hết, ta cần tạo thêm hai kí hiệu nữa:

\index{nghiệm tổng quát}
\index{nghiệm riêng}

\begin{python}
C1, p_0 = symbols('C1 p_0')
\end{python}

Bây giờ ta có thể thực hiện thay thế:

\begin{python}
particular = solution_eq.subs(C1, p_0)
\end{python}

Kết quả là
%
\[ f{\left (t \right )} = p_{0} \exp(\alpha t) \]
%
Hàm số này được gọi là {\bf đường cong tăng trưởng theo cấp số nhân}; xem \url{http://modsimpy.com/expo}.

\index{tăng trưởng theo cấp số nhân}


\section{Giải mô hình tăng trưởng bậc hai}

Trong tập lệnh của chương này, bạn sẽ thấy cách sử dụng cùng bộ công cụ để giải mô hình tăng trưởng bậch hai với các tham số $r$ và $K$.  Nghiệm tổng quát là 
%
\[ f{\left (t \right )} = \frac{K \exp(C_{1} K + r t)}{\exp(C_{1} K + r t) - 1} \]
%
Để thu được nghiệm riêng ứng với $f(0) = p_0$, ta ước lượng nghiệm tổng quát tại $t=0$, kết quả cho ta:
%
\[ f(0) = \frac{K \exp(C_{1} K)}{\exp(C_{1} K) - 1} \]
%
Sau đó ta đặt biểu thức này bằng $p_0$ rồi giải tìm ra $C_1$.  Kết quả là:
%
\[ C_1 = \frac{1}{K} \ln{\left (- \frac{p_{0}}{K - p_{0}} \right )} \]
%
Sau cùng, ta thay thế giá trị $C_1$ này vào nghiệm tổng quát, kết quả được:
%
\[ f(t) = \frac{K p_{0} \exp(r t)}{K + p_{0} \exp(r t) - p_{0}} \]
%
Hàm số này được gọi là {\bf đường trong tăng trưởng lôgit}; xem \url{http://modsimpy.com/logistic}.  Trong ngữ cảnh mô hình tăng trưởng, hàm lôgit thường được viết dưới dạng tương đương:
%
\[ f(t) = \frac{K}{1 + A \exp(-rt)} \]
%
trong đó $A = (K - p_0) / p_0$.

Nếu muốn xem cách giải bằng tay phương trình vi phân này, có thể bạn sẽ 
thích video này: \url{http://modsimpy.com/khan2}
\index{tăng trưởng bậc hai}
\index{hàm lôgit}


\section{Tóm tắt}

Bảng dưới đây tóm tắt những kết quả ta thu được đến giờ:

\begin{tabular}{l|l} 
\hline
Loại tăng trưởng         & Rời rạc (phương trình sai phân) \\ 
\hline 
Hằng số & tuyến tính: $x_n = p_0 + \alpha n$  \\ 
 
Tỉ lệ & cấp số nhân: $x_n = p_0(1+\alpha)^n$  \\ 

\end{tabular} 

\begin{tabular}{l|l} 
\hline
        & Liên tục (phương trình vi phân) \\ 
\hline 
Hằng số & tuyến tính: $x(t) = p_0 + \alpha t$ \\ 
 
Tỉ lệ & cấp số nhân: $x(t) = p_0 \exp(\alpha t)$ \\ 
 
Bậc hai & lôgit: $x(t) = K / (1 + A\exp(-rt))$ \\ 
\end{tabular} 

Cái mà tôi gọi là mô hình tăng trưởng hằng số thường được biết đến với tên ``tăng trưởng tuyến tính" vì nghiệm là một đường thẳng. Tương tự, cái mà tôi gọi là tỉ lệ thường được biết đến là ``cấp số nhân", và bậc hai -- thường được biết với tên ``lôgit". Tôi tránh những thuật ngữ thường dùng vì đến bây giờ chúng dựa đến những kết quả mà ta vẫn chưa suy luận ra được.

\index{tăng trưởng tuyến tính}
\index{tăng trưởng cấp số nhân}
\index{tăng trưởng logit}

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap09sympy.ipynb}.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Những nghiên cứu cụ thể}
\label{chap10}

Chương này điểm lại những dạng mẫu tính toán mà ta đã gặ đến giờ cũng như trình bày các bài tập mà bạn có thể áp dụng những dạng mẫu đó.

\section{Công cụ tính toán}

Ở Chương~\ref{chap01}, chúng ta đã dùng Pint để định nghĩa các đơn vị và thực hiện tính toán với đơn vị:

\begin{code}
meter = UNITS.meter
second = UNITS.second
a = 9.8 * meter / second**2
\end{code}

Ở Chương~\ref{chap02} ta đã định nghĩa một đối tượng \py{State} để chứa các biến đại diện cho trạng thái của hệ thống, thường thay đổi theo thời gian:

\begin{code}
bikeshare = State(olin=10, wellesley=2)
\end{code}

Ta đã dùng những toán tử cập nhật như \py{+=} và \py{-=} để thay đổi các biến trạng thái. Ta dùng các câu lệnh \py{print} để hiển thị giá rị của các biến.

Ta đã dùng hàm \py{flip} để mô phỏng các thời điểm tới ngẫu nhiên, và dùng câu lệnh  \py{if} để kiểm tra kết quả.

Ta đã học cách định nghĩa những hàm mới có nhận các tham số:

\begin{code}
def step(p1, p2):
    if flip(p1):
        bike_to_wellesley()
        
    if flip(p2):
        bike_to_olin()
\end{code}

Ta đã dùng một vòng lặp \py{for} với hàm \py{range} để thực thi phần thân của một vòng lặp với số lần định trước.

\begin{code}
for i in range(4):
    step(p1, p2)
\end{code}

Ta đã học cách tạo một đối tượng \py{TimeSeries} rồi dùng nó để lưu giữ giá trị của một biến trạng thái khi nó thay đổi theo thời gian:

\begin{code}
results = TimeSeries()

for i in range(10):
    step(0.3, 0.2)
    results[i] = bikeshare.olin
\end{code}

Ta đã dùng \py{plot} để vẽ đồ thị kết quả, \py{decorate} để ghi tiêu đề trục, và \py{savefig} để lưu hình vẽ.

\begin{code}
plot(results, label='Olin')
decorate(xlabel='Time step (min)', 
         ylabel='Number of bikes')
savefig('chap01-fig01.pdf)
\end{code}

Ở Chương~\ref{chap03} ta đã dùng toán tử so sánh để kiểm tra những điều kiện nhất định và câu lệnh  \py{return} để kết thúc thực thi một hàm.

\begin{code}
def bike_to_olin(state):
    if state.wellesley == 0:
        state.wellesley_empty += 1
        return
    state.wellesley -= 1
    state.olin += 1
\end{code}

Ở Chương~\ref{chap04} ta đã viết một phiên bản của \py{run_simulation} có dùng một lệnh \py{return} để trả lại một giá trị:

\begin{code}
def run_simulation(p1, p2, num_steps):
    state = State(olin=10, wellesley=2, 
                  olin_empty=0, wellesley_empty=0)
                    
    for i in range(num_steps):
        step(state, p1, p2)
        
    return state
\end{code}

Phiên bản này của \py{run_simulation} trả lại giá trị cuối cùng của \py{state}, trong đó chứa các thông số (metrics) mà ta có thể dùng để đo hiệu năng của hệ thống.

Ta đã dùng \py{linspace} để tạo nên một mảng NumPy chứa những giá trị cách đều nhau, và một vòng lặp \py{for} để lặp qua mảng này. Ta đã dùng một \py{SweepSeries} để lưu kết quả từ một loạt (series) các mô phỏng, ánh xạ từ giá trị của mỗi thông số tới giá trị của metric tương ứng.

\begin{code}
p1_array = linspace(0, 1, 11)
sweep = SweepSeries()

for p1 in p1_array:
    state = run_simulation(p1, p2, num_steps)
    sweep[p1] = state.olin_empty
\end{code}

Ở Chương~\ref{chap05}, ta đã dùng Pandas để đọc dữ liệu từ một trang web và lưu kết quả vào trong một \py{DataFrame}.  Ta đã chọn một cột từ \py{DataFrame} này để thu được một dãy \py{Series}.

Ở Chương~\ref{chap06}, ta đã tạo một đối tượng \py{System} có chứa các tham số mô hình, và định nghĩa một phiên bản khác cho \py{run_simulation}:

\begin{code}
def run_simulation(system, update_func):
    results = TimeSeries()
    results[system.t_0] = system.p_0
    
    for t in linrange(system.t_0, system.t_end):
        results[t+1] = update_func(results[t], t, system)
        
    return results
\end{code}

Phiên bản này nhận vào một đối tượng \py{System} làm tham số, và một hàm cập nhật. Thay vì trả lại trạng thái cuối của hệ thống, nó trả lại một \py{TimeSeries} có chứa trạng thái khi thay đổi theo thời gian.

Hàm cập nhật nhận lấy các tham số gồm trạng thái hiện thời của hệ thống, thời gian, và đối tượng \py{System}, rồi trả lại trạng thái mới. Chẳng hạn, sau đây là hàm cập nhật cho mô hình phát triển bậc hai.

\begin{code}
def update_func_quad(pop, t, system):
    net_growth = system.alpha * pop + system.beta * pop**2
    return pop + net_growth
\end{code}

Ở ví dụ này, trạng thái của hệ thống là một con số, \py{pop}.  Sau này ta sẽ thấy những ví dụ mà trạng thái được biểu diễn bởi một đối tượng \py{State} chứa nhiều hơn một biến.

Chương~\ref{chap07} giới thiệu mô hình tăng trưởng bậc hai và Chương~\ref{chap08} sử dụng mô hình đó để phát sinh những dự đoán, nhưng hai chương này đều không giới thiệu thêm công cụ tính toán nào mới cả.

Chương~\ref{chap09} giới thiệu SymPy, mà ta có thể sử dụng để tạo các đối tương \py{Symbol}:

\begin{code}
t, alpha = symbols('t alpha')
f = Function('f')
\end{code}

viết các phương trình vi phân:

\begin{code}
dfdt = diff(f(t), t)
eq1 = Eq(dfdt, alpha*f(t))
\end{code}

rồi giải chúng:

\begin{code}
solution_eq = dsolve(eq1)
\end{code}

Trên đây đã tóm tắt những công cụ tính toán mà ta đã thấy cho đến giờ.


\section{Nhìn bên trong}
\label{dataframe}

Đến giờ ta đã dùng các đối tượng \py{DataFrame} và \py{Series} mà không thực sự hiểu được cách chúng hoạt động ra sao. Ở mục này, ta sẽ điểm lại những gì ta biết đến giờ và đi sâu thêm chút nữa vào các chi tiết.

Mỗi \py{DataFrame} có chứa 3 đối tượng: \py{index} là một dãy các nhãn ghi các hàng, \py{columns} là một dãy các nhãn ghi các cột, và \py{values} là một mảng NumPy chứa dữ liệu.

Với các đối tượng \py{DataFrame} trong chương này, \py{index} có chứa các năm từ 1950 đến 2016, \py{columns} chứa tên của các tổ chức hoặc cá nhân thực hiện dự đoán, còn \py{values} là mảng chứa các trị số dự đoán.

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/dataframe.pdf}}
\caption{Các thành phần hợp nên một \py{DataFrame} và một \py{Series}.}
\label{fig-dataframe}
\end{figure}

Một \py{Series} cũng giống với \py{DataFrame} chỉ có một cột: nó chứa một chuỗi kí tự \py{name} giống như một nhãn tên cột, một chỉ số, và một mảng các giá trị.

Hình~\ref{fig-dataframe} minh họa các phần tử của một \py{DataFrame} và \py{Series}.

\index{type (hàm)}

Để xác dịnh kiểu của những phần tử này, ta có thể sử dụng hàm \py{type} trong Python:

\begin{code}
type(table2)
type(table2.index)
type(table2.columns)
type(table2.values)
\end{code}

Kiểu của \py{table2} là \py{DataFrame}.  Kiểu của \py{table2.index} là \py{Int64Index}, vốn giống như một \py{Series}.

Kiểu của \py{table2.columns} là \py{Index}, vốn có vẻ lạ, vì chỉ số là dãy các nhãn tên hàng. Nhưng dãy ác nhãn tên cột cũng là một kiểu chỉ số vậy.

Kiểu của \py{table2.values} là \py{ndarray}, vốn là kiểu mảng cơ bản được NumPy cung cấp; tên của nó chỉ rằng mảng này có \textit{n} chiều (``n-dimensional"); nghĩa là nó có thể có số chiều tùy ý.

Trong \py{census} hay \py{un}, chỉ số là một đối tượng \py{Int64Index} còn giá trị được lưu vào trong một \py{ndarray}.

Trong thư viện \py{modsim}, các hàm \py{get_first_label} và \py{get_last_label} cho ta một cách đơn giản để truy cập tới chỉ số của một \py{DataFrame} hoặc \py{Series}:

\begin{code}
def get_first_label(series):
    return series.index[0]

def get_last_label(series):
    return series.index[-1]
\end{code}

Viết trong cặp dấu ngoặc, số \py{0} chọn lấy nhãn thứ nhất; còn số \py{-1} chọn lấy nhãn cuối cùng.

Vài đối tượng trong số đã định nghĩa ở \py{modsim} là các phiên bản được chỉnh sửa từ các đối tượng \py{Series}.  Các đối tượng \py{State} và \py{System} là các \py{Series} trong đó các nhãn là những tên biến. Một \py{TimeSeries} là một \py{Series} trong đó các nhãn là thời gian, còn một \py{SweepSeries} là một \py{Series}  trong đó các nhãn là những giá trị tham số.

Không cần thiết phải dịnh nghĩa những đối tượng này; ta có thể làm điều tương tự bằng cách dùng những đối tượng \py{Series}. Nhưng bằng cách đặt tên khác nhau cho chúng đã giúp cho mã lệnh dễ đọc và dễ hiểu hơn, và cũng giúp tránh được những kiểu lỗi nhất định (như bị nhầm lẫn hai loại đối tượng \py{Series}).

Sau này nếu bạn viết các mô phỏng bằng Python, bạn có thể tiếp tục sử dụng những đối tượng trong \py{modsim} khi cần thiết, hoặc có thể trực tiếp sử dụng các đối tượng Pandas.


\section{Một hàng đợi hay là hai?}

Chương này trình bày hai nghiên cứu cụ thể giúp bạn thực hành những gì đã học. Nghiên cứu thứ nhất liên quan tới {\bf lý thuyết hàng đợi}, vốn đi tìm hiểu những hệ thống có thời gian chờ đợi trong các hàng, còn gọi là  những ``hàng đợi".  

Giả sử bạn dang thiết kế khu vực thanh toán của một quầy hàng. Có đủ chỗ trong quầy để bạn bố trí 2 bàn thanh toán và một khu dành cho khách hàng đứng đợi. Bạn có thể bố trí khách xếp hai hàng, mỗi hàng tiến vào một bàn thanh toán, hay chỉ một hàng đi vào cả 2 bàn.

Về lý thuyết, bạn sẽ dự trù rằng một hàng hẳn phải tốt hơn, nhưng nó có những trở ngại rất thực tế: để duy trì dược một hàng, bạn phải đặt thêm rào chắn, và khách hàng có thể cảm thấy bực vì hàng có vẻ dài hơn, dù rằng hàng này sẽ di chuyển nhanh hơn.

Như vậy bạn sẽ muốn kiểm tra xem liệu một hàng có thực sự nhanh hơn không và nếu có thì nhanh hơn bao nhiêu. Mô phỏng sẽ giúp ta giải đáp điều này.

\begin{figure}
\centerline{\includegraphics[width=4.5in]{figs/queue.pdf}}
\caption{Một hàng đợi với một bàn phục vụ (trái), một hàng đợi với hai bàn phục vụ (giữa), hai hàng đợi với hai bàn phục vụ (phải).}
\label{fig-queue}
\end{figure}

Hình~\ref{fig-queue} cho thấy ba kịch bản mà ta cần xét đến. Như đã làm với mô hình chung xe, ta sẽ giả sử rằng một khách hàng có khả năng đồng đều xuất hiện vào bất kì bước thời gian nào. Tôi sẽ kí hiệu xác suất này bằng chữ cái Hi Lạp lambda, $\lambda$, hoặc bằng tên biến \py{lam}.  Trị số của $\lambda$ có lẽ thay đổi ngày qua ngày, bởi vậy ta sẽ phải xét một khoảng các xác suất.

Dựa vào số liệu từ những cửa hàng khác, bạn biết rằng trung bình mỗi khách hàng phải mất 5 phút để chờ đến khi thanh toán xong. Nhưng thời gian thanh toán này lại khác nhau: đa số khách hàng mất ít hơn 5 phút, nhưng có người lại mất nhiều hơn 5 phút rất nhiều. Một cách dơn giản để mô hình hóa sự biến đổi này là giả sử rằng khi một khách hàng thanh toán, luôn có cùng xác suất để thanh toán xong xuôi ở bước thời gian kế tiếp, bất kể họ đã mất bao nhiêu thời gian từ lúc xếp hàng đến giờ. Tôi sẽ kí hiệu xác suất này bằng chữ cái Hi Lạp mu, $\mu$, hay là tên biến \py{mu}.

Nếu ta chọn $\mu=1/5$ mỗi phút, thì thời gian trung bình của mỗi lượt thanh toán sẽ là 5 phút; điều này thống nhất với số liệu ta có. Hầu hết mọi người chỉ mất ít hơn 5 phút, nhưng vài người mất thời gian lâu hơn nhiều, vốn có lẽ không phải một mô hình tệ đối với sự phân bố (thời gian thanh toán) thực tế trong quầy.

Bây giờ ta đã sẵn sàng bắt đầu. Trong thư mục mã lệnh kèm cuốn sách này, bạn sẽ thấy một cuốn sổ có tên \py{queue.ipynb} trong đó chứa mã lệnh giúp bạn bắt đầu cùng những hướng dẫn nữa. 

Như thường lệ, bạn nên luyện tập cách phát triển tăng dần: mỗi lần chỉ viết một hai dòng lệnh chứ không hơn, và vừa viết vừa thử chạy chương trình!



\section{Dự đoán số lượng cá hồi}

Hàng năm, Ủy ban đánh giá cá hồi Đại Tây Dương (Atlantic Salmon Assessment Committee) của Hoa Kỳ đều báo cáo con số ước tính số cá hồi trên biển và trong sông ở Đông bắc Hoa Kỳ. Những báo cáo này rất hữu ích để giám sát những thay đổi về số lượng cá, nhưng nói chung không bao gồm các con số dự đoán.

Mục tiêu của nghiên cứu cụ thể này nhằm mô phỏng thay đổi hằng năm của số cá hồi, đánh giá xem những thay đổi này có dễ dự đoán không, và ước tính xác suất để một số cá cụ thể sẽ tăng hay giảm trong vòng 10 năm tới.

Lấy ví dụ, tôi dùng dữ liệu từ trang 18 của cuốn báo cáo năm 2017, vốn cung cấp những số cá ước tính cho các dòng sông Narraguagus và Sheepscot ở bang Maine.

Trong thư mục mã lệnh kèm cuốn sách này, bạn sẽ thấy một cuốn sổ có tên \py{salmon.ipynb} trong đó chứa mã lệnh giúp bạn bắt đầu cùng những hướng dẫn nữa. 

Bạn nên theo hướng dẫn mà tôi đã gợi ý; nếu bạn muốn thử điều gì khác, hãy làm nó!


\section{Tree growth}

Nghiên cứu cụ thể này được dựa theo ``Height-Age Curves for Planted Stands of Douglas Fir, with Adjustments for Density" (tạm dịch: các đường cong biểu hiện chiều cao-tuổi cây thông Douglas được gieo trồng, có điều chỉnh theo mật độ cây), một bài báo của nhóm tác giả Flewelling, Collier, Gonyea, Marshall, và Turnblom, xem link \url{http://modsimpy.com/trees}.

Bài báo cho ta các ``đường cong chỉ số theo địa điểm", đây là những đường cong đồ thị biểu diên chiều cao ước tính của cây cao nhất trong một hàng cây thông Douglas như một hàm tuổi cây, đối với hàng trồng các cây cùng tuổi.

Tùy thuộc vào chất lượng của hàng ở từng địa điểm, cây có thể mọc nhanh hơn hoặc chậm hơn. Như vậy, mỗi đường đồ thị được nhận diện bởi một ``chỉ số địa điểm" vốn phản ánh chất lượng của địa điểm này.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/trees-fig01.pdf}}
\caption{Đồ thị chỉ số địa điểm cho sự sinh trưởng của cây.}
\label{trees-fig01}
\end{figure}

Hình~\ref{trees-fig01} thể hiện các đường đồ thị cho ba chỉ số địa điểm khác nhau. Mục đích của nghiên cứu cụ thể này nhằm giải thích hình dạng của các đường cong này; nghĩa là tại sao cây lại sinh trưởng như vậy.

Để bắt đầu, ta hãy giả sử rằng khả năng cây trồng tăng trọng thì bị hạn chế bởi diện tích nó phơi ra ngoài ánh mặt trời, còn tốc độ tăng trưởng (về khối lượng) thì tỉ lệ thuận với diện tích đó. Như vậy, ta có thể viết:
%
$ m_{n+1} = m_n + \alpha A$
%
trong đó $m_n$ là khối lượng cây tại bước thời gian $n$, $A$ là diện tích phơi nắng, còn $\alpha$ là một hệ số sinh trưởng mà ta chưa biết.

Để đi từ $m$ đến $A$, tôi sẽ giả sử thêm rằng khối lượng thì tỉ lệ với chiều cao lũy thừa một số mũ chưa biết khác:
%
$ m = \beta h^D $
%
trong đó $h$ là chiều cao, $\beta$ là một hằng số tỉ lệ chưa biết, và $D$ là đại lượng liên hệ giữa chiều cao và khối lượng. Để bắt đầu, tôi sẽ giả sử $D=3$, và sẽ còn kiểm tra lại giả sử này sau.

Cuối cùng, tôi sẽ giả sử rằng diện tích thì tỉ lệ với bình phương của chiều cao:

$ A = \gamma h^2$

Tôi tính chiều cao theo feet, và chọn các đơn vị cho khối lượng và diện tích sao cho $\beta=1$ và $\gamma=1$. Tổng hợp mọi thứ lại, ta có thể viết được một phương trình sai phân cho chiều cao:

$ h_{n+1}^D = h_n^D + \alpha h_n^2 $

Nghiệm của phương trình này hóa ra lại gần như một đường thẳng, vậy là mô hình không tồi để biểu diễn đường cong tăng trưởng. Nhưng mô hình lại cho cây lớn lên mãi, và ta biết điều này không đúng. Khi cây càng cao thì càng khó để đưa nước và dưỡng chất lên dưới ảnh hưởng của trọng lực, và do vậy sự tăng trưởng cũng chậm lại.

Ta có thể mô hình hóa hiệu ứng này bằng cách thêm một hệ số vào mô hình tương tự như ta đã thấy ở mô hình logit về tăng trưởng dân số. Thay vì giả sử rằng:

$ m_{n+1} = m_n + \alpha A $ 

Hãy giả sử rằng

$ m_{n+1} = m_n + \alpha A (1 - h / K) $

trong đó $K$ tương tự như sức chứa trong mô hình logit. Khi $h$ tiến đến $K$, thừa số $(1 - h/K)$ sẽ tiến đến 0, dẫn đến mức tăng trưởng bị chậm đi.

Trong thư mục mã lệnh kèm cuốn sách này, bạn sẽ thấy một cuốn sổ có tên \py{trees.ipynb} trong đó lập trình cho cả 2 mô hình và dùng chúng để khớp với dữ liệu. Không có bài tập nào cho nghiên cứu cụ thể này cả. Nghiên cứu chỉ là ví dụ cho thấy bạn có thể làm gì với những công cụ ta học đến giờ, và hé lộ những gì ta có thể làm với công cụ này trong vài chương sắp tới.




\chapter{Dịch tễ học}
\label{chap11}

Trong chương này, chúng tôi phát triển một mô hình dịch bệnh lây lan trong một vùng dân cư dễ lây nhiễm, và sử dụng mô hình để đánh giá mức độ hiệu quả những biện pháp ngăn chặn.

\index{bệnh dịch}

Trình bày của tôi về mô hình SIR trong vài chương sắp tới được dựa theo bài báo xuất sắc của David Smith và Lang Moore\footnote{Smith and Moore, ``The SIR Model for Spread of Disease," Journal of Online Mathematics and its Applications, December 2001, at \url{http://modsimpy.com/sir}.}.

\index{SIR (mô hình)}


\section{Bệnh dịch tân sinh viên}

Hằng năm ở trường Olin College, có khoảng 90 tân sinh viên tới kí túc xá từ khắp nơi trên thế giới. Hầu hết khi mới tới, họ đều khỏe mạnh và vui vẻ, song ít nhất một người mang đến một loại bệnh lây nhiễm nào đó. Vài tuần sau, chắc bạn cũng đoán được, một phần trong số sinh viên bị mắc phải chứng ``bệnh dịch tân sinh viên".

\index{Olin College}
\index{bệnh dịch tân sinh viên}
\index{Kermack-McKendrick}

Ở chương này, chúng tôi giới thiệu một mô hình nổi tiếng về bệnh dịch lây nhiễm, mô hình Kermack-McKendrick, và dùng nó để giải thích sự tiến triển bệnh dịch trong suốt một học kì, dự đoán ảnh hưởng của những biện pháp can thiệp khả dĩ (như miễn dịch) và thiết kế chương trình can thiệp hiệu quả nhất.

\index{bệnh}
\index{lây nhiễm}
\index{thiết kế}

Đến giờ ta đã thực hiện mô phỏng của riêng mình; nghĩa là ta chọn hệ thống vật thể, nhận diện những yếu tố dường như quan trọng, và ra quyết định về cách biểu diễn chúng. Ở chương này, ta bắt đầu bằng một mô hình sẵn có và phân tích nó theo chiều hướng ngược lại. Trong quá trình thực hiện, ta xét những quyết định mô hình gắn với nó và nhận diện những khả năng cùng hạn chế của mô hình này.


\section{Mô hình SIR}

Mô hình Kermack-McKendrick là một phiên bản của {\bf mô hình SIR}. Sở dĩ có tên gọi như vậy vì nó đề cập đến ba nhóm người:

\begin{itemize}

\item {\bf S}: Những người dễ tổn thương, tiếng Anh gọi là ``susceptible"; họ có khả năng bị nhiễm bệnh khi tiếp xúc với những ai mang bệnh.

\item {\bf I}: Những người lây nhiễm, tiếng Anh gọi là ``infectious"; họ có khả năng truyền bệnh nếu họ tiếp xúc với người dễ tổn thương.

\item {\bf R}: Những người đã hồi phục, tiếng Anh gọi là ``recovered".

\end{itemize}

Trong dạng cơ bản của mô hình, những người đã hồi phục thì được coi là miễn nhiễm. Đây là một mô hình hợp lý với vài căn bệnh nhưng lại không phù hợp với các căn bệnh khác; cho nên điều này được xếp vào danh sách những giả sử để sau này xem xét.

Hãy cùng xem số người mỗi loại biến đổi ra sao theo thời gian. Chẳng hạn, ta biết rằng những người mắc bệnh trung bình trong khoảng thời gian 4 ngày. Nếu có 100 người có bệnh tại một thời điểm nào đó, và ta bỏ qua thời điểm cụ thể khi họ bắt đầu mắc thì ta sẽ dự trù rằng cứ trong 4 người sẽ có 1 người hồi phục vào bất kì ngày nào. 

Nói cách khác, nếu thời gian giữa các lần hòi phục là là 4 ngày thì tốc độ hồi phục là khoảng 0.25 ca mỗi ngày. Ta sẽ kí hiệu đại lượng này bằng chữ cái Hy Lạp gamma,  $\gamma$. Nếu số người trong tổng thể dân cư là $N$, và tỉ lệ hiện bị nhiễm là $i$, thì số ca hồi phục mà ta dự trù mỗi ngày sẽ là $\gamma i N$.

\index{tốc độ hồi phục}

Bây giờ hãy hình dung số ca nhiễm mới. Coi như ta biết rằng mỗi người tổn thương tới tiếp xúc với 1 người trong khoảng thời gian trung bình 3 ngày, do đó họ sẽ bị nhiễm  bệnh nếu người kia đã bị nhiễm. Ta sẽ kí hiệu tốc độ tiếp xúc này bằng chữ cái Hy Lạp beta, $\beta$.

\index{tốc độ lây nhiễm}

Có lẽ sẽ không hợp lý nếu giả thiết rằng ta biết trước $\beta$, song về sau ta sẽ thấy cách ước tính nó dựa trên số liệu từ những đợt bùng phát dịch trước đây.

Nếu $s$ là tỉ lệ dân số dễ tổn thương, $s N$ là số người dễ tổn thương, thì $\beta s N$ là số lượt tiếp xúc mỗi ngày, và $\beta s i N$ là số những tiếp xúc trong đó người kia đã nhiễm bệnh.

\index{dễ tổn thương}

Nói tóm lại:

\begin{itemize}

\item Số ca hồi phục ta dự liệu mỗi ngày là $\gamma i N$; đem chia cho $N$ được tỉ lệ dân số phục hồi mỗi ngày, chính là $\gamma i$.

\item Số ca nhiễm mới mỗi ngày là $\beta s i N$; đem chia cho $N$ được tỉ lệ dân số nhiễm bệnh mỗi ngày, chính là $\beta s i$.

\end{itemize}

Mô hình này giả thiết rằng dân số khép kín; nghĩa là không ai mới đến hoặc rời khỏi khu dân cư, và vì vậy số người $N$, là không đổi.


\section{Các phương trình SIR}
\label{sireqn}

Nếu coi thời gian là một đại lượng liên tục thì ta có thể viết các phương trình vi phân mô tả tốc độ thay đổi của $s$, $i$, và $r$ (trong đó $r$ là tỉ lệ dân số đã hồi phục):
%
\begin{align*}
\frac{ds}{dt} &= -\beta s i \\
\frac{di}{dt} &= \beta s i - \gamma i\\
\frac{dr}{dt} &= \gamma i
\end{align*}
%
Để tránh bị chồng chéo, khi viết $s$ tôi đã ngụ ý đó là một hàm theo thời gian, $s(t)$, và tương tự như vậy với $i$ và $r$.
\index{phương trình vi phân}

Các mô hình SIR là ví dụ về {\bf mô hình khoang chứa}. Sở dĩ có tên gọi như vậy vì chúng chia thế giới thực thành các ngăn riêng biệt, cũng như mô tả sự trao đổi giữa các ngăn. Những ngăn này cũng được gọi là {\bf kho} và sự chuyển đổi giữa chúng được gọi là {\bf luồng}.

\index{mô hình khoang chứa}
\index{kho}
\index{luồng}
\index{biểu đồ kho và luồng}

Ở ví dụ này, ta có 3 ``kho'' --- nhóm tổn thương, nhóm nhiễm bệnh, và nhóm phục hồi --- cùng với 2 luồng --- nhiễm mới và phục hồi. Các mô hình khoang chứa thường được biểu diễn bằng sơ đồ kho và luồng (xem \url{http://modsimpy.com/stock}).
Hình~\ref{stock_flow1} thể hiện sơ đồ kho và luồng cho một mô hình SIR.

\begin{figure}
% first version was on YUML
% https://yuml.me/edit/3de9c163
% wget https://yuml.me/2389d485.pdf; mv 2389d485.pdf figs/stock_flow1.pdf
% current version uses lodraw
\centerline{\includegraphics[width=4in]{figs/stock_flow1.pdf}}
\caption{Sơ đồ kho và luồng cho một mô hình SIR.}
\label{stock_flow1}
\end{figure}

Các kho được biểu diễn bằng hình chữ nhật, và luồng bằng những mũi tên. Khí hiệu nằm giữa mũi tên thể hiện một cái van để điều tiết tốc độ luồng chảy; sơ đồ cũng cho thấy những tham số kiểm soát các van này.


\section{Thực hiện}

Với một hệ thống vật lí cho trước, có rất nhiều mô hình khả dĩ; cũng như với một mô hình cho trước sẽ có nhiều cách biểu diễn nó. Chẳng hạn, ta có thể biểu diễn một mô hình SIR như một sơ đồ kho và luồng, như một hệ phương trình vi phân, hoặc như một chương trình Python. Quá trình biểu diễn một mô hình dưới những hình thức này được gọi là {\bf thực hiện}. Ở mục này, ta thực hiện mô hình SIR bằng Python.

\index{thực hiện}

Tôi sẽ biểu diễn trạng thái ban đầu của hệ thống bằng một đối tượng \py{State} cùng những biến trạng thái \py{S}, \py{I}, và \py{R}; chúng thể hiện tỉ lệ của dân số trong từng thành phần.

\index{System (đối tượng)}
\index{State (đối tượng)}
\index{biến trạng thái}

Ta có thể khởi tạo đối tượng \py{State} với {\em số} người thuộc từng thành phần, nếu coi như có một sinh viên bị nhiễm bệnh trong một lớn gồm 90 người:

\begin{python}
init = State(S=89, I=1, R=0)
\end{python}

Và rồi chuyển đổi những con số này về tỉ lệ bằng cách chia cho tổng số:

\begin{python}
init /= sum(init)
\end{python}

Bây giờ ta hãy coi như đã biết thời gian giữa các sự tiếp xúc và thời gian giữa các ca phục hồi:

\begin{python}
tc = 3             # thời gian giữa các tiếp xúc, tính theo ngày
tr = 4             # thời gian hồi phục tính theo ngày
\end{python}

Ta có thể dùng chúng để tính ra các tham số mô hình:

\begin{python}
beta = 1 / tc      # tốc độ tiếp xúc, mỗi ngày
gamma = 1 / tr     # tốc độ hồi phục, mỗi ngày
\end{python}

Bây giờ ta cần một đối tượng \py{System} để lưu trữ các tham số và điều kiện đầu. Hàm sau đây nhận vào những tham số hiệ thống dưới dạng tham số hàm rồi trả lại một đối tượng \py{System} mới:

\index{\py{make_system}}

\begin{python}
def make_system(beta, gamma):
    init = State(S=89, I=1, R=0)
    init /= sum(init)

    t0 = 0
    t_end = 7 * 14

    return System(init=init, t0=t0, t_end=t_end,
                  beta=beta, gamma=gamma)
\end{python}

Giá trị mặc định cho \py{t_end} là 14 tuần, bằng khoảng một học kì.


\section{Hàm cập nhật}

Tai bất kì thời điểm nào, trạng thái của hệ thống được biểu diễn bởi một đối tượng \py{State} với ba biến số, \py{S}, \py{I} và \py{R}.  Vì vậy, tôi sẽ định nghĩa một hàm cập nhật để nhận các tham số gồm một đối tượng \py{State}, thời điểm hiện tại, và một đối tượng \py{System}:

\index{cập nhật (hàm)}
\index{hàm!cập nhật}
\index{bước thời gian}

\begin{python}
def update_func(state, t, system):
    s, i, r = state

    infected = system.beta * i * s    
    recovered = system.gamma * i
    
    s -= infected
    i += infected - recovered
    r += recovered
    
    return State(S=s, I=i, R=r)
\end{python}

Dòng thứ nhất sử dụng một đặc điểm mà tôi chưa từng thấy, {\bf lệnh gán bội}.  Ở vế phải là một đối tượng \py{State} gồm 3 giá trị. Ở vế trái là một dãy gồm 3 tên biến. Lệnh gán bội này thực hiện đúng việc ta mong muốn: nó gán 3 giá trị từ đối tượng \py{State} vào 3 biến theo đúng thứ tự.

Các biến cục bộ, \py{s}, \py{i} và \py{r}, được viết chữ thường để phân biệt với chữ in là các biến trạng thái, \py{S}, \py{I} và \py{R}.

\index{State (đối tượng)}
\index{biến trạng thái}
\index{biến cục bộ}

Hàm cập nhật tính ra \py{infected} và \py{recovered} dưới dạng tỉ lệ của tổng thể, rồi cập nhật \py{s}, \py{i} và \py{r}.  Giá trị trả lại là một \py{State} có chứa các trị số đã cập nhật.

\index{giá trị trả lại}

Khi ta gọi \py{update_func} như sau:

\begin{python}
state = update_func(init, 0, system)
\end{python}

thì kết quả sẽ là một đối tượng \py{State} với các giá trị:

\begin{tabular}{lr}
 & {\bf \sf value} \\ 
\hline 
{\bf \sf S} & 0.985388 \\ 
{\bf \sf I} & 0.011865 \\ 
{\bf \sf R} & 0.002747 \\ 
\end{tabular} 

Bạn có thể phát hiện thấy rằng phiên bản này của \py{update_func} không dùng đến một trong các tham biến của nó là \py{t}.  Dù sao tôi vẫn giữ lại tham biến này mà không bỏ đi, vì đôi lúc hàm cập nhật còn phụ thuộc vào thời gian, và sẽ tiện lợi hơn nếu về mặt hình thức, hàm có những tham biến như nhau, bất kể chúng có được dùng tới hay không.



\section{Chạy mô phỏng}

Bây giờ, ta có thể mô phỏng mô hình qua một dãy thời điểm:

\index{bước thời gian}

\begin{python}
def run_simulation(system, update_func):
    state = system.init

    for t in linrange(system.t0, system.t_end):
        state = update_func(state, t, system)

    return state
\end{python}

Các tham số của \py{run_simulation} bao gồm đối tượng \py{System} và hàm cập nhật. Đối tượng \py{System} cung cấp các tham số, điều kiện ban đầu, và những giá trị \py{t0} và \py{t_end}.

\index{\py{run_simulation}}

Nét bao quát của hàm này chắc bạn thấy quen thuộc; nó giống như hàm ta đã dùng cho mô hình dân số trong Mục~\ref{nowwithsystem}.

Bây giờ ta có thể gọi \py{run_simulation} như sau:

\begin{python}
system = make_system(beta, gamma)
final_state = run_simulation(system, update_func)
\end{python}

Kết quả là trạng thái cuối cùng của hệ thống:

\begin{tabular}{lr}
 & {\bf \sf value} \\ 
\hline 
{\bf \sf S} & 0.520819 \\ 
{\bf \sf I} & 0.000676 \\ 
{\bf \sf R} & 0.478505 \\ 
\end{tabular} 

Kết quả này cho thấy rằng sau 14 tuần (98 ngày), có khoảng 52\% dân số còn bị tổn thương, nghĩa là họ chưa từng bị nhiễm, dưới 1\% hiện đang bị nhiễm, và 48\% đã phục hồi, nghĩa là trong quá khứ có lúc họ đã bị nhiễm.


\section{Thu thập kết quả}

Phiên bản trước của \py{run_simulation} chỉ trả lại trạng thái cuối cùng, nhưng ta có thể muốn xem trạng thái diễn biến ra sao. Ta sẽ xét hai cách thực hiện: đầu tiên là dùng ba đối tượng \py{TimeSeries}, tiếp theo là dùng một đối tượng mới có tên \py{TimeFrame}.

\index{TimeFrame (đối tượng)}
\index{TimeSeries (đối tượng)}

Sau đây là phiên bản thứ nhất:

\begin{python}
def run_simulation(system, update_func):
    S = TimeSeries()
    I = TimeSeries()
    R = TimeSeries()

    state = system.init
    t0 = system.t0
    S[t0], I[t0], R[t0] = state
    
    for t in linrange(system.t0, system.t_end):
        state = update_func(state, t, system)
        S[t+1], I[t+1], R[t+1] = state
    
    return S, I, R
\end{python}

Đầu tiên, ta tạo ra các đối tượng \py{TimeSeries} để lưu trữ kết quả. Chú ý rằng các biến \py{S}, \py{I}, và \py{R} giờ đây là những đối tượng \py{TimeSeries}.

Tiếp theo, ta khởi tạo \py{state}, \py{t0}, cùng những phần tử đầu tiên của \py{S}, \py{I} và \py{R}.  

Bên trong vòng lặp, ta dùng \py{update_func} để tính toán trạng thái của hệ thống tại bước thời gian tiếp theo, rồi dùng lệnh gán bội để gỡ các giá trị của \py{state}, gán từng giá trị cho \py{TimeSeries} tương ứng.

\index{bước thời gian}

Ở cuối hàm này, ta trả lại những giá trị \py{S}, \py{I}, và \py{R}.  Đây là ví dụ đâu tiên ta thấy một hàm trả lại nhiều giá trị.

Bây giờ ta có thể chạy hàm này như sau:

\begin{python}
system = make_system(beta, gamma)
S, I, R = run_simulation(system, update_func)
\end{python}

Ta sẽ dùng các hàm sau để vẽ đồ thị kết quả:

\begin{python}
def plot_results(S, I, R):
    plot(S, '--', label='Tổn thương')
    plot(I, '-', label='Nhiễm')
    plot(R, ':', label='Kháng')
    decorate(xlabel='T.gian (ngày)',
             ylabel='Tỉ lệ dân số')
\end{python}

\index{vẽ đồ thị}
\index{trang trí}

Và rồi chạy mã lệnh như sau:

\begin{python}
plot_results(S, I, R)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig01.pdf}}
\caption{Các chuỗi thời gian \py{S}, \py{I}, và \py{R} trong khoảng thời gian 98 ngày.}
\label{chap05-fig01}
\end{figure}

Hình~\ref{chap05-fig01} cho thấy kết quả. Lưu ý rằng sẽ mất khoảng 3 tuần (21 ngày) để sự bùng phát dịch bệnh diễn ra, và khoảng 6 tuần (42 ngày) trước khi nó đạt đỉnh. Tỉ lệ của dân số nhiễm bệnh chưa bao giờ quá cao, song nó sẽ tích lũy lại. Tổng cộng, có đến gần nửa dân số bị bệnh.


\section{Đến lượt dùng TimeFrame}
\label{timeframe}

Nếu số các biến trạng thái còn ít thì việc dùng những đối tượng  \py{TimeSeries} riêng biệt có thể không quá tệ. Nhưng cách tốt hơn là dùng một \py{TimeFrame}, vốn là một đối tượng khác được định nghĩa trong thư viện \py{modsim}.

\index{TimeFrame (đối tượng)}
\index{DataFrame (đối tượng)}

Một \py{TimeFrame} gần như giống hệt một \py{DataFrame}, vốn ta đã dùng ở Mục~\ref{worldpopdata}, nhưng có vài điểm mà tôi đã điều chỉnh để nó phù hợp với mục đích của ta.

Sau đây là phiên bản \py{run_simulation} được viết gọn hơn khi dùng \py{TimeFrame}:

\begin{python}
def run_simulation(system, update_func):
    frame = TimeFrame(columns=system.init.index)
    frame.row[system.t0] = system.init
    
    for t in linrange(system.t0, system.t_end):
        frame.row[t+1] = update_func(frame.row[t], system)
    
    return frame
\end{python}

Dòng đầu tiên tạo ra một \py{TimeFrame} trống với mỗi cột dành cho từng biến trạng thái. Tiếp theo, trước khi bắt đầu vòng lặp, ta lưu điều kiện ban đầu vào trong \py{TimeFrame} tại \py{t0}.  Dựa theo cách ta đã làm với đối tượng \py{TimeSeries}, có lẽ bạn muốn viết:

\begin{python}
frame[system.t0] = system.init
\end{python}

Nhưng khi dùng toán tử ngoặc vuông cho một \py{TimeFrame} hay \py{DataFrame}, nó sẽ lụa chọn một cột chứ không phải một hàng. Chẳng hạn, để chọn một cột, ta có thể viết:

\index{ngoặc vuông (toán tử)}
\index{toán tử~ngoặc vuông}

\begin{python}
frame['S']
\end{python}

Để chọn một hàng, ta phải dùng \py{row}, như thế này:

\index{row}

\begin{python}
frame.row[system.t0] = system.init
\end{python}

Vì giá trị ở vế phải là một \py{State}, phép gán đem khớp chỉ số của \py{State} với cột của \py{TimeFrame}; nghĩa là nó gán giá trị \py{S} từ \py{system.init} vào cột \py{S} của \py{frame}, và tương tự đối với \py{I} và \py{R}.

\index{phép gán}

Ta có thể dùng chính đặc điểm này để viết các vòng lặp một cách gọn gàng hơn, đem gán \py{State} nhận được từ \py{update_func} trực tiếp vào hàng tiếp theo của \py{frame}.
  
\index{biến hệ thống}

Sau cùng, ta trả lại \py{frame}. Ta có thể gọi phiên bản này của \py{run_simulation} như sau:

\begin{python}
results = run_simulation(system, update_func)
\end{python}

Và vẽ đồ thị kết quả như sau:

\begin{python}
plot_results(results.S, results.I, results.R)
\end{python}

Cũng giống với một \py{DataFrame}, ta có thể dùng toán tử dấu chấm để chọn các cột từ một \py{TimeFrame}.

\index{dấu chấm (toán tử)}
\index{toán tử!dấu chấm}

Trước khi tiếp tục, bạn có thể muốn đọc cuốn tập lệnh cho chương này, \py{chap11.ipynb}, và làm các bài tập.  Để biết về chỉ dẫn cách tải về và chạy mã lệnh, hãy xem Mục~\ref{code}.


\chapter{Optimization}
\label{chap12}

In the previous chapter I presented the SIR model of infectious disease and used it to model the Freshman Plague at Olin.  In this chapter we'll consider metrics intended to quantify the effect of the disease and interventions that might reduce the negative effects.


\section{Metrics}
\label{metrics2}

When we plot a time series, we get a view of everything that happened when the model ran, but often we want to boil it down to a few numbers that summarize the outcome.  These summary statistics are called {\bf metrics}, as we saw in Section~\ref{metrics}.

\index{metric}

In the SIR model, we might want to know the time until the peak of the outbreak, the number of people who are sick at the peak, the number of students who will still be sick at the end of the semester, or the total number of students who get sick at any point.

As an example, I will focus on the last one --- the total number of sick students --- and we will consider interventions intended to minimize it.

When a person gets infected, they move from \py{S} to \py{I}, so we can get the total number of infections by computing the difference in \py{S} at the beginning and the end:

\begin{python}
def calc_total_infected(results, system):
    return results.S[system.t0] - results.S[system.t_end]
\end{python}

In the notebook that accompanies this chapter, you will have a chance to write functions that compute other metrics.  Two functions you might find useful are \py{max} and \py{idxmax}.

\index{max}
\index{idxmax}
 
If you have a \py{Series} called \py{S}, you can compute the largest value of the series like this:

\begin{python}
largest_value = S.max()
\end{python}

And the label of the largest value like this:

\begin{python}
time_of_largest_value = S.idxmax()
\end{python}

If the \py{Series} is a \py{TimeSeries}, the label you get from \py{idxmax} is a time or date.  You can read more about these functions in the \py{Series} documentation at \url{http://modsimpy.com/series}.

\index{Series}


\section{Immunization}

Models like this are useful for testing ``what if?" scenarios.  As an example, we'll consider the effect of immunization.

\index{immunization}
\index{vaccine}
\index{Freshman Plague}

Suppose there is a vaccine that causes a student to become immune to the Freshman Plague without being infected.  How might you modify the model to capture this effect?

One option is to treat immunization as a short cut from susceptible to recovered without going through infectious.  We can implement this feature like this:

\begin{python}
def add_immunization(system, fraction):
    system.init.S -= fraction
    system.init.R += fraction
\end{python}

\py{add_immunization} moves the given fraction of the population from \py{S} to \py{R}.  If we assume that 10\% of students are vaccinated at the beginning of the semester, and the vaccine is 100\% effective, we can simulate the effect like this:

\begin{python}
system2 = make_system(beta, gamma)
add_immunization(system2, 0.1)
results2 = run_simulation(system2, update_func)
\end{python}

For comparison, we can run the same model without immunization and plot the results.  Figure~\ref{chap05-fig02} shows \py{S} as a function of time, with and without immunization.  

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig02.pdf}}
\caption{Time series for \py{S}, with and without immunization.}
\label{chap05-fig02}
\end{figure}

Without immunization, almost 47\% of the population gets infected at some point.  With 10\% immunization, only 31\% gets infected.  That's pretty good.

Now let's see what happens if we administer more vaccines.  This following function sweeps a range of immunization rates:

\index{sweep}

\begin{python}
def sweep_immunity(immunize_array):
    sweep = SweepSeries()

    for fraction in immunize_array:
        sir = make_system(beta, gamma)
        add_immunization(sir, fraction)
        results = run_simulation(sir, update_func)
        sweep[fraction] = calc_total_infected(results, sir)

    return sweep
\end{python}

The parameter of \py{sweep_immunity} is an array of immunization rates.  The result is a \py{SweepSeries} object that maps from each immunization rate to the resulting fraction of students ever infected.
  
\index{SweepSeries object}
\index{parameter sweep}

Figure~\ref{chap05-fig03} shows a plot of the \py{SweepSeries}.  Notice that the x-axis is the immunization rate, not time.

As the immunization rate increases, the number of infections drops steeply.  If 40\% of the students are immunized, fewer than 4\% get sick.  That's because immunization has two effects: it protects the people who get immunized (of course) but it also protects the rest of the population. 

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig03.pdf}}
\caption{Fraction of the population infected as a function of immunization rate.}
\label{chap05-fig03}
\end{figure} 

Reducing the number of ``susceptibles" and increasing the number of ``resistants" makes it harder for the disease to spread, because some fraction of contacts are wasted on people who cannot be infected.  This phenomenon is called {\bf herd immunity}, and it is an important element of public health (see \url{http://modsimpy.com/herd}).

\index{herd immunity}

The steepness of the curve in Figure~\ref{chap05-fig03} is a blessing and a curse.  It's a blessing because it means we don't have to immunize everyone, and vaccines can protect the ``herd" even if they are not 100\% effective.

But it's a curse because a small decrease in immunization can cause a big increase in infections.  In this example, if we drop from 80\% immunization to 60\%, that might not be too bad.  But if we drop from 40\% to 20\%, that would trigger a major outbreak, affecting more than 15\% of the population.  For a serious disease like measles, just to name one, that would be a public health catastrophe.

\index{measles}

One use of models like this is to demonstrate phenomena like herd immunity and to predict the effect of interventions like vaccination.  Another use is to evaluate alternatives and guide decision making.  We'll see an example in the next section.





\section{Hand washing}

Suppose you are the Dean of Student Life, and you have a budget of just \$1200 to combat the Freshman Plague.  You have two options for spending this money:

\begin{enumerate}

\item You can pay for vaccinations, at a rate of \$100 per dose.

\item You can spend money on a campaign to remind students to wash hands frequently.

\end{enumerate}

We have already seen how we can model the effect of vaccination.  Now let's think about the hand-washing campaign.  We'll have to answer two questions:

\begin{enumerate}

\item How should we incorporate the effect of hand washing in the model?

\item How should we quantify the effect of the money we spend on a hand-washing campaign?

\end{enumerate}

For the sake of simplicity, let's assume that we have data from a similar campaign at another school showing that a well-funded campaign can change student behavior enough to reduce the infection rate by 20\%.  

In terms of the model, hand washing has the effect of reducing \py{beta}.  That's not the only way we could incorporate the effect, but it seems reasonable and it's easy to implement.

Now we have to model the relationship between the money we spend and the effectiveness of the campaign.  Again, let's suppose we have data from another school that suggests:

\begin{itemize}

\item If we spend \$500 on posters, materials, and staff time, we can change student behavior in a way that decreases the effective value of \py{beta} by 10\%.

\item If we spend \$1000, the total decrease in \py{beta} is almost 20\%.

\item Above \$1000, additional spending has little additional benefit.

\end{itemize}

In the notebook for this chapter you will see how I used a logistic curve to fit this data.  The result is the following function, which takes spending as a parameter and returns \py{factor}, which is the factor by which \py{beta} is reduced:

\index{logistic curve}

\begin{python}
def compute_factor(spending):
    return logistic(spending, M=500, K=0.2, B=0.01)
\end{python}

I use \py{compute_factor} to write \py{add_hand_washing}, which takes a \py{System} object and a budget, and modifies \py{system.beta} to model the effect of hand washing:

\begin{python}
def add_hand_washing(system, spending):
    factor = compute_factor(spending)
    system.beta *= (1 - factor)
\end{python}

Now we can sweep a range of values for \py{spending} and use the simulation to compute the effect:

\begin{python}
def sweep_hand_washing(spending_array):
    sweep = SweepSeries()
    
    for spending in spending_array:
        sir = make_system(beta, gamma)
        add_hand_washing(sir, spending)
        results, run_simulation(sir, update_func)
        sweep[spending] = calc_total_infected(results, sir)
        
    return sweep
\end{python}

Here's how we run it:

\begin{python}
spending_array = linspace(0, 1200, 20)
infected_sweep = sweep_hand_washing(spending_array)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig05.pdf}}
\caption{Fraction of the population infected as a function of hand-washing campaign spending.}
\label{chap05-fig05}
\end{figure} 

Figure~\ref{chap05-fig05} shows the result.  Below \$200, the campaign has little effect.  At \$800 it has a substantial effect, reducing total infections from 46\% to 20\%.  Above \$800, the additional benefit is small.


\section{Optimization} 

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap05-fig06.pdf}}
\caption{Fraction of the population infected as a function of the number of doses.}
\label{chap05-fig06}
\end{figure} 

Let's put it all together.  With a fixed budget of \$1200, we have to decide how many doses of vaccine to buy and how much to spend on the hand-washing campaign.

\index{optimization}

Here are the parameters:

\begin{python}
num_students = 90
budget = 1200
price_per_dose = 100
max_doses = int(budget / price_per_dose)
\end{python}

The fraction \py{budget/price_per_dose} might not be an integer.  \py{int} is a built-in function that converts numbers to integers, rounding down.

We'll sweep the range of possible doses:

\begin{python}
dose_array = linrange(max_doses, endpoint=True)
\end{python}

In this example we call \py{linrange} with only one argument; it returns a NumPy array with the integers from 0 to \py{max_doses}.  With the argument \py{endpoint=True}, the result includes both endpoints.

\index{linrange}
\index{NumPy}
 \index{array}

Then we run the simulation for each element of \py{dose_array}:

\begin{python}
def sweep_doses(dose_array):
    sweep = SweepSeries()
    
    for doses in dose_array:
        fraction = doses / num_students
        spending = budget - doses * price_per_dose
        
        sir = make_system(beta, gamma)
        add_immunization(sir, fraction)
        add_hand_washing(sir, spending)
        
        run_simulation(sir, update_func)
        sweep[doses] = calc_total_infected(sir)

    return sweep
\end{python}

For each number of doses, we compute the fraction of students we can immunize, \py{fraction} and the remaining budget we can spend on the campaign, \py{spending}.  Then we run the simulation with those quantities and store the number of infections.

Figure~\ref{chap05-fig06} shows the result.  If we buy no doses of vaccine and spend the entire budget on the campaign, the fraction infected is around 19\%.  At 4 doses, we have \$800 left for the campaign, and this is the optimal point that minimizes the number of students who get sick.

As we increase the number of doses, we have to cut campaign spending, which turns out to make things worse.  But interestingly, when we get above 10 doses, the effect of herd immunity starts to kick in, and the number of sick students goes down again.

\index{herd immunity}

Before you go on, you might want to read the notebook for this chapter, \py{chap12.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.



\chapter{Sweeping two parameters}
\label{chap13}

In the previous chapters I presented an SIR model of infectious disease, specifically the Kermack-McKendrick model.  We extended the model to include vaccination and the effect of a hand-washing campaign, and used the extended model to allocate a limited budget optimally, that is, to minimize the number of infections.

\index{Kermack-McKendrick model}
\index{SIR model}

But we assumed that the parameters of the model, contact rate and recovery rate, were known.  In this chapter, we explore the behavior of the model as we vary these parameters, use analysis to understand these relationships better, and propose a method for using data to estimate parameters.


\section{Unpack}
\label{unpack}

Before we analyze the SIR model, I want to make a few improvements to the code.  In the previous chapter, we used this version of \py{run_simulation}:
\index{\py{run_simulation}}

\begin{python}
def run_simulation(system, update_func):
    frame = DataFrame(columns=system.init.index)
    frame.row[system.t0] = system.init
    
    for t in linrange(system.t0, system.t_end):
        frame.row[t+1] = update_func(frame.row[t], t, system)
    
    system.results = frame
\end{python}

Because we read so many variables from \py{system}, this code is a bit cluttered.  We can clean it up using \py{unpack}, which is defined in the \py{modsim} library.  \py{unpack} takes a \py{System} object as a parameter and makes the system variables available without using the dot operator.  So we can rewrite \py{run_simulation} like this:

\index{unpack}
\index{System object}

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t0] = init
    
    for t in linrange(t0, t_end):
        frame.row[t+1] = update_func(frame.row[t], t, system)
    
    system.results = frame
\end{python}

The variables you unpack should be treated as read-only.  Modifying them is not an error, but it might not have the behavior you expect.  In the notebook for this chapter, you can use \py{unpack} to clean up \py{update1}.


\section{Sweeping beta}

Recall that $\beta$ is the contact rate, which captures both the frequency of interaction between people and the fraction of those interactions that result in a new infection.  If $N$ is the size of the population and $s$ is the fraction that's susceptible, $s N$ is the number of susceptibles, $\beta s N$ is the number of contacts per day between susceptibles and other people, and $\beta s i N$ is the number of those contacts where the other person is infectious.
\index{parameter sweep}

As $\beta$ increases, we expect the total number of infections to increase.  To quantify that relationship, I'll create a range of values for $\beta$:

\begin{python}
beta_array = linspace(0.1, 1.1, 11)
\end{python}

Then run the simulation for each value and print the results.

\begin{python}
for beta in beta_array:
    sir = make_system(beta, gamma)
    run_simulation(sir, update1)
    print(sir.beta, calc_total_infected(sir))
\end{python}

We can wrap that code in a function and store the results in a \py{SweepSeries} object:
\index{SweepSeries object}

\begin{python}
def sweep_beta(beta_array, gamma):
    sweep = SweepSeries()
    for beta in beta_array:
        system = make_system(beta, gamma)
        run_simulation(system, update1)
        sweep[system.beta] = calc_total_infected(system)
    return sweep
\end{python}

Now we can run \py{sweep_beta} like this:

\begin{python}
infected_sweep = sweep_beta(beta_array, gamma)
\end{python}

And plot the results:

\begin{python}
label = 'gamma = ' + str(gamma)
plot(infected_sweep, label=label)
\end{python}

%TODO: figure out when to introduce strings

The first line uses string operations to assemble a label for the plotted line:
\index{string}

\begin{itemize}

\item When the \py{+} operator is applied to strings, it joins them end-to-end, which is called {\bf concatenation}. 
 
\index{concatenation}

\item The function \py{str} converts any type of object to a String representation.  In this case, \py{gamma} is a number, so we have to convert it to a string before trying to concatenate it.

\index{str function}

\end{itemize}

If the value of \py{gamma} is \py{0.25}, the value of \py{label} is the string \py{'gamma = 0.25'}.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap06-fig01.pdf}}
\caption{Total number of infected students as a function of the parameter \py{beta}, with \py{gamma = 0.25}.}
\label{chap06-fig01}
\end{figure}

Figure~\ref{chap06-fig01} shows the results.  Remember that this figure is a parameter sweep, not a time series, so the x-axis is the parameter \py{beta}, not time.  

When \py{beta} is small, the contact rate is low and the outbreak never really takes off; the total number of infected students is near zero.  As \py{beta} increases, it reaches a threshold near 0.3 where the fraction of infected students increases quickly.  When \py{beta} exceeds 0.5, more than 80\% of the population gets sick.


\section{Sweeping gamma}

Now let's see what that looks like for a few different values of \py{gamma}.  Again, we'll use \py{linspace} to make an array of values:

\index{linspace}

\begin{python}
gamma_array = linspace(0.1, 0.7, 4)
\end{python}

And run \py{sweep_beta} for each value of \py{gamma}:

\begin{python}
for gamma in gamma_array:
    infected_sweep = sweep_beta(beta_array, gamma)
    label = 'gamma = ' + str(gamma)
    plot(infected_sweep, label=label)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap06-fig02.pdf}}
\caption{Total number of infected students as a function of the parameter \py{beta}, for several values of \py{gamma}.}
\label{chap06-fig02}
\end{figure}

Figure~\ref{chap06-fig02} shows the results.  When \py{gamma} is low, the recovery rate is low, which means people are infectious longer.  In that case, even a low contact rate (\py{beta}) results in an epidemic.

When \py{gamma} is high, \py{beta} has to be even higher to get things going.  That observation suggests that there might be a relationship between \py{gamma} and \py{beta} that determines the outcome of the model.  In fact, there is.  In the next two chapters I demonstrate it by running simulations, then derive it by analysis.

Before you go on, you might want to read the notebook for this chapter, \py{chap13.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.


\chapter{Analysis} 
\label{chap14}

In the previous chapters we used simulation to predict the effect of an infectious disease in a susceptible population and to design interventions that would minimize the effect.

In this chapter we use analysis to investigate the relationship between the parameters, \py{beta} and \py{gamma}, and the outcome of the simulation.


\section{Nondimensionalization}
\label{nondim}

Before we go on, let's wrap the code from the previous chapter in a function:

\begin{python}
def sweep_parameters(beta_array, gamma_array):
    frame = SweepFrame(columns=gamma_array)
    for gamma in gamma_array:
        frame[gamma] = sweep_beta(beta_array, gamma)
    return frame
\end{python}

\py{sweep_parameters} takes as parameters two arrays: a range of values for \py{beta} and a range of values for \py{gamma}.

It creates a \py{SweepFrame} to store the results, with one column for each value of \py{gamma} and one row for each value of \py{beta}.  A \py{SweepFrame} is a kind of \py{DataFrame}, defined in the \py{modsim} library.  Its purpose is to store results from a two-dimensional parameter sweep.
\index{SweepFrame object}
\index{DataFrame object}

Each time through the loop, we run \py{sweep_beta}.  The result is a \py{SweepSeries} object with one element for each value of \py{gamma}.  The assignment

\begin{python}
frame[gamma] = sweep_beta(beta_array, gamma)
\end{python}

stores the values from the \py{SweepSeries} object as a new column in the \py{SweepFrame}, corresponding to the current value of \py{gamma}.

At the end, the \py{SweepFrame} stores the fraction of students infected for each pair of parameters, \py{beta} and \py{gamma}.

We can run \py{sweep_parameters} like this:

\begin{python}
frame = sweep_parameters(beta_array, gamma_array)
\end{python}

Then we can loop through the results like this:

\begin{python}
for gamma in frame.columns:
    series = frame[gamma]
    for beta in series.index:
        frac_infected = series[beta]
        print(beta, gamma, frac_infected)
\end{python}

This is the first example we've seen with one \py{for} loop inside another:

\begin{itemize}

\item Each time the outer loop runs, it selects a value of \py{gamma} from the columns of the \py{DataFrame} and extracts the corresponding column as a \py{Series}.
\index{Series}

\item Each time the inner loop runs, it selects a value of \py{beta} from the \py{Series} and selects the corresponding element, which is the fraction of student infected.

\end{itemize}  

In this example, \py{frame} has 4 columns, one for each value of \py{gamma}, and 11 rows, one for each value of \py{beta}.  So these loops print 44 lines, one for each pair of parameters.

Now let's think about possible relationships between \py{beta} and \py{gamma}:

\begin{itemize}

\item When \py{beta} exceeds \py{gamma}, that means there are more contacts (that is, potential infections) than recoveries.  The difference between \py{beta} and \py{gamma} might be called the ``excess contact rate", in units of contacts per day.

\item As an alternative, we might consider the ratio \py{beta/gamma}, which is the number of contacts per recovery.  Because the numerator and denominator are in the same units, this ratio is {\bf dimensionless}, which means it has no units.
\index{dimensionless}

\end{itemize}

Describing physical systems using dimensionless parameters is often a useful move in the modeling and simulation game.  It is so useful, in fact, that it has a name: {\bf nondimensionalization} (see \url{http://modsimpy.com/nondim}).

\index{nondimensionalization}

So we'll try the second option first.  In the notebook for this chapter, you can explore the first option as an exercise.

The following function wraps the previous loops and plots the fraction infected as a function of the ratio \py{beta/gamma}:

\begin{python}
def plot_sweep_frame(frame):
    for gamma in frame.columns:
        series = frame[gamma]
        for beta in series.index:
            frac_infected = series[beta]
            plot(beta/gamma, frac_infected, 'ro')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap06-fig03.pdf}}
\caption{Total fraction infected as a function of contact number.}
\label{chap06-fig03}
\end{figure}

Figure~\ref{chap06-fig03} shows that the results fall neatly on a single curve, at least approximately.  That means that we can predict the fraction of students who will be infected based on a single parameter, the ratio \py{beta/gamma}.  We don't need to know the values of \py{beta} and \py{gamma} separately.


\section{Contact number}
\label{contact}

Recall that the number of new infections in a given day is $\beta s i N$, and the number of recoveries is $\gamma i N$.  If we divide these quantities, the result is $\beta s / \gamma$, which is the number of new infections per recovery (as a fraction of the population).

\index{contact number}
\index{basic reproduction number}

When a new disease is introduced to a susceptible population, $s$ is approximately 1, so the number of people infected by each sick person is $\beta / \gamma$.  This ratio is called the ``contact number" or ``basic reproduction number" (see \url{http://modsimpy.com/contact}).  By convention it is usually denoted $R_0$, but in the context of an SIR model, this notation is confusing, so we'll use $c$ instead.

The results in the previous section suggest that there is a relationship between $c$ and the total number of infections.  We can derive this relationship by analyzing the differential equations from Section~\ref{sireqn}:
%
\begin{align*}
\frac{ds}{dt} &= -\beta s i \\
\frac{di}{dt} &= \beta s i - \gamma i\\
\frac{dr}{dt} &= \gamma i
\end{align*}
%
In the same way we divided the contact rate by the infection rate to get the dimensionless quantity $c$, now we'll divide $di/dt$ by $ds/dt$ to get a ratio of rates:
%
\[ \frac{di}{ds} = -1 + \frac{1}{cs} \]
%
Dividing one differential equation by another is not an obvious move, but in this case it is useful because it gives us a relationship between $i$, $s$ and $c$ that does not depend on time.  From that relationship, we can derive an equation that relates $c$ to the final value of $S$.  In theory, this equation makes it possible to infer $c$ by observing the course of an epidemic.

Here's how the derivation goes.  We multiply both sides of the previous equation by $ds$:
%
\[ di = \left( -1 + \frac{1}{cs} \right) ds \]
%
And then integrate both sides:
%
\[ i = -s + \frac{1}{c} \log s + q \]
%
where $q$ is a constant of integration.  Rearranging terms yields:
%
\[ q = i + s - \frac{1}{c} \log s \]
%
Now let's see if we can figure out what $q$ is.  At the beginning of an epidemic, if the fraction infected is small and nearly everyone is susceptible, we can use the approximations $i(0) = 0$ and $s(0) = 1$ to compute $q$:
%
\[ q = 0 + 1 + \frac{1}{c} \log 1 \]
%
Since $\log 1 = 0$, we get $q = 1$.
\index{integration}
\index{constant of integration}

\newcommand{\sinf}{s_{\infty}}

Now, at the end of the epidemic, let's assume that $i(\infty) = 0$, and $s(\infty)$ is an unknown quantity, $\sinf$.  Now we have:
%
\[ q = 1 = 0 + \sinf - \frac{1}{c} \log \sinf \]
%
Solving for $c$, we get
%
\[ c = \frac{\log \sinf}{\sinf - 1} \]
%
By relating $c$ and $\sinf$, this equation makes it possible to estimate $c$ based on data, and possibly predict the behavior of future epidemics.

\section{Analysis and simulation}

Let's compare this analytic result to the results from simulation.
I'll create an array of values for $\sinf$
\index{linspace}

\begin{python}
s_inf_array = linspace(0.0001, 0.9999, 31)
\end{python}

And compute the corresponding values of $c$:

\begin{python}
c_array = log(s_inf_array) / (s_inf_array - 1)
\end{python}

To get the total infected, we compute the difference between $s(0)$ and $s(\infty)$, then store the results in a \py{Series}:
\index{array}
\index{series}

\begin{python}
frac_infected = 1 - s_inf_array
frac_infected_series = Series(frac_infected, index=c_array)
\end{python}

Recall from Section~\ref{dataframe} that a \py{Series} object contains an index and a corresponding sequence of values.  In this case, the index is \py{c_array} and the values are from \py{frac_infected}.

Now we can plot the results:

\begin{python}
plot(frac_infected_series)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap06-fig04.pdf}}
\caption{Total fraction infected as a function of contact number, showing results from simulation and analysis.}
\label{chap06-fig04}
\end{figure}

Figure~\ref{chap06-fig04} compares the analytic results from this section with the simulation results from Section~\ref{nondim}.  Over most of the range they are consistent with each other, with one discrepancy: when the contact number is less than 1, analysis indicates there should be no infections; but in the simulations a small part of the population is affected even when $c<1$.
\index{analysis}

The reason for the discrepancy is that the simulation divides time into a discrete series of days, whereas the analysis treats time as a continuous quantity.  In other words, the two methods are actually based on different models.  So which model is better?

Probably neither.  When the contact number is small, the early progress of the epidemic depends on details of the scenario.  If we are lucky, the original infected person, ``patient zero",  infects no one and there is no epidemic.  If we are unlucky, patient zero might have a large number of close friends, or might work in the dining hall (and fail to observe safe food handling procedures).
\index{patient zero}

For contact numbers near or less than 1, we might need a more detailed model.  But for higher contact numbers the SIR model might be good enough.

Figure~\ref{chap06-fig04} shows that if we know the contact number, we can compute the fraction infected.  But we can also read the figure the other way; that is, at the end of an epidemic, if we can estimate the fraction of the population that was ever infected, we can use it to estimate the contact number.

Well, at least in theory.  In practice, it might not work very well, because of the shape of the curve.  When the contact number is near 2, the curve is quite steep, which means that small changes in $c$ yield big changes in the number of infections.  If we observe that the total fraction infected is anywhere from 20\% to 80\%, we would conclude that $c$ is near 2.

On the other hand, for larger contact numbers, nearly the entire population is infected, so the curve is quite flat.  In that case we would not be able to estimate $c$ precisely, because any value greater than 3 would yield effectively the same results.  Fortunately, this is unlikely to happen in the real world; very few epidemics affect anything like 90\% of the population.

So the SIR model has limitations; nevertheless, it provides insight into the behavior of infectious disease, especially the phenomenon of herd resistance.  As we saw in the previous chapter, if we know the parameters of the model, we can use it to evaluate possible interventions.  And as we saw in this chapter, we might be able to use data from earlier outbreaks to estimate the parameters.

Before you go on, you might want to read the notebook for this chapter, \py{chap14.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.



%\part{Modeling thermal systems}



\chapter{Heat}
\label{chap15}

So far the systems we have studied have been physical in the sense that they exist in the world, but they have not been physics, in the sense of what physics classes are usually about.  In the next few chapters, we'll do some physics, starting with {\bf thermal systems}, that is, systems where the temperature of objects changes as heat transfers from one to another.

\index{thermal system}

\section{The coffee cooling problem}

The coffee cooling problem was discussed by Jearl Walker in {\it Scientific American} in 1977\footnote{Walker, ``The Amateur Scientist", {\it Scientific American}, Volume 237, Issue 5, November 1977.}; since then it has become a standard example of modeling and simulation.

\index{coffee cooling problem}
\index{Walker, Jearl}

Here is my version of the problem:

\begin{quote}
Suppose I stop on the way to work to pick up a cup of coffee, which I take with milk.  Assuming that I want the coffee to be as hot as possible when I arrive at work, should I add the milk at the coffee shop, wait until I get to work, or add the milk at some point in between?
\end{quote}

To help answer this question, I made a trial run with the milk and coffee in separate containers and took some measurements\footnote{This is fiction.  I usually drink tea and bike to work.}:

\begin{itemize}

\item When served, the temperature of the coffee is \SI{90}{\celsius}.  The volume is \SI{300}{mL}.

\item The milk is at an initial temperature of \SI{5}{\celsius}, and I take about \SI{50}{mL}.

\item The ambient temperature in my car is \SI{22}{\celsius}.

\item The coffee is served in a well insulated cup.  When I arrive at work after 30 minutes, the temperature of the coffee has fallen to \SI{70}{\celsius}.

\item The milk container is not as well insulated.  After 15 minutes, it warms up to \SI{20}{\celsius}, nearly the ambient temperature.

\end{itemize}

To use this data and answer the question, we have to know something about temperature and heat, and we have to make some modeling decisions.


\section{Temperature and heat}

To understand how coffee cools (and milk warms), we need a model of temperature and heat.  {\bf Temperature} is a property of an object or a system; in SI units it is measured in degrees Celsius (\si{\celsius}).  Temperature quantifies how hot or cold the object is, which is related to the average velocity of the particles that make up the object.

\index{temperature}

When particles in a hot object contact particles in a cold object, the hot object gets cooler and the cold object gets warmer as energy is transferred from one to the other.  The transferred energy is called {\bf heat}; in SI units it is measured in joules (\si{\joule}).

\index{heat}

Heat is related to temperature by the following equation (see \url{http://modsimpy.com/thermass}):
%
\[ Q = C \Delta T \]
%
where $Q$ is the amount of heat transferred to an object, $\Delta T$ is resulting change in temperature, and $C$ is the {\bf thermal mass} of the object, which quantifies how much energy it takes to heat or cool it.  In SI units, thermal mass is measured in joules per degree Celsius (\si{\joule\per\celsius}).

\index{thermal mass}

For objects made primarily from one material, thermal mass can be computed like this:
%
\[ C = m c_p \]
%
where $m$ is the mass of the object and $c_p$ is the {\bf specific heat capacity} of the material (see \url{http://modsimpy.com/specheat}).

\index{specific heat capacity}

We can use these equations to estimate the thermal mass of a cup of coffee.  The specific heat capacity of coffee is probably close to that of water, which is \SI{4.2}{\joule\per\gram\per\celsius}.  Assuming that the density of coffee is close to that of water, which is \SI{1}{\gram\per\milli\liter}, the mass of \SI{300}{\milli\liter} of coffee is \SI{300}{\gram}, and the thermal mass is \SI{1260}{\joule\per\celsius}.

\index{density}

So when a cup of coffee cools from \SI{90}{\celsius} to \SI{70}{\celsius}, the change in temperature, $\Delta T$ is \SI{20}{\celsius}, which means that \SI{25200}{\joule} of heat energy was transferred from the coffee to the surrounding environment (the cup holder and air in my car).

To give you a sense of how much energy that is, if you were able to harness all of that heat to do work (which you cannot\footnote{See \url{http://modsimpy.com/thermo}.}), you could use it to lift a cup of coffee from sea level to \SI{8571}{\meter}, just shy of the height of Mount Everest, \SI{8848}{\meter}.

\index{Mount Everest}

Assuming that the cup has less mass than the coffee, and is made from a material with lower specific heat, we can ignore the thermal mass of the cup.
For a cup with substantial thermal mass, we might consider a model that computes the temperature of coffee and cup separately.


\section{Heat transfer}

In a situation like the coffee cooling problem, there are three ways heat transfers from one object to another (see \url{http://modsimpy.com/transfer}):

\index{heat transfer}
\index{conduction}
\index{convection}
\index{radiation}

\begin{itemize}

\item Conduction: When objects at different temperatures come into contact, the faster-moving particles of the higher-temperature object transfer kinetic energy to the slower-moving particles of the lower-temperature object.

\item Convection: When particles in a gas or liquid flow from place to place, they carry heat energy with them.  Fluid flows can be caused by external action, like stirring, or by internal differences in temperature.  For example, you might have heard that hot air rises, which is a form of ``natural convection".

\index{fluid flow}

\item Radiation: As the particles in an object move due to thermal energy, they emit electromagnetic radiation.  The energy carried by this radiation depends on the object's temperature and surface properties (see \url{http://modsimpy.com/thermrad}).

\end{itemize}

For objects like coffee in a car, the effect of radiation is much smaller than 
the effects of conduction and convection, so we will ignore it.

Convection can be a complex topic, since it often depends on details of fluid flow in three dimensions.  But for this problem we will be able to get away with a simple model called ``Newton's law of cooling".

\index{Newton's law of cooling}

\section{Newton's law of cooling}

Newton's law of cooling asserts that the temperature rate of change for an object is proportional to the difference in temperature between the object and the surrounding environment:
%
\[ \frac{dT}{dt} = -r (T - T_{env}) \]
%
where $T$, the temperature of the object, is a function of time, $t$; $T_{env}$ is the temperature of the environment, and $r$ is a constant that characterizes how quickly heat is transferred between the system and the environment.

Newton's so-called ``law" is really a model in the sense that it is approximately true in some conditions, only roughly true in others, and not at all true in others.

For example, if the primary mechanism of heat transfer is conduction, Newton's law is ``true", which is to say that $r$ is constant over a wide range of temperatures.  And sometimes we can estimate $r$ based on the material properties and shape of the object.

When convection contributes a non-negligible fraction of heat transfer, $r$  depends on temperature, but Newton's law is often accurate enough, at least over a narrow range of temperatures.  In this case $r$ usually has to be estimated experimentally, since it depends on details of surface shape, air flow, evaporation, etc.

When radiation makes up a substantial part of heat transfer, Newton's law is not a good model at all.  This is the case for objects in space or in a vacuum, and for objects at high temperatures (more than a few hundred degrees Celsius, say).

\index{radiation}

However, for a situation like the coffee cooling problem, we expect Newton's model to be quite good.


\section{Implementation}
\label{coffee_impl}

To get started, let's forget about the milk temporarily and focus on the coffee.  I'll create a \py{State} object to represent the initial temperature:

\begin{python}
init = State(T=90)
\end{python}

And a \py{System} object to contain the parameters of the system:

\index{State object}
\index{System object}

\begin{python}
coffee = System(init=init,
                volume=300,
                r=0.01,
                T_env=22,
                t_0=0, 
                t_end=30,
                dt=1)
\end{python}

The values of \py{volume}, \py{T_env}, and \py{t_end} come from the statement of the problem.  I chose the value of \py{r} arbitrarily for now; we will figure out how to estimate it soon.

\index{time step}

\py{dt} is the time step we use to simulate the cooling process.
Strictly speaking, Newton's law is a differential equation, but over a short period of time we can approximate it with a difference equation:
%
\[ \Delta T = -r (T - T_{env}) dt \]
%
where $dt$ is a small time step and $\Delta T$ is the change in temperature during that time step.

Note: I use $\Delta T$ to denote a change in temperature over time, but in the context of heat transfer, you might also see $\Delta T$ used to denote the difference in temperature between an object and its environment, $T - T_{env}$.  To minimize confusion, I avoid this second use.

Now we can write an update function:

\index{unpack}

\begin{python}
def update_func(state, t, system):
    unpack(system)
    
    T = state.T
    T += -r * (T - T_env) * dt

    return State(T=T)
\end{python}

Like previous update functions, this one takes a \py{State} object, a time, and a \py{System} object.

Now if we run 

\begin{python}
update_func(init, 0, coffee)
\end{python}

we see that the temperature after one minute is \SI{89.3}{\celsius}, so the temperature drops by about \SI{0.7}{\celsius\per\minute}, at least for this value of \py{r}.

Here's a version of \py{run_simulation} that simulates a series of time steps from \py{t_0} to \py{t_end}:

\index{time step}
\index{\py{run_simulation}}
\index{unpack}

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t_0] = init
    ts = linrange(t_0, t_end, dt)
    
    for t in ts:
        frame.row[t+dt] = update_func(frame.row[t], t, system)
        
    # store the final temperature in T_final
    system.T_final = get_last_value(frame.T)
    
    return frame
\end{python}

This function is similar to previous versions of \py{run_simulation}.

One difference is that it uses \py{linrange} to make an array of values from \py{t_0} to \py{t_end} with time step \py{dt}.  The result does not include \py{t_end}, so the last value in the array is \py{t_end-dt}.

\index{linrange}
\index{NumPy}
\index{array}

Also, it stores the final temperature as a system variable, \py{T_final}.

We can run it like this:

\begin{python}
results = run_simulation(coffee, update_func)
\end{python}

The result is a \py{TimeFrame} object with one row per time step and just one column, \py{T}.  The temperature after 30 minutes is \SI{72.3}{\celsius}, which is a little higher than stated in the problem, \SI{70}{\celsius}.  We can adjust \py{r} and find the right value by trial and error, but we'll see a better way in the next chapter.

\index{time step}
\index{TimeFrame object}

First I want to wrap what we have so far in a function:

\begin{python}
def make_system(T_init=90, r=0.01, volume=300, t_end=30):
    init = State(T=T_init)
    
    return System(init=init,
                  T_final=T_init,
                  volume=volume,
                  r=r,
                  T_env=22, 
                  t_0=0,
                  t_end=t_end,
                  dt=1)
\end{python}

\py{make_system} takes the system parameters and packs them into a \py{System} object.  Now we can simulate the system like this:

\index{\py{make_system}}

\begin{python}
coffee = make_system(T_init=90, r=0.01, 
                     volume=300, t_end=30)
results = run_simulation(coffee, update_func)
\end{python}

Before you go on, you might want to read the notebook for this chapter, \py{chap15.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.


\chapter{Mixing}
\label{chap16}

In the previous chapter we wrote a simulation of a cooling cup of coffee.  Given the initial temperature of the coffee, the temperature of the atmosphere, and the rate parameter, \py{r}, we can predict how the temperature of the coffee will change over time.

In general, we don't know the value of \py{r}, but we can use measurements to estimate it.  Given an initial temperature, a final temperature, and the time in between, we can find \py{r} by trial and error.

In this chapter, we'll see a better way to find \py{r}, using a SciPy function called \py{fsolve}.

And the we'll get back to solving the coffee cooling problem.

\section{Using fsolve}
\label{fsolve}

SciPy provides a method called \py{fsolve} that finds the roots of non-linear equations.  As a simple example, suppose you want to find the roots of the polynomial
%
\[ f(x) = (x - 1)(x - 2)(x - 3) \]
%
where {\bf root} means a value of $x$ that makes $f(x)=0$.  Because of the way I wrote the polynomial, we can see that if $x=1$, the first factor is 0; if $x=2$, the second factor is 0; and if $x=3$, the third factor is 0, so those are the roots.

\index{\py{fsolve}}
\index{root}

But usually it's not that easy.  In that case \py{fsolve} can help.  First, we have to write a function that evaluates $f$:

\begin{python}
def func(x):
    return (x-1) * (x-2) * (x-3)
\end{python}

Now we call \py{fsolve} like this:

\begin{python}
fsolve(func, x0=0)
\end{python}

The first argument is the function whose roots we want.  The second argument, \py{x0}, is an initial guess about where a root might be.  Generally, the closer the initial guess is to an actual root, the faster \py{fsolve} runs.  In this case, with the initial guess \py{x0=0}, the result is 1.

Often \py{fsolve} finds the root that's closest to the initial guess.  In this example, when \py{x0=1.9}, \py{fsolve} returns 2, and when \py{x0=2.9}, \py{fsolve} returns 3.  But this behavior can be unpredictable; with \py{x0=1.5}, \py{fsolve} returns 3.

So how can we use \py{fsolve} to estimate \py{r}?  

What we want is the value of \py{r} that yields a final temperature of \SI{70}{\celsius}.  To work with \py{fsolve}, we need a function that takes \py{r} as a parameter and returns the difference between the final temperature and the goal:

\begin{python}
def error_func1(r):
    system = make_system(r=r)
    results = run_simulation(system, update)
    return system.T_final - 70
\end{python}

I call a function like this an ``error function" because it returns the difference between what we got and what we wanted, that is, the error.  When we find the right value of \py{r}, this error will be 0.

\index{error function}
\index{function!error}

We can test \py{error_func1} like this, using our initial guess for \py{r}:

\begin{python}
error_func1(r=0.01)
\end{python}

The result is an error of \SI{2.3}{\celsius}, because the final temperature with this value of \py{r} is too high.

Now we can call \py{fsolve} like this:

\begin{python}
solution = fsolve(error_func1, 0.01)
r_coffee = solution[0]
\end{python}

The return value from \py{fsolve} is an array with a single element, which is the root \py{fsolve} found.  In this example, \py{r_coffee} turns out to be about \py{0.012}, in units of \si{\per\minute}.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap07-fig01.pdf}}
\caption{Temperature of the coffee and milk over time.}
\label{chap07-fig01}
\end{figure}

As one of the exercises for this chapter, you will use the same process to estimate \py{r_milk}.  

With the correct values of \py{r_coffee} and \py{r_milk}, the simulation results should look like Figure~\ref{chap07-fig01}, which shows the temperature of the coffee and milk over time.


\section{Mixing liquids}

When we mix two liquids, the temperature of the mixture depends on the temperatures of the ingredients, but it might not be obvious how to compute it.

\index{mixing}

Assuming there are no chemical reactions that either produce or consume heat, the total thermal energy of the system is the same before and after mixing; in other words, thermal energy is {\bf conserved}.

\index{conservation of energy}

If the temperature of the first liquid is $T_1$, the temperature of the second liquid is $T_2$, and the final temperature of the mixture is $T$, the heat transfer into the first liquid is $C_1 (T - T_1)$ and the heat transfer into the second liquid is $C_2 (T - T_2)$, where $C_1$ and $C_2$ are the thermal masses of the liquids.

In order to conserve energy, these heat transfers must add up to 0:
%
\[ C_1 (T - T_1) + C_2 (T - T_2) = 0 \]
%
We can solve this equation for T:
%
\[ T = \frac{C_1 T_1 + C_2 T_2}{C_1 + C_2} \]
%
For the coffee cooling problem, we have the volume of each liquid; if we also know the density, $\rho$, and the specific heat capacity, $c_p$, we can compute thermal mass:
%
\[ C = \rho V c_p \]
%
If we assume that the density and specific heat of the milk and coffee are equal, they drop out of the equation, and we can write:
%
\[ T = \frac{V_1 T_1 + V_2 T_2}{V_1 + V_2} \]
%
where $V_1$ and $V_2$ are the volumes of the liquids.  As an exercise, you can look up the density and specific heat of milk to see how good this approximation is.

\index{volume}
\index{density}
\index{specific heat}

The following function takes two \py{System} objects that represent the coffee and milk, and creates a new \py{System} to represent the mixture:

\begin{python}
def mix(s1, s2):
    assert s1.t_end == s2.t_end
    
    V_mix = s1.volume + s2.volume
    
    T_mix = (s1.volume * s1.T_final + 
             s2.volume * s2.T_final) / V_mix
    
    mixture = make_system(T_init=T_mix,
                          t_end=0,
                          r=s1.r,
                          volume=V_mix)
    
    return mixture
\end{python}

The first line is an \py{assert} statement, which is a way of checking for errors.  It compares \py{t_end} for the two systems to confirm that they have been cooling for the same time.  If not, \py{assert} displays an error message and stops the program.

\index{assert statement}
\index{statement!assert}

The next two statements compute the total volume of the mixture and its temperature.  Finally, \py{mix} makes a new \py{System} object and returns it.

This function uses the value of \py{r} from \py{s1} as the value of \py{r} for the mixture.  If \py{s1} represents the coffee, and we are adding the milk to the coffee, this is probably a reasonable choice.  On the other hand, when we increase the amount of liquid in the coffee cup, that might change \py{r}.  So this is an assumption we might want to revisit.


\section{Mix first or last?}

Now we have everything we need to solve the problem.  First I'll create objects to represent the coffee and cream, and run for 30 minutes.

\begin{python}
coffee = make_system(T_init=90, t_end=30, 
                     r=r_coffee, volume=300)
coffee_results = run_simulation(coffee, update_func)

milk = make_system(T_init=5, t_end=30, 
                   r=r_milk, volume=50)
milk_results = run_simulation(milk, update_func)
\end{python}

The final temperatures, before mixing, are \SI{70}{\celsius} and \SI{21.8}{\celsius}.  Then I'll mix them:

\begin{python}
mix_last = mix(coffee, milk)
\end{python}

After mixing, the temperature is \SI{63.1}{\celsius}, which is still warm enough to be enjoyable.  Would we do any better if we added the milk first?

To find out, I'll create new objects for the coffee and milk:

\begin{python}
coffee = make_system(T_init=90, r=r_coffee, 
                     volume=300, t_end=30)
milk = make_system(T_init=5, r=r_milk, 
                   volume=50, t_end=30)
\end{python}

Then mix them and simulate 30 minutes:

\begin{python}
mix_first = mix(coffee, milk)
results = run_simulation(mix_first, update_func)
\end{python}

The final temperature is only \SI{61.4}{\celsius}.  So it looks like adding the milk at the end is better, by about \SI{1.7}{\celsius}.  But is that the best we can do?


\section{Optimization}

Adding the milk after 30 minutes is better than adding immediately, but maybe there's something in between that's even better.  To find out, I'll use the following function, which takes \py{t_add} as a parameter:

\index{optimization}

\begin{python}
def run_and_mix(t_add, t_total=30):
    coffee = make_system(T_init=90, t_end=t_add, 
                         r=r_coffee, volume=300)
    coffee_results = run_simulation(coffee, update_func)

    milk = make_system(T_init=5, t_end=t_add, 
                       r=r_milk, volume=50)
    milk_results = run_simulation(milk, update_func)
    
    mixture = mix(coffee, milk)
    mixture.t_end = t_total - t_add
    results = run_simulation(mixture, update_func)

    return mixture.T_final
\end{python}

When \py{t_add=0}, we add the milk immediately; when \py{t_add=30}, we add it at the end.  Now we can sweep the range of values in between:

\begin{python}
sweep = SweepSeries()
for t_add in linspace(0, 30, 11):
    sweep[t_add] = run_and_mix(t_add, 30)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap07-fig02.pdf}}
\caption{Final temperature as a function of the time the milk is added.}
\label{chap07-fig02}
\end{figure}

Figure~\ref{chap07-fig02} shows the result.  Again, note that this is a parameter sweep, not a time series.  The x-axis is the time when we add the milk, not the index of a \py{TimeSeries}.

The final temperature is maximized when \py{t_add=30}, so adding the milk at the end is optimal.

In the notebook for this chapter you will have a chance to explore this solution and try some variations.  For example, suppose the coffee shop won't let me take milk in a separate container, but I keep a bottle of milk in the refrigerator at my office.  In that case is it better to add the milk at the coffee shop, or wait until I get to the office?


\section{Analysis}

Simulating Newton's law of cooling is almost silly, because we can solve the differential equation analytically.  If
%
\[ \frac{dT}{dt} = -r (T - T_{env}) \]
%
the general solution is
%
\[ T{\left (t \right )} = C_{1} \exp(-r t) + T_{env} \]
%
and the particular solution where $T(0) = T_{init}$ is
%
\[ T_{env} + \left(- T_{env} + T_{init}\right) \exp(-r t) \]
%
You can see how I got this solution using SymPy in \py{chap16sympy.ipynb} in the repository for this book.  If you would like to see it done by hand, you can watch this video: \url{http://modsimpy.com/khan3}.

\index{analysis}
\index{SymPy}

Now we can use the observed data to estimate the parameter $r$.  If we observe $T(t_{end}) = T_{end}$, we can plug $t_{end}$ and $T_{end}$ into the particular solution and solve for $r$.  The result is:
%
\[ r = \frac{1}{t_{end}} \log{\left (\frac{T_{init} - T_{env}}{T_{end} - T_{env}} \right )} \]
%
Plugging in $t_{end}=30$ and $T_{end}=70$ (and again with $T_{init}=90$ and $T_{env}=22$), the estimate for $r$ is 0.0116.

We can use the following function to compute the time series:

\index{unpack}

\begin{python}
def run_analysis(system):
    unpack(system)
    
    T_init = init.T    
    ts = linrange(t_0, t_end, dt, endpoint=True)
    
    T_array = T_env + (T_init - T_env) * exp(-r * ts)
    
    results = TimeFrame(T_array, index=ts, columns=['T'])
    system.T_final = get_last_value(results.T)

    return results
\end{python}

This function is similar to \py{run_simulation}; it takes a \py{System} as a parameter and returns a \py{TimeFrame} as a result.

Because \py{linrange} returns a NumPy array, \py{T_array} is also a NumPy array.  To be consistent with \py{run_simulation}, we have to put it into a \py{TimeFrame}.
    
We can run it like this:
\index{\py{run_analysis}}

\begin{python}
r_coffee2 = 0.0116
coffee2 = make_system(T_init=90, r=r_coffee2, 
                      volume=300, t_end=30)
results = run_analysis(coffee2)
\end{python}

The final temperature is \SI{70}{\celsius}, as it should be.  In fact, the results are identical to what we got by simulation, with a small difference due to round off.

Before you go on, you might want to read the notebook for this chapter, \py{chap16.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.


%%\part{Pharmacokinetics}

\chapter{Pharmacokinetics}
\label{chap17}

{\bf Pharmacokinetics} is the study of how drugs and other substances move around the body, react, and are eliminated.  In this chapter, we implement one of the most widely used pharmacokinetic models: the so-called {\bf minimal model} of glucose and insulin in the blood stream.

\index{pharmacokinetics}

We will use this model to fit data collected from a patient, and use the parameters of the fitted model to quantify the patient's ability to produce insulin and process glucose.

\index{glucose}
\index{insulin}

My presentation in this chapter follows Bergman (2005) ``Minimal Model" (abstract at \url{http://modsimpy.com/bergman},
PDF at \url{http://modsimpy.com/minmod}).



\section{The glucose-insulin system}

{\bf Glucose} is a form of sugar that circulates in the blood of animals; it is used as fuel for muscles, the brain, and other organs.  The concentration of blood sugar is controlled by the hormone system, and especially by {\bf insulin}, which is produced by the pancreas and has the effect of reducing blood sugar.

\index{pancreas}

In people with normal pancreatic function, the hormone system maintains {\bf homeostasis}; that is, it keeps the concentration of blood sugar in a range that is neither too high or too low.

But if the pancreas does not produce enough insulin, or if the cells that should respond to insulin become insensitive, blood sugar can become elevated, a condition called {\bf hyperglycemia}.  Long term, severe hyperglycemia is the defining symptom of {\bf diabetes mellitus}, a serious disease that affects almost 10\% of the population in the U.S. (see \url{http://modsimpy.com/cdc}).

\index{hyperglycemia}
\index{diabetes}

One of the most-used tests for hyperglycemia and diabetes is the frequently sampled intravenous glucose tolerance test (FSIGT), in which glucose is injected into the blood stream of a fasting subject (someone who has not eaten recently); then blood samples are collected at intervals of 2--10 minutes for 3 hours.  The samples are analyzed to measure the concentrations of glucose and insulin.

\index{FSIGT}

By analyzing these measurements, we can estimate several parameters of the subject's response; the most important is a parameter denoted $S_I$, which quantifies the effect of insulin on the rate of reduction in blood sugar.


\section{The glucose minimal model}

The ``minimal model" was proposed by Bergman, Ider, Bowden, and Cobelli\footnote{Bergman RN, Ider YZ, Bowden CR, Cobelli C., ``Quantitative estimation of insulin sensitivity", Am J Physiol. 1979 Jun;236(6):E667-77.  Abstract at \url{http://modsimpy.com/insulin}.}.
It consists of two parts: the glucose model and the insulin model.  I will present an implementation of the glucose model; as a case study, you will have the chance to implement the insulin model.

\index{minimal model}

The original model was developed in the 1970s; since then, many variations and extensions have been proposed.  Bergman's comments on the development of the model provide insight into their process:

\begin{quote}
We applied the principle of Occam's Razor, i.e.~by asking
what was the simplest model based upon known physiology
that could account for the insulin-glucose relationship
revealed in the data. Such a model must be simple
enough to account totally for the measured glucose (given
the insulin input), yet it must be possible, using mathematical
techniques, to estimate all the characteristic parameters
of the model from a single data set (thus avoiding
unverifiable assumptions).
\end{quote}

The most useful models are the ones that achieve this balance: including enough realism to capture the essential features of the system without too much complexity to be practical.  In this case the practical limit is the ability to estimate the parameters of the model using data, and to interpret the parameters meaningfully.

\index{Occam's Razor}

Bergman discusses the features he and his colleagues thought were essential:

\begin{quote}
(1) Glucose, once elevated by injection, returns to basal level due to
two effects: the effect of glucose itself to normalize its own
concentration [...] as well as the catalytic effect of insulin to allow
glucose to self-normalize (2) Also, we discovered
that the effect of insulin on net glucose disappearance
must be sluggish --- that is, that insulin acts slowly because
insulin must first move from plasma to a remote compartment [...] to exert its action on glucose disposal.
\end{quote}

To paraphrase the second point, the effect of insulin on glucose disposal, as seen in the data, happens more slowly than we would expect if it depended primarily on the the concentration of insulin in the blood.  Bergman's group hypothesized that insulin must move, relatively slowly, from the blood to a ``remote compartment" where it has its effect.

\index{compartment model}

At the time, the remote compartment was a modeling abstraction that might, or might not, reflect something physical.  Later, according to Bergman, it was ``shown to be interstitial fluid", that is, the fluid that surrounds tissue cells.  In the history of mathematical modeling, it is common for hypothetical entities, added to models to achieve particular effects, to be found later to correspond to physical entities.

\index{interstitial fluid}

The glucose model consists of two differential equations:
%
\[ \frac{dG}{dt} = -k_1 \left[ G(t) - G_b \right] - X(t) G(t)  \]
%
\[ \frac{dX}{dt} = k_3 \left[I(t) - I_b \right] - k_2 X(t) \]
%
where

\begin{itemize}

\item $G$ is the concentration of blood glucose as a function of time and $dG/dt$ is its rate of change.

\item $I$ is the concentration of insulin in the blood as a function of time, which is taken as an input into the model, based on measurements.

\item $G_b$ is the basal concentration of blood glucose and $I_b$ is the basal concentration of blood insulin, that is, the concentrations at equilibrium.  Both are constants estimated from measurements at the beginning or end of the test.

\item $X$ is the concentration of insulin in the tissue fluid as a function of time, and $dX/dt$ is its rate of change.

\item $k_1$, $k_2$, and $k_3$ are positive-valued parameters that control the rates of appearance and disappearance for glucose and insulin. 

\end{itemize}

We can interpret the terms in the equations one by one:

\begin{itemize}

\item $-k_1 \left[ G(t) - G_b \right]$ is the rate of glucose disappearance due to the effect of glucose itself.  When $G(t)$ is above basal level, $G_b$, this term is negative; when $G(t)$ is below basal level this term is positive.  So in the absence of insulin, this term tends to restore blood glucose to basal level.

\item $-X(t) G(t)$ models the interaction of glucose and insulin in tissue fluid, so the rate increases as either $X$ or $G$ increases.  This term does not require a rate parameter because the units of $X$ are unspecified; we can consider $X$ to be in whatever units would make the parameter of this term 1.

\item $k_3 \left[ I(t) - I_b \right]$ is the rate at which insulin diffuses between blood and tissue fluid.  When $I(t)$ is above basal level, insulin diffuses from the blood into the tissue fluid.  When $I(t)$ is below basal level, insulin diffuses from tissue to the blood.

\item $-k_2 X(t)$ is the rate of insulin disappearance in tissue fluid as it is consumed or broken down.

\end{itemize}

The initial state of the model is $X(0) = I_b$ and $G(0) = G_0$, where $G_0$ is a constant that represents the concentration of blood sugar immediately after the injection.  In theory we could estimate $G_0$ based on measurements, but in practice it takes time for the injected glucose to spread through the blood volume.  Since $G_0$ is not measurable, it is treated as a {\bf free parameter} of the model, which means that we are free to choose it to fit the data.

\index{free parameter}


\section{Data}

To develop and test the model, I use data from Pacini and Bergman\footnote{``MINMOD: A computer program to calculate insulin sensitivity and pancreatic responsivity from the frequently sampled intravenous glucose tolerance test", {\em Computer Methods and Programs in Biomedicine} 23: 113-122, 1986.}.  The dataset is in a file in the repository for this book, which we can read into a \py{DataFrame}:

\index{data}
\index{DataFrame object}

\begin{python}
data = pd.read_csv('data/glucose_insulin.csv',
                   index_col='time')
\end{python}

\py{data} has two columns: \py{glucose} is the concentration of blood glucose in \si{\milli\gram/\deci\liter}; \py{insulin} is concentration of insulin in the blood in \si{\micro U\per\milli\liter} (a medical ``unit", denoted \si{U}, is an amount defined by convention in context).  The index is time in \si{\minute}.

\index{concentration}

\begin{figure}
\centerline{\includegraphics[width=3.5in]{figs/chap08-fig01.pdf}}
\caption{Glucose and insulin concentrations measured by FSIGT.}
\label{chap08-fig01}
\end{figure}

Figure~\ref{chap08-fig01} shows glucose and insulin concentrations over \SI{182}{\minute} for a subject with normal insulin production and sensitivity.


\section{Interpolation}
\label{interpolate}

Before we are ready to implement the model, there's one problem we have to solve.  In the differential equations, $I$ is a function that can be evaluated at any time, $t$.  But in the \py{DataFrame}, we only have measurements at discrete times.  This is a job for interpolation!

\index{interpolation}

The \py{modsim} library provides a function named \py{interpolate}, which is a wrapper for the SciPy function \py{interp1d}.  It takes any kind of \py{Series} as a parameter, including \py{TimeSeries} and \py{SweepSeries}, and returns a function.  That's right, I said it returns a {\em function}.

\index{function!as return value}
\index{Series}
\index{interpolate}
\index{interp1d}
\index{SciPy}

So we can call \py{interpolate} like this:

\begin{python}
I = interpolate(data.insulin)
\end{python}

Then we can call the new function, \py{I}, like this:

\begin{python}
I(18)
\end{python}

The result is 31.66, which is a linear interpolation between the actual measurements at \py{t=16} and \py{t=19}.  We can also pass an array as an argument to \py{I}:

\begin{python}
ts = linrange(t_0, t_end, endpoint=True)
I(ts)
\end{python}

The result is an array of interpolated values for equally-spaced values of \py{t}.

\index{linrange}
\index{NumPy}

\py{interpolate} can take additional arguments, which it passes along to \py{interp1d}.  You can read about these options at \url{http://modsimpy.com/interp}.


\section{Implementation}
\label{glucose}

To get started, we'll assume that the parameters of the model are known.  We'll implement the model and use it to generate time series for \py{G} and \py{X}.  Then we'll see how to find the parameters that generate the series that best fits the data.

Taking advantage of estimates from prior work, we'll start with these values:

\begin{python}
params = Params(G0 = 290,
                k1 = 0.03,
                k2 = 0.02,
                k3 = 1e-05)
\end{python}

A \py{Params} object is similar to a \py{System} or \py{State} object; it is useful for holding a collection of parameters.

\index{State object}
\index{System object}

We can pass \py{params} and \py{data} to \py{make_system}:

\begin{python}
def make_system(params, data):
    G0, k1, k2, k3 = params
    
    Gb = data.glucose[0]
    Ib = data.insulin[0]
    
    t_0 = get_first_label(data)
    t_end = get_last_label(data)

    init = State(G=G0, X=0)
    
    return System(G0=G0, k1=k1, k2=k2, k3=k3,
                  init=init, Gb=Gb, Ib=Ib,
                  t_0=t_0, t_end=t_end, dt=2)
\end{python}

\py{make_system} uses the measurements at \py{t=0} as the basal levels, \py{Gb} and \py{Ib}.
It gets \py{t_0} and \py{t_end} from the data.
And it uses the parameter \py{G0} as the initial value for \py{G}.
Then it packs everything into a \py{System} object.

Here's the update function:

\index{update function}
\index{function!update}

\begin{python}
def update_func(state, t, system):
    G, X = state
    unpack(system)
        
    dGdt = -k1 * (G - Gb) - X*G
    dXdt = k3 * (I(t) - Ib) - k2 * X
    
    G += dGdt * dt
    X += dXdt * dt

    return State(G=G, X=X)
\end{python}

As usual, the update function takes a \py{State} object, a time, and a \py{System} object as parameters.  The first line \py{update} uses multiple assignment to extract the current values of \py{G} and \py{X}.  The second line uses \py{unpack} so we can read the system variables without using the dot operator.

\index{unpack}

Computing the derivatives \py{dGdt} and \py{dXdt} is straightforward; we just translate the equations from math notation to Python.

\index{derivative}

Then, to perform the update, we multiply each derivative by the discrete time step \py{dt}, which is \SI{2}{\minute} in this example.  The return value is a \py{State} object with the new values of \py{G} and \py{X}.

\index{time step}

Before running the simulation, it is a good idea to run the update function with the initial conditions:

\begin{python}
update_func(system.init, system.t_0, system)
\end{python}

Now we are ready to run the simulation.  We'll use this version of \py{run_simulation}, which is very similar to previous versions:

\index{\py{run_simulation}}

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t0] = init
    ts = linrange(t0, t_end, dt)
    
    for t in ts:
        frame.row[t+dt] = update_func(frame.row[t], t, system)
    
    return frame
\end{python}

We can run it like this:

\begin{python}
results = run_simulation(system, update_func)
\end{python}

\begin{figure}
\centerline{\includegraphics[width=3.5in]{figs/chap08-fig03.pdf}}
\caption{Results from simulation of the glucose minimal model.}
\label{chap08-fig03}
\end{figure}

The top plot in Figure~\ref{chap08-fig03} shows simulated glucose levels from the model along with the measured data.  The bottom plot shows simulated insulin levels in tissue fluid, which is in unspecified units, and not to be confused with measured insulin levels in the blood.

With the parameters I chose, the model fits the data well, but we can do better.

In the next chapter, we replace \py{run_simulation} with a better differential equation solver, then search for the parameters that yield the best fit for the data.

Before you go on, you might want to read the notebook for this chapter, \py{chap17.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.



\chapter{Numerical methods}
\label{chap18}

In the previous chapter, we implemented the glucose minimal model using \py{run_simulation}, which solves differential equations using discrete time steps.  This method works well enough for many applications, but it is not very accurate.  In this chapter we explore a better option: using an {\bf ODE solver}.

Then we use a search algorithm to find the model parameters that yield the best fit for the data.


\section{Solving differential equations}
\label{slopefunc}

So far we have solved differential equations by rewriting them as difference equations.  In the current example, the differential equations are:
%
\[ \frac{dG}{dt} = -k_1 \left[ G(t) - G_b \right] - X(t) G(t)  \]
%
\[ \frac{dX}{dt} = k_3 \left[I(t) - I_b \right] - k_2 X(t) \]
%
If we multiply both sides by $dt$, we have:
%
\[ dG = \left[ -k_1 \left[ G(t) - G_b \right] - X(t) G(t) \right] dt  \]
%
\[ dX = \left[ k_3 \left[I(t) - I_b \right] - k_2 X(t) \right] dt \]
%
When $dt$ is very small, or more precisely {\bf infinitesimal}, this equation is exact.  But in our simulations, $dt$ is \SI{2}{\minute}, which is small but not infinitesimal.  In effect, the simulations assume that the derivatives $dG/dt$ and $dX/dt$ are constant during each \SI{2}{\minute} time step.

\index{time step}

This method, evaluating derivatives at discrete time steps and assuming that they are constant in between, is called {\bf Euler's method} (see \url{http://modsimpy.com/euler}).

\index{Euler's method}

Euler's method is good enough for some simple problems, but there are many better ways to solve differential equations.  Rather than implement these methods ourselves, we will use functions from SciPy.  The \py{modsim} library provides a function called \py{run_ode_solver}, which uses the SciPy function \py{solve_ivp}.

\index{SciPy}

The ``ODE" in \py{run_ode_solver} stands for ``ordinary differential equation integrator".  The equations we are solving are ``ordinary'' because all the derivatives are with respect to the same variable; in other words, there are no partial derivatives.  

The ``IVP" in \py{solve_ivp} stands for ``initial value problem", which is the term for problems where you start with an initial value and figure out how the system changes over time, or sometimes space or another quantity.

\index{ordinary differential equation}
\index{initial value problem}

\py{solve_ivp} can use one of several ODE solvers; by default it uses a {\bf Runge-Kutta-Fehlberg method}.  These methods are {\bf adaptive}; that is, they choose the step size automatically, using small steps when necessary to limit errors, and large steps when possible to be efficient.

To use \py{run_ode_solver}, we have to provide a ``slope function", like this:

\index{slope function}
\index{function!slope}
\index{unpack}

\begin{python}
def slope_func(state, t, system):
    G, X = state
    unpack(system)
    
    dGdt = -k1 * (G - Gb) - X*G
    dXdt = k3 * (I(t) - Ib) - k2 * X
    
    return dGdt, dXdt
\end{python}

\py{slope_func} is similar to \py{update_func}; in fact, it takes the same parameters in the same order.  But \py{slope_func} is simpler, because all we have to do is compute the derivatives, that is, the slopes.  We don't have to do the updates; \py{run_ode_solver} does them for us.


\index{\py{run_ode_solver}}

Now we can call \py{run_ode_solver} like this:

\begin{python}
results, details = run_ode_solver(system, slope_func, 
                                  t_eval=data.index)
\end{python}

\py{run_ode_solver} is similar to \py{run_simulation}: it takes a \py{System} object and a slope function as parameters, and returns a \py{TimeFrame} as a result.  \py{results} has one row for each time step and one column for each state variable.  In this example, the rows are the values from \py{data.index}; the columns are the state variables, \py{G} and \py{X}.
 
\index{TimeFrame object}

\py{run_ode_solver} also returns \py{details}, which is a \py{ModSimSeries} with information about how the solver ran, including a success code, a diagnostic message, and other information.  A \py{ModSimSeries} is like a \py{System} or \py{State} object; it contains a set of variables and their values.

\index{ModSimSeries}

\py{run_ode_solver} takes an optional argument, \py{t_eval}, which indicates where we want to evaluate the solution.  In this case we want the results to have the same time steps as the data, so we can compare them easily. 

The results are similar to what we saw in Figure~\ref{chap08-fig03}.  The biggest relative difference is less than 1\%.


\section{Least squares}

So far we have been taking the parameters as given, but in general we don't have that luxury.  Normally we are given the data and we have to search for the parameters that yield a time series that best matches the data.

\index{fitting data}

We will do that now, in two steps:

\begin{enumerate}

\item First we'll define an {\bf error function} that takes a set of parameters, simulates the system with the given parameters, and computes the errors, that is, the differences between the simulation results and the data.

\index{error function}
\index{function~error}

\item Then we'll use \py{fit_leastsq}, to search for the parameters that minimize mean squared error (MSE).

\index{\py{fit_leastsq}}
\index{leastsq}
\index{mean squared error}
\index{MSE}

\end{enumerate}

When \py{fit_leastsq} runs, it calls \py{error_func} many times, each time with a different set of parameters, until it converges on the parameters that minimize MSE.

\index{\py{error_func}}

Here's the error function:

\begin{python}
def error_func(params, data):
    system = make_system(params, data)
    results, details = run_ode_solver(system, slope_func)
    errors = results.G - data.glucose
    return errors
\end{python}

\py{error_func} takes as parameters a \py{Params} object and a \py{DataFrame} containing the measurements.  It uses \py{make_system} to create a \py{System} object, and calls \py{run_ode_solver} using the same slope function we saw in Section~\ref{slopefunc}.

Then it computes the difference between the simulation results and the data.  Since \py{results.G} and \py{data.glucose} are both \py{Series} objects, \py{errors} is also a \py{Series}.

\index{Series}
\index{\py{run_ode_solver}}

Now, to do the actual minimization, we run \py{fit_leastsq}:

\begin{python}
best_params, details = fit_leastsq(error_func, params, data)
\end{python}

The first return value is a \py{Params} object with the parameters that yield the best fit for the data.  The second return value is a \py{ModSimSeries} object with more information.


\section{Interpreting parameters}

To see the results, we can pass \py{best_params} to \py{make_system} and then run the simulation:

\begin{python}
system = make_system(best_params, data)
results, details = run_ode_solver(system, slope_func,
                                  t_eval=data.index)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap08-fig04.pdf}}
\caption{Simulation of the glucose minimal model with parameters that minimize MSE.}
\label{chap08-fig04}
\end{figure}

Figure~\ref{chap08-fig04} shows the results.  The simulation matches the measurements well except during the first few minutes after the injection.  

But we don't expect the model to do well in this regime.

The problem is that the model is {\bf non-spatial}; that is, it does not take into account different concentrations in different parts of the body.  Instead, it assumes that the concentrations of glucose and insulin in blood, and insulin in tissue fluid, are the same throughout the body.  This way of representing the body is known among experts as the ``bag of blood" model.

\index{non-spatial model}
\index{bag of blood}

Immediately after injection, it takes time for the injected glucose to circulate.  During that time, we don't expect a non-spatial model to be accurate.  For this reason, we should not take the estimated value of \py{G0} too seriously; it is useful for fitting the model, but not meant to correspond to a physical, measurable quantity.

On the other hand, the other parameters are meaningful; in fact, they are the reason the model is useful.  Using the best-fit parameters, we can estimate two quantities of interest:

\index{glucose effectiveness}
\index{insulin sensitivity}

\begin{itemize}

\item ``Glucose effectiveness", $E$, which is the tendency of elevated glucose to cause depletion of glucose.  

\item ``Insulin sensitivity", $S$, which is the ability of elevated blood insulin to enhance glucose effectiveness.

\end{itemize}

Glucose effectiveness is defined as the change in $dG/dt$ as we vary $G$:
%
\[ E \equiv - \frac{\delta \dot{G}}{\delta G} \]
%
where $\dot{G}$ is shorthand for $dG/dt$.  Taking the derivative of $dG/dt$ with respect to $G$, we get
%
\[ E = k_1 + X \]
%
The {\bf glucose effectiveness index}, $S_G$, is the value of $E$ when blood insulin is near its basal level, $I_b$.  In that case, $X$ approaches 0 and $E$ approaches $k_1$.  So we can use the best-fit value of $k_1$ as an estimate of $S_G$.

\index{basal level}

Insulin sensitivity is defined as the change in $E$ as we vary $I$:
%
\[ S \equiv - \frac{\delta E}{\delta I} \]
%
The {\bf insulin sensitivity index}, $S_I$, is the value of $S$ when $E$ and $I$ are at steady state:
%
\[ S_I \equiv \frac{\delta E_{SS}}{\delta I_{SS}} \]
%
$E$ and $I$ are at steady state when $dG/dt$ and $dX/dt$ are 0, but we don't actually have to solve those equations to find $S_I$.  If we set $dX/dt = 0$ and solve for $X$, we find the relation:
%
\[ X_{SS} = \frac{k_3}{k_2} I_{SS} \]
%
And since $E = k_1 + X$, we have:
%
\[ S_I = \frac{\delta E_{SS}}{\delta I_{SS}} = \frac{\delta X_{SS}}{\delta I_{SS}} \]
%
Taking the derivative of $X_{SS}$ with respect to $I_{SS}$, we have:
%
\[ S_I = k_3 / k_2 \]
%
So if we find parameters that make the model fit the data, we can use $k_3 / k_2$ as an estimate of $S_I$.  

For the example data, the estimated values of $S_G$ and $S_I$ are $0.029$ and for $8.9 \times 10^{-4}$.  According to Pacini and Bergman, these values are within the normal range.

Before you go on, you might want to read the notebook for this chapter, \py{chap18.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.


\chapter{Case studies}
\label{chap19}

This chapter reviews the computational patterns we have seen so far and presents exercises where you can apply them.

\section{Computational tools}

In Chapter~\ref{chap11} we saw an update function that uses multiple assignment to unpack a \py{State} object and assign the state variables to local variables.

\begin{python}
def update_func(state, t, system):
    s, i, r = state

    infected = system.beta * i * s    
    recovered = system.gamma * i
    
    s -= infected
    i += infected - recovered
    r += recovered
    
    return State(S=s, I=i, R=r)
\end{python}

And in \py{run_simulation} we used multiple assignment again to assign state variables to a row in a \py{TimeFrame}:

\begin{python}
def run_simulation(system, update_func):
    frame = TimeFrame(columns=system.init.index)
    frame.row[system.t0] = system.init
    
    for t in linrange(system.t0, system.t_end):
        frame.row[t+1] = update_func(frame.row[t], system)
    
    return frame
\end{python}

In Chapter~\ref{chap12} we used the functions \py{max} and \py{idxmax} to compute metrics:

\begin{python}
largest_value = S.max()
time_of_largest_value = S.idxmax()
\end{python}

And we saw the logistic function, a general function which is useful for modeling relationships between variables, like the effectiveness of an intervention as a function of expenditure.

In Chapter~\ref{chap13} we saw the \py{unpack} function, which makes system variables available as if they were local variables.

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t0] = init
    
    for t in linrange(t0, t_end):
        frame.row[t+1] = update_func(frame.row[t], t, system)
    
    system.results = frame
\end{python}

One thing to remember when you use \py{unpack}: if you modify any of the unpacked variables, the change does not affect the \py{System} object.

In Chapter~\ref{chap14} we used a \py{SweepFrame} object to sweep two parameters.

\begin{python}
def sweep_parameters(beta_array, gamma_array):
    frame = SweepFrame(columns=gamma_array)
    for gamma in gamma_array:
        frame[gamma] = sweep_beta(beta_array, gamma)
    return frame
\end{python}

In Chapter~\ref{chap15} we used \py{linrange} to create an array of values with a given step size.  \py{linrange} is similar to \py{linspace}: the difference is that \py{linrange} lets you specify the space between values, and it computes the number of values; \py{linspace} lets you specify the number of values, and it computes the space between them.

Here's a version of \py{run_simulation} that uses \py{linrange}:

\begin{python}
def run_simulation(system, update_func):
    unpack(system)
    
    frame = TimeFrame(columns=init.index)
    frame.row[t_0] = init
    ts = linrange(t_0, t_end, dt)
    
    for t in ts:
        frame.row[t+dt] = update_func(frame.row[t], t, system)
        
    # store the final temperature in T_final
    system.T_final = get_last_value(frame.T)
    
    return frame
\end{python}

In Chapter~\ref{chap16} we used \py{fsolve} to find the value of a parameter that yields a particular result.  We defined an error function:

\index{\py{fsolve}}

\begin{python}
def error_func1(r):
    system = make_system(r=r)
    results = run_simulation(system, update)
    return system.T_final - 70
\end{python}

And passed it to \py{fsolve} with an initial guess, like this:

\begin{python}
solution = fsolve(error_func1, 0.01)
r_coffee = solution[0]
\end{python}

In Chapter~\ref{chap17} we used \py{interpolate}, which returns a function:

\begin{python}
I = interpolate(data.insulin)
\end{python}

which we can call like any other function, passing as an argument either a single value or a NumPy array:

\begin{python}
I(18)

ts = linrange(t_0, t_end)
I(ts)
\end{python}

We also used a \py{Params} object, which is a collection of parameters.

\begin{python}
params = Params(G0 = 290,
                k1 = 0.03,
                k2 = 0.02,
                k3 = 1e-05)
\end{python}

Chapter~\ref{chap18} introduces \py{run_ode_solver} which computes numerical solutions to differential equations.

\py{run_ode_solver} uses a slope function, which is similar to an update function:

\begin{python}
def slope_func(state, t, system):
    G, X = state
    unpack(system)
    
    dGdt = -k1 * (G - Gb) - X*G
    dXdt = k3 * (I(t) - Ib) - k2 * X
    
    return dGdt, dXdt
\end{python}

We used \py{run_ode_solver} to write an error function, which takes a \py{Params} object, runs a simulation, and returns the difference between the simulation results and the data:

\begin{python}
def error_func(params, data):
    system = make_system(params, data)
    results, details = run_ode_solver(system, slope_func, 
                                      t_eval=data.index)
    errors = results.G - data.glucose
    return errors
\end{python}

Then we passed the error function to \py{fit_leastsq}, which finds the set of parameters that minimizes the errors:

\begin{python}
best_params, fit_details = fit_leastsq(error_func, params, data)
\end{python}

%TODO: Anything to say here?


\section{Under the hood}

\py{unpack} is a function in the \py{modsim} library that copies the variables and values from a \py{System} object into a special Python data structure that stores global variables.  To be honest, it is a bit of a hack; that is, it may be expedient, but it might not be an example of software engineering you should emulate.

\py{fsolve} is based on a Scipy function that is also called \py{fsolve}; you can read more about it at \url{http://modsimpy.com/fsolve}.
It uses a numerical method called Powell's method, and you can read more about that at \url{http://modsimpy.com/powell}.

\index{\py{fsolve}}

\py{run_ode_solver} uses the SciPy function \py{solve_ivp}, which you can read about at \url{http://modsimpy.com/ivp}.
By default it uses an algorithm called RK45, or RKF45, which you can read about at \url{http://modsimpy.com/runge}).

\py{fit_leastsq} is based on the SciPy function \py{leastsq}; you can read about it at \url{http://modsimpy.com/sq}.
By default it uses a version of the Levenberg-Marquardt method, which you can read about at \url{http://modsimpy.com/lm }.

These SciPy functions don't work with the units provided by Pint, so the \py{modsim} library turns off unit-checking before calling them.  This mechanism is a bit of a hack, so you might get some unexpected behavior.  If so, I suggest you make a modest effort to fix them problem, but don't spend too much time on it.

Carrying units through computations like this is not as common as it should be, so the tools are not as polished as they could be.  I think it is worth trying, because you can catch a lot of errors by checking units; but if it gets to be too much trouble, you can always remove the units from the code.  In that case, you should add comments that document the units for all variables!

The rest of this chapter presents case studies you can use to practice what you have learned so far.


\section{The insulin minimal model}

Along with the glucose minimal model in Chapter~\ref{chap17}, Berman et al.~developed an insulin minimal model, in which the concentration of insulin, $I$, is governed by this differential equation:
%
\[ \frac{dI}{dt} = -k I(t) + \gamma \left[ G(t) - G_T \right] t \]
%
where

\begin{itemize}

\item $k$ is a parameter that controls the rate of insulin disappearance independent of blood glucose.   

\item $G(t)$ is the measured concentration of blood glucose at time $t$.

\item $G_T$ is the glucose threshold; when blood glucose is above this level, it triggers an increase in blood insulin. 

\item $\gamma$ is a parameter that controls the rate of increase (or decrease) in blood insulin when glucose is above (or below) $G_T$.

% TODO: explain why t is there

\end{itemize}

The initial condition is $I(0) = I_0$.  As in the glucose minimal model, we treat the initial condition as a parameter which we'll choose to fit the data.

\index{insulin minimal model}
\index{differential equation}

The parameters of this model can be used to estimate, $\phi_1$ and $\phi_2$, which are values that ``describe the sensitivity to glucose of the first and second phase pancreatic responsivity".  They are related to the parameters as follows:
%
\[ \phi_1 = \frac{I_{max} - I_b}{k (G_0 - G_b)}\]
%
\[ \phi_2 = \gamma \times 10^4 \]
%
where $I_{max}$ is the maximum measured insulin level, and $I_b$ and $G_b$ are the basal levels of insulin and glucose.

%TODO: Clarify whether G0 here is the parameter we estimated in the previous
% model, or the maximum observed value of G.

In the repository for this book, you will find a notebook, \py{insulin.ipynb}, which contains starter code for this case study.   Use it to implement the insulin model, find the parameters that best fit the data, and estimate these values.


\section{Low-Pass Filter}

The following circuit diagram\footnote{From \url{http://modsimpy.com/divider}} shows a low-pass filter built with one resistor and one capacitor.  

\centerline{\includegraphics[height=1.3in]{figs/RC_Divider.pdf}}

A ``filter" is a circuit takes a signal, $V_{in}$, as input and produces a signal, $V_{out}$, as output.  In this context, a ``signal" is a voltage that changes over time.

A filter is ``low-pass" if it allows low-frequency signals to pass from $V_{in}$ to $V_{out}$ unchanged, but it reduces the amplitude of high-frequency signals.

By applying the laws of circuit analysis, we can derive a differential equation that describes the behavior of this system.  By solving the differential equation, we can predict the effect of this circuit on any input signal.

Suppose we are given $V_{in}$ and $V_{out}$ at a particular instant in time.  By Ohm's law, which is a simple model of the behavior of resistors, the instantaneous current through the resistor is:
%
\[ I_R = (V_{in} - V_{out}) / R \]
%
where $R$ is resistance in ohms (\si{\ohm}).

Assuming that no current flows through the output of the circuit, Kirchhoff's current law implies that the current through the capacitor is:
%
\[ I_C = I_R \]
%
According to a simple model of the behavior of capacitors, current through the capacitor causes a change in the voltage across the capacitor:
%
\[ I_C = C \frac{d V_{out}}{dt} \]
%
where $C$ is capacitance in farads (\si{\farad}).  Combining these equations yields a differential equation for $V_{out}$:
%
\[ \frac{d V_{out}}{dt} = \frac{V_{in} - V_{out}}{R C} \]
%
In the repository for this book, you will find a notebook, \py{filter.ipynb}, which contains starter code for this case study.   Follow the instructions to simulate the low-pass filter for input signals like this:
%
\[ V_{in}(t) = A \cos (2 \pi f t) \]
%
where $A$ is the amplitude of the input signal, say \SI{5}{\volt}, and $f$ is the frequency of the signal in \si{\hertz}.

In the repository for this book, you will find a notebook, \py{filter.ipynb}, which contains starter code for this case study.  Read the notebook, run the code, and work on the exercises.



\section{Thermal behavior of a wall}

This case study is based on a paper by Gori, et~al\footnote{Gori, Marincioni, Biddulph, Elwell, ``Inferring the thermal resistance and effective thermal mass distribution of a wall from in situ measurements to characterise heat transfer at both the interior and exterior surfaces", {\it Energy and Buildings}, Volume 135, pages 398-409, \url{http://modsimpy.com/wall2}.
    
The authors put their paper under a Creative Commons license, and make their data available at \url{http://modsimpy.com/wall }.  I thank them for their commitment to open, reproducible science, which made this case study possible.} that models the thermal behavior of a brick wall, with the goal of understanding the ``performance gap between the expected energy use of buildings and their measured energy use".

The following figure shows the scenario and their model of the wall:

\vspace{0.1in}
\centerline{\includegraphics[height=1.3in]{figs/wall_model.pdf}}

On the interior and exterior surfaces of the wall, they measure temperature and heat flux over a period of three days.  They model the wall using two thermal masses connected to the surfaces, and to each other, by thermal resistors.

The primary methodology of the paper is a Bayesian method for inferring the parameters of the system (two thermal masses and three thermal resistances).

The primary result is a comparison of two models: the one shown here with two thermal masses, and a simpler model with only one thermal mass.  They find that the two-mass model is able to reproduce the measured fluxes substantially better.

For this case study we will implement their model and run it with the estimated parameters from the paper, and then use \py{fit_leastsq} to see if we can find parameters that yield lower errors.

In the repository for this book, you will find a notebook, \py{wall.ipynb} with the code and results for this case study.


\chapter{Projectiles}
\label{chap20}

So far the differential equations we've worked with have been {\bf first order}, which means they involve only first derivatives.   In this chapter, we turn our attention to second order ODEs, which can involve both first and second derivatives.  

\index{first order ODE}
\index{second order ODE}

We'll revisit the falling penny example from Chapter~\ref{chap01}, and use \py{odeint} to find the position and velocity of the penny as it falls, with and without air resistance.


\section{Newton's second law of motion}

First order ODEs can be written
%
\[ \frac{dy}{dx} = G(x, y) \]
%
where $G$ is some function of $x$ and $y$ (see \url{http://modsimpy.com/ode}).  Second order ODEs can be written
%
\[ \frac{d^2y}{dx^2} = H(x, y, \frac{dy}{dt}) \]
%
where $H$ is a function of $x$, $y$, and $dy/dx$.

In this chapter, we will work with one of the most famous and useful second order ODE, Newton's second law of motion:
%
\[ F = m a \]
%
where $F$ is a force or the total of a set of forces, $m$ is the mass of a moving object, and $a$ is its acceleration.

\index{Newton's second law of motion}
\index{differential equation}
\index{acceleration}
\index{velocity}
\index{position}

Newton's law might not look like a differential equation, until we realize that acceleration, $a$, is the second derivative of position, $y$, with respect to time, $t$.  With the substitution
%
\[ a = \frac{d^2y}{dt^2} \]
%
Newton's law can be written
%
\[ \frac{d^2y}{dt^2} = F / m \]
%
And that's definitely a second order ODE.  In general, $F$ can be a function of time, position, and velocity.

Of course, this ``law" is really a model, in the sense that it is a simplification of the real world.  Although it is often approximately true:

\begin{itemize}

\item It only applies if $m$ is constant.  If mass depends on time, position, or velocity, we have to use a more general form of Newton's law (see \url{http://modsimpy.com/varmass}).

\index{variable mass}

\item It is not a good model for very small things, which are better described by another model, quantum mechanics.

\index{quantum mechanics}

\item And it is not a good model for things moving very fast, which are better described by yet another model, relativistic mechanics.

\index{relativity}

\end{itemize}

However, for medium-sized things with constant mass, moving at medium-sized speeds, Newton's model is phenomenally useful.  If we can quantify the forces that act on such an object, we can predict how it will move.


\section{Dropping pennies}

As a first example, let's get back to the penny falling from the Empire State Building, which we considered in Section~\ref{penny}.  We will implement two models of this system: first without air resistance, then with.

\index{falling penny}
\index{air resistance}

Given that the Empire State Building is \SI{381}{\meter} high, and assuming that the penny is dropped with velocity zero, the initial conditions are:

\index{State object}

\begin{python}
init = State(y=381 * m, 
             v=0 * m/s)
\end{python}

where \py{y} is height above the sidewalk and \py{v} is velocity.  The units \py{m} and \py{s} are from the \py{UNITS} object provided by Pint:

\index{unit}
\index{Pint}

\begin{python}
m = UNITS.meter
s = UNITS.second
\end{python}

The only system parameter is the acceleration of gravity:

\begin{python}
g = 9.8 * m/s**2
\end{python}

In addition, we'll specify the duration of the simulation:

\begin{python}
t_end = 10 * s
\end{python}

We need a \py{System} object to contain the system parameters:

\index{System object}

\begin{python}
system = System(init=init, g=g, t_end=t_end)
\end{python}

Now we need a slope function, and here's where things get tricky.  As we have seen, \py{run_ode_solver} can solve systems of first order ODEs, but Newton's law is a second order ODE.  However, if we recognize that

\index{slope function}
\index{function!slope}

\begin{enumerate}

\item Velocity, $v$, is the derivative of position, $dy/dt$, and

\item Acceleration, $a$, is the derivative of velocity, $dv/dt$,

\end{enumerate}

we can rewrite Newton's law as a system of first order ODEs:
%
\[ \frac{dy}{dt} = v \]
%
\[ \frac{dv}{dt} = a \]
%
And we can translate those equations into a slope function:

\index{system of equations}
\index{unpack}

\begin{python}
def slope_func(state, t, system):
    y, v = state
    unpack(system)    

    dydt = v
    dvdt = -g
    
    return dydt, dvdt
\end{python}

The first parameter, \py{state}, contains the position and velocity of the penny.  The last parameter, \py{system}, contains the system parameter \py{g}, which is the magnitude of acceleration due to gravity.

\index{State object}

The second parameter, \py{t}, is time.  It is not used in this slope function because none of the factors of the model are time dependent (see Section~\ref{glucose}).  I include it anyway because this function will be called by \py{run_ode_solver}, which always provides the same arguments, whether they are needed or not.

\index{time dependent}

The rest of the function is a straightforward translation of the differential equations, with the substitution $a = -g$, which indicates that acceleration is due to gravity, in the direction of decreasing $y$.  \py{slope_func} returns a sequence containing the two derivatives.

Before calling \py{run_ode_solver}, it is a good idea to test the slope function with the initial conditions:

\begin{python}
dydt, dvdt = slope_func(init, 0, system)
\end{python}

The result is \SI{0}{\meter\per\second} for velocity and \SI{9.8}{\meter\per\second\squared} for acceleration.  Now we can call \py{run_ode_solver} like this:

\begin{python}
results, details = run_ode_solver(system, slope_func,
                                  max_step=0.5*s)
\end{python}

The optional argument \py{max_step} determines the largest step size \py{run_ode_solver} can use.  Specifying \py{max_step} makes the simulation take longer, but it makes the results look better when plotted.  It has little or no effect on accuracy.

\py{results} in a \py{TimeFrame} with two columns: \py{y} contains the height of the penny; \py{v} contains its velocity.
 
\index{TimeFrame object}
\index{\py{run_ode_solver}}

We can plot the results like this:

\begin{python}
def plot_position(results):
    plot(results.y)
    decorate(xlabel='Time (s)',
             ylabel='Position (m)')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap09-fig01.pdf}}
\caption{Height of the penny versus time, with no air resistance.}
\label{chap09-fig01}
\end{figure}

Figure~\ref{chap09-fig01} shows the result.  Since acceleration is constant, velocity increases linearly and position decreases quadratically; as a result, the height curve is a parabola.

\index{parabola}

The last value of \py{results.y} is \SI{-109}{\meter}, which means we ran the simulation too long.  One way to solve this problem is to use the results to estimate the time when the penny hits the sidewalk.

The \py{modsim} library provides \py{crossings}, which takes a \py{TimeSeries} and a value, and returns a sequence of times when the series passes through the value.  We can find the time when the height of the penny is \py{0} like this:

\begin{python}
t_crossings = crossings(results.y, 0)
\end{python}

The result is an array with a single value, \SI{8.818}{s}.  Now, we could run the simulation again with \py{t_end = 8.818}, but there's a better way.

\section{Events}
\label{events}

As an option, \py{run_ode_solver} can take an {\bf event function}, which detects an ``event", like the penny hitting the sidewalk, and ends the simulation.

Event functions take the same parameters as slope functions, \py{state}, \py{t}, and \py{system}.  They should return a value that passes through \py{0} when the event occurs.  Here's an event function that detects the penny hitting the sidewalk:

\begin{python}
def event_func(state, t, system):
    y, v = state
    return y
\end{python}

The return value is the height of the penny, \py{y}, which passes through \py{0} when the penny hits the sidewalk.

We pass the event function to \py{run_ode_solver} like this:

\begin{python}
results, details = run_ode_solver(system, slope_func,
                                  events=event_func)
\end{python}

\py{events} can also be a sequence of event functions, if there is more than one event that might occur.

\py{run_ode_solver} uses Brent's method to estimate the time of the event precisely (see \url{http://modsimpy.com/brent}).

Before you go on, you might want to read the notebook for this chapter, \py{chap20.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.




\chapter{Air resistance}
\label{chap21}

In the previous chapter we simulated a penny falling in a vacuum, that is, without air resistance.  But the computational framework we used is very general; it is easy to add additional forces, including drag.

In this chapter, I present a model of drag force and add it to the simulation.


\section{Drag force}
\label{drag}

As an object moves through a fluid, like air, the object applies force to the air and, in accordance with Newton's third law of motion, the air applies an equal and opposite force to the object (see \url{http://modsimpy.com/newton}).

\index{air resistance}
\index{drag force}
\index{force!drag}
\index{drag equation}

The direction of this {\bf drag force} is opposite the direction of travel, and its magnitude is given by the drag equation (see \url{http://modsimpy.com/drageq}):
%
\[ F_d = \frac{1}{2}~\rho~v^2~C_d~A \]
%
where

\begin{itemize}

\item $F_d$ is force due to drag, in newtons (\si{\newton}).

\item $\rho$ is the density of the fluid in \si{\kg\per\meter\cubed}.
\index{density}

\item $v$ is the magnitude of velocity in \si{\meter\per\second}.
\index{velocity}

\item $A$ is the {\bf reference area} of the object, in \si{\meter\squared}.  In this context, the reference area is the projected frontal area, that is, the visible area of the object as seen from a point on its line of travel (and far away).

\index{reference area}

\item $C_d$ is the {\bf drag coefficient}, a dimensionless quantity that depends on the shape of the object (including length but not frontal area), its surface properties, and how it interacts with the fluid.

\index{drag coefficient}

\end{itemize}

For objects moving at moderate speeds through air, typical drag coefficients are between 0.1 and 1.0, with blunt objects at the high end of the range and streamlined objects at the low end (see \url{http://modsimpy.com/dragco}).

For simple geometric objects we can sometimes guess the drag coefficient with reasonable accuracy; for more complex objects we usually have to take measurements and estimate $C_d$ from the data.

Of course, the drag equation is itself a model, based on the assumption that $C_d$ does not depend on the other terms in the equation: density, velocity, and area.  For objects moving in air at moderate speeds (below 45 mph or \SI{20}{\meter\per\second}), this model might be good enough, but we should remember to revisit this assumption.

For the falling penny, we can use measurements to estimate $C_d$.   In particular, we can measure {\bf terminal velocity}, $v_{term}$, which is the speed where drag force equals force due to gravity:
%
\[ \frac{1}{2}~\rho~v_{term}^2~C_d~A = m g \]
%
where $m$ is the mass of the object and $g$ is acceleration due to gravity.  Solving this equation for $C_d$ yields:
%
\[ C_d = \frac{2~m g}{\rho~v_{term}^2~A} \]
%
According to {\it Mythbusters}, the terminal velocity of a penny is between 35 and 65 mph (see \url{http://modsimpy.com/mythbust}).  Using the low end of their range, 40 mph or about \SI{18}{\meter\per\second}, the estimated value of $C_d$ is 0.44, which is close to the drag coefficient of a smooth sphere.

\index{Mythbusters}
\index{terminal velocity}

Now we are ready to add air resistance to the model.


\section{Implementation}
\label{penny_drag}

As the number of system parameters increases, and as we need to do more work to compute them, we will find it useful to define a \py{Params} object to contain the quantities we need to make a \py{System} object.  \py{Params} objects are similar to \py{System} and \py{State} objects; in fact, all three have the same capabilities.  I have given them different names to document the different roles they play.

\index{Params object}

Here's the \py{Params} object for the falling penny:

\begin{python}
params = Params(height = 381 * m,
                v_init = 0 * m / s,
                g = 9.8 * m/s**2,
                mass = 2.5e-3 * kg,
                diameter = 19e-3 * m,
                rho = 1.2 * kg/m**3,
                v_term = 18 * m / s)
\end{python}

The mass and diameter are from \url{http://modsimpy.com/penny}.  The density of air depends on temperature, barometric pressure (which depends on altitude), humidity, and composition (\url{http://modsimpy.com/density}).  I chose a value that might be typical in New York City at \SI{20}{\celsius}.

\index{System object}
\index{\py{make_system}}

Here's a version of \py{make_system} that takes a \py{Params} object and returns a \py{System}:

\index{unpack}

\begin{python}
def make_system(params):
    unpack(params)
    
    area = np.pi * (diameter/2)**2
    C_d = 2 * mass * g / (rho * area * v_term**2)
    init = State(y=height, v=v_init)
    t_end = 30 * s
    
    return System(params, area=area, C_d=C_d, 
                  init=init, t_end=t_end)
\end{python}

The first argument of \py{System} is \py{params}, so the result contains all of the parameters in \py{params}, plus \py{init}, \py{area}, and \py{C_d}.

It might not be obvious why we need \py{Params} objects, but they will turn out to be useful soon.

We can make a \py{System} like this:

\begin{python}
system = make_system(params)
\end{python}

Now here's a version of the slope function that includes drag:

\index{slope function}
\index{function!slope}
\index{unpack}

\begin{python}
def slope_func(state, t, system):
    y, v = state
    unpack(system)
    
    f_drag = rho * v**2 * C_d * area / 2
    a_drag = f_drag / mass
    
    dydt = v
    dvdt = -g + a_drag
    
    return dydt, dvdt
\end{python}

\py{f_drag} is force due to drag, based on the drag equation.  \py{a_drag} is acceleration due to drag, based on Newton's second law.

\index{gravity}

To compute total acceleration, we add accelerations due to gravity and drag. \py{g} is negated because it is in the direction of decreasing \py{y}, and \py{a_drag} is positive because it is in the direction of increasing \py{y}.  In the next chapter we will use \py{Vector} objects to keep track of the direction of forces and add them up in a less error-prone way.

To stop the simulation when the penny hits the sidewalk, we'll use the event function from Section~\ref{events}:

\begin{python}
def event_func(state, t, system):
    y, v = state
    return y
\end{python}

Now we can run the simulation like this:

\index{\py{run_ode_solver}}

\begin{python}
results, details = run_ode_solver(system, slope_func,
                       events=event_func, max_step=0.5*s)
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap09-fig02.pdf}}
\caption{Height of the penny versus time, with air resistance.}
\label{chap09-fig02}
\end{figure}

Figure~\ref{chap09-fig02} shows the result.  It only takes a few seconds for the penny to accelerate up to terminal velocity; after that, velocity is constant, so height as a function of time is a straight line.

\index{terminal velocity}

In the notebook for this chapter, you'll have a chance to extend this model.


\section{Bungee jumping}
\label{bungee}

Suppose you want to set the world record for the highest ``bungee dunk", which is a stunt in which a bungee jumper dunks a cookie in a cup of tea at the lowest point of a jump.  An example is shown in this video: \url{http://modsimpy.com/dunk}.

Since the record is \SI{70}{\meter}, let's design a jump for \SI{80}{\meter}.  We'll start with the following modeling assumptions:

\begin{itemize}

\item  Initially the bungee cord hangs from a crane with the attachment point \SI{80}{\meter} above a cup of tea.

\item Until the cord is fully extended, it applies no force to the jumper.  It turns out this might not be a good assumption; we will revisit it.

\item After the cord is fully extended, it obeys Hooke's Law; that is, it applies a force to the jumper proportional to the extension of the cord beyond its resting length.  See \url{http://modsimpy.com/hooke}. 

\item The mass of the jumper is \SI{75}{\kilogram}.

\item The jumper is subject to drag force, as in the previous model, so that their terminal velocity is \SI{60}{\meter \per \second}.

\end{itemize}

Our objective is to choose the length of the cord, \py{L}, and its spring constant, \py{k}, so that the jumper falls all the way to the tea cup, but no farther!

We'll start with the length of the bungee cord, \py{L} at \SI{25}{\meter} and spring constant, \py{k} at \SI{40}{\newton \per \meter}.  Here's a \py{Params} object with all of these parameters:

\begin{python}
params = Params(y_attach = 80 * m,
                v_init = 0 * m / s,
                g = 9.8 * m/s**2,
                mass = 75 * kg,
                area = 1 * m**2,
                rho = 1.2 * kg/m**3,
                v_term = 60 * m / s,
                L = 25 * m,
                k = 40 * N / m)
\end{python}

And here's a version of \py{make_system} that uses \py{v_term} to compute \py{C_d}:

\begin{python}
def make_system(params):
    unpack(params)
    
    C_d = 2 * mass * g / (rho * area * v_term**2)
    init = State(y=y_attach, v=v_init)
    t_end = 20 * s

    return System(params, C_d=C_d, 
                  init=init, t_end=t_end)
\end{python}

We can run it like this:

\begin{python}
system = make_system(params)
\end{python}

We need a function to compute spring force based on the altitude of the jumper, \py{y}:

\begin{python}
def spring_force(y, system):
    unpack(system)
    distance_fallen = y_attach - y
    if distance_fallen <= L:
        return 0 * N
    
    extension = distance_fallen - L
    f_spring = k * extension
    return f_spring
\end{python}

\py{distance_fallen} is the distance of the jumper from the attachment point.  If the cord is not fully extended, the spring force is 0.  Otherwise we compute the extension of the cord, \py{extension}, and the spring force, \py{f_spring}.

I'll also define a function to compute drag force:

\begin{python}
def drag_force(v, system):
    unpack(system)
    f_drag = -np.sign(v) * rho * v**2 * C_d * area / 2
    return f_drag
\end{python}

\py{drag_force} uses the NumPy function \py{sign}, which returns 1 if the argument is positive, -1 if it is negative, and 0 if it is 0.  This ensures that the drag force is always in the opposite direction of velocity.

\index{NumPy}
\index{sign}

Now here's the slope function:

\begin{python}
def slope_func(state, t, system):
    y, v = state
    unpack(system)
    
    a_drag = drag_force(v, system) / mass
    a_spring = spring_force(y, system) / mass
    dvdt = -g + a_drag + a_spring
    
    return v, dvdt
\end{python}

\py{slope_func} uses \py{spring_force} and \py{drag_force} to compute forces, then divides by \py{mass} to get accelerations.

We can run the simulation like this:

\begin{python}
ts = linspace(0, system.t_end, 301)
results, details = run_ode_solver(system, slope_func,
                                  max_step=0.3*s)
\end{python}

Again, I use \py{max_step} so the results look better when plotted.
Figure~\ref{chap09-fig03} shows the results.

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap09-fig03.pdf}}
\caption{Position and velocity of the bungee jumper.}
\label{chap09-fig03}
\end{figure}

We can find the altitude of the jumper at the lowest point like this:

\begin{python}
min(results.y)
\end{python}

For the parameters we chose, the jumper bottoms out at about \SI{5}{\meter}, so we need to increase \py{L} or decrease \py{k}.  In the notebook for this chapter, you'll have to a chance to find the best parameters for the bungee dunk.

\section{Getting acceleration}

In fact, there are many combinations of \py{L} or decrease \py{k} that would work.  We might want to find the combination that minimizes the peak acceleration of the jumper, providing the maximum time near the sidewalk to make the dunk.

To do that, we need to know the acceleration of the jumper over time.  Although we compute acceleration in the slope function, it is not included in the results.

It might be tempting to record the acceleration each time the slope function runs, but we should not do that.  The ODE solver calls the slope function many times with different values of \py{state} and \py{t}.  Because of the way the solver works, not all of the states and times are actually part of the solution.  So recording acceleration while the solver is running would not work.

Instead, we can use the computed velocities to estimate acceleration as a function of time.

The \py{modsim} library provides \py{gradient}, which uses NumPy to estimate the derivative of a \py{TimeSeries}.  Here's how it works:

\begin{python}
a = gradient(results.v)
\end{python}

In the notebook for this chapter, \py{chap21.ipynb}, you can finish this problem by finding the combination of \py{L} and \py{k} that allows the jumper to complete the bungee dunk while minimizing the acceleration they experience.  For instructions on downloading and running the code, see Section~\ref{code}.


\chapter{Projectiles in 2-D}
\label{chap22}

In the previous chapter we modeled objects moving in one dimension, with and without drag.  Now let's move on to two dimensions, and baseball!

In this chapter we model the flight of a baseball including the effect of air resistance.  In the next chapter we use this model to solve an optimization problem.


\section{Baseball}
\label{baseball}

To model the flight of a baseball, we have to make some modeling decisions.  To get started, we ignore any spin that might be on the ball, and the resulting Magnus force (see \url{http://modsimpy.com/magnus}).  Under this assumption, the ball travels in a vertical plane, so we'll run simulations in two dimensions, rather than three.

\index{Magnus force}

Air resistance has a substantial effect on most projectiles in air, so we will include a drag force.

\index{air resistance}

To model air resistance, we'll need the mass, frontal area, and drag coefficient of a baseball.  Mass and diameter are easy to find (see \url{http://modsimpy.com/baseball}).  Drag coefficient is only a little harder; according to {\it The Physics of Baseball}\footnote{Adair, {\it The Physics of Baseball}, Third Edition, Perennial, 2002}, the drag coefficient of a baseball is approximately 0.33 (with no units).

\index{drag coefficient}

However, this value {\em does} depend on velocity.  At low velocities it might be as high as 0.5, and at high velocities as low as 0.28.  Furthermore, the transition between these regimes typically happens exactly in the range of velocities we are interested in, between \SI{20}{\meter\per\second} and \SI{40}{\meter\per\second}.

Nevertheless, we'll start with a simple model where the drag coefficient does not depend on velocity; as an exercise at the end of this chapter, you will have a chance to implement a more detailed model and see what effect is has on the results.

But first we need a new computational tool, the \py{Vector} object.


\section{Vectors}

Now that we are working in two dimensions, we will find it useful to work with {\bf vector quantities}, that is, quantities that represent both a magnitude and a direction.  We will use vectors to represent positions, velocities, accelerations, and forces in two and three dimensions. 

\index{Vector object}
\index{array}
\index{NumPy}

The \py{modsim} library provides a \py{Vector} object that represents a vector quantity.  A \py{Vector} object is a like a NumPy array; it contains elements that represent the {\bf components} of the vector.  For example, in a \py{Vector} that represents a position in space, the components are the $x$ and $y$ coordinates (and a $z$ coordinate in 3-D).  A \py{Vector} object can also have units, like the quantities we've seen in previous chapters.  

\index{unit}

You can create a \py{Vector} by specifying its components.  The following \py{Vector} represents a point \SI{3}{\meter} to the right (or east) and \SI{4}{\meter} up (or north) from an implicit origin:

\index{component}

\begin{python}
A = Vector(3, 4) * m
\end{python}

You can access the components of a \py{Vector} by name using the dot operator, for example, \py{A.x} or \py{A.y}.  You can also access them by index using brackets, for example, \py{A[0]} or \py{A[1]}.

Similarly, you can get the magnitude and angle using the dot operator, \py{A.mag} and \py{A.angle}.  {\bf Magnitude} is the length of the vector: if the \py{Vector} represents position, magnitude is the distance from the origin; if it represents velocity, magnitude is speed, that is, how fast the object is moving, regardless of direction.

\index{angle}
\index{magnitude}

The {\bf angle} of a \py{Vector} is its direction, expressed as the angle in radians from the positive x-axis.  In the Cartesian plane, the angle \SI{0}{\radian} is due east, and the angle \SI{\pi}{\radian} is due west. 

\index{radian}

\py{Vector} objects support most mathematical operations, including addition and subtraction:

\begin{python}
B = Vector(1, 2) * m
A + B
A - B
\end{python}

For the definition and graphical interpretation of these operations, see \url{http://modsimpy.com/vecops}.

\index{vector operation}

When you add and subtract \py{Vector} objects, the \py{modsim} library uses NumPy and Pint to check that the operands have the same number of dimensions and units.  The notebook for this chapter shows examples for working with \py{Vector} objects.

\index{dimensions}

One note on working with angles: in mathematics, we almost always represent angle in radians, and most Python functions expect angles in radians.  But people often think more naturally in degrees.  It can be awkward, and error-prone, to use both units in the same program.  Fortunately, Pint makes it possible to represent angles using quantities with units.

\index{degree}

As an example, I'll get the \py{degree} unit from \py{UNITS}, and create a quantity that represents 45 degrees:

\begin{python}
degree = UNITS.degree
angle = 45 * degree
\end{python}

If we need to convert to radians we can use the \py{to} function
\index{\py{to}}

\begin{python}
radian = UNITS.radian
rads = angle.to(radian)
\end{python}

If you are given an angle and velocity, you can make a \py{Vector} using \py{pol2cart}, which converts from polar to Cartesian coordinates.  To demonstrate, I'll extract the angle and magnitude of \py{A}:

\index{pol2cart}

\begin{python}
mag = A.mag
angle = A.angle
\end{python}

And then make a new \py{Vector} with the same components:

\begin{python}
x, y = pol2cart(angle, mag)
Vector(x, y)
\end{python}

Another way to represent the direction of \py{A} is a {\bf unit vector}, which is a vector with magnitude 1 that points in the same direction as \py{A}.  You can compute a unit vector by dividing a vector by its magnitude:

\index{unit vector}
\index{hat function}

\begin{python}
A / A.mag
\end{python}

We can do the same thing using the \py{hat} function, so named because unit vectors are conventionally decorated with a hat, like this: $\hat{A}$.

\begin{python}
A.hat()
\end{python}

Now let's get back to the game.


\section{Simulating baseball flight}

Let's simulate the flight of a baseball that is batted from home plate at an angle of \SI{45}{\degree} and initial speed \SI{40}{\meter \per \second}.
Using the center of home plate as the origin, the x-axis is parallel to the ground; the y-axis is vertical.  The initial height is about \SI{1}{\meter}.

As in Section~\ref{penny_drag}, I'll create a \py{Params} object that contains the parameters of the system:

\index{Params object}

\begin{python}
params = Params(x = 0 * m, 
                y = 1 * m,
                g = 9.8 * m/s**2,
                mass = 145e-3 * kg,
                diameter = 73e-3 * m,
                rho = 1.2 * kg/m**3,
                C_d = 0.3,
                angle = 45 * degree,
                velocity = 40 * m / s,
                duration = 6 * s)
\end{python}

The mass, diameter, and drag coefficient of the baseball are from the sources in Section~\ref{baseball}.  The acceleration of gravity, \py{g}, is a well-known quantity, and the density of air, \py{rho}, is based on a temperature of \SI{20}{\celsius} at sea level (see \url{http://modsimpy.com/tempress}).
 I chose the value of \py{duration} to run the simulation long enough for the ball to land on the ground.

\index{density}

The following function uses the \py{Params} object to make a \py{System} object.  This two-step process makes the code more readable and makes it easier to work with functions like \py{fsolve}.

\index{System object}
\index{\py{make_system}}

\begin{python}
def make_system(condition):
    unpack(params)
    
    theta = np.deg2rad(angle)
    vx, vy = pol2cart(theta, velocity)
    init = State(x=x, y=y, vx=vx, vy=vy)
    area = np.pi * (diameter/2)**2
    
    return System(params, init=init, area=area)
\end{python}

\py{make_system} uses \py{np.deg2rad} to convert \py{angle} to radians and \py{pol2cart} to compute the $x$ and $y$ components of the initial velocity.  Then it makes the initial \py{State} object, computes \py{area}, and creates the \py{System} object, which contains all of the variables in \py{params} plus \py{init} and \py{area}.

\index{deg2rad}
\index{State object}

Next we need a function to compute drag force:

\begin{python}
def drag_force(v, system):
    unpack(system)
    mag = rho * v.mag**2 * C_d * area / 2
    direction = -v.hat()
    f_drag = direction * mag
    return f_drag
\end{python}

This function differs from the one in Section~\ref{bungee} because it takes \py{v} as a \py{Vector} and returns \py{f_drag} as a \py{Vector}.  It uses the drag equation to compute the magnitude of the drag force, and the \py{hat} function to compute the direction.  \py{-v.hat()} computes a unit vector pointing in the opposite direction of \py{v}.

\index{unit vector}
\index{slope function}
\index{function!slope}

Now we're ready for a slope function:

\begin{python}
def slope_func(state, t, system):
    x, y, vx, vy = state
    unpack(system)

    v = Vector(vx, vy)    
    a_drag = drag_force(v, system) / mass
    a_grav = Vector(0, -g)
    
    a = a_grav + a_drag
    
    return vx, vy, a.x, a.y
\end{python}

As usual, the parameters of the slope function are a \py{State} object, time, and a \py{System} object.  In this example, we don't use \py{t}, but we can't leave it out because when \py{run_ode_solver} calls the slope function, it always provides the same arguments, whether they are needed or not.

The \py{State} object contains four state variables: \py{x} and \py{y} are the components of position; \py{vx} and \py{vy} are the components of velocity.

\index{state variable}

The return values from the slope function are the derivatives of these components.  The derivative of position is velocity, so the first two return values are just \py{vx} and \py{vy}, the values we extracted from the \py{State} object.  The derivative of velocity is acceleration, and that's what we have to compute.

\index{acceleration}
\index{velocity}
\index{position}

The total acceleration of the baseball is the sum of accelerations due to gravity and drag.  These quantities have both magnitude and direction, so they are represented by vectors \py{Vector} objects.

We already saw how \py{a_drag} is computed.  \py{a_grav} is a \py{Vector} with magnitude \py{g} pointed in the negative \py{y} direction.

Using vectors to represent forces and accelerations makes the code concise, readable, and less error-prone.  In particular, when we add \py{a_grav} and \py{a_drag}, the directions are likely to be correct, because they are encoded in the \py{Vector} objects.  And the units are certain to be correct, because otherwise Pint would report an error.
\index{Pint}

As always, we can test the slope function by running it with the initial conditions:

\begin{python}
slope_func(system.init, 0, system)
\end{python}

We can use an event function to stop the simulation when the ball hits the ground.

\begin{python}
def event_func(state, t, system):
    x, y, vx, vy = state
    return y
\end{python}

The event function takes the same parameters as the slope function, and returns the y coordinate.  When the y coordinate passes through 0, the simulation stops.

Now we're ready to run the simulation:

\begin{python}
ts = linspace(0, system.t_end, 101)
results, details = run_ode_solver(system, slope_func,
                       events=event_func, max_step=0.2*s)
\end{python}

\py{results} is a \py{TimeFrame} object with one column for each of the state variables, \py{x}, \py{y}, \py{vx}, and \py{vy}.

\index{TimeFrame object}

We can get the flight time like this:

\begin{python}
flight_time = get_last_label(results) * s
\end{python}

And the final \py{x} coordinate like this:

\begin{python}
x_dist = get_last_value(results.x) * m
\end{python}

Notice that the results don't have units; if we want these values to have the correct units, we have to apply them.


\section{Trajectories}

We can plot the $x$ and $y$ components of position like this:

\begin{python}
plot(results.x, label='x')
plot(results.y, label='y')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap10-fig01.pdf}}
\caption{Simulated baseball flight, $x$ and $y$ components of position as a function of time.}
\label{chap10-fig01}
\end{figure}

Figure~\ref{chap10-fig01} shows the result.  As expected, the $x$ component increases monotonically, with decreasing velocity.  The $y$ position climbs initially and then descends, falling slightly below \SI{0}{\meter} after \SI{5.1}{\second}.

\index{monotonic}

Another way to view the same data is to plot the $x$ component on the x-axis and the $y$ component on the y-axis, so the plotted line follows the trajectory of the ball through the plane:

\begin{python}
plot(results.x, results.y, label='trajectory')
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap10-fig02.pdf}}
\caption{Simulated baseball flight, trajectory plot.}
\label{chap10-fig02}
\end{figure}

Figure~\ref{chap10-fig02} shows this way of visualizing the results, which is called a {\bf trajectory plot} (see \url{http://modsimpy.com/trajec}).

\index{trajectory plot}

A trajectory plot can be easier to interpret than a time series plot, because it shows what the motion of the projectile would look like (at least from one point of view).  Both plots can be useful, but don't get them mixed up!  If you are looking at a time series plot and interpreting it as a trajectory, you will be very confused.

Before you go on, you might want to read the notebook for this chapter, \py{chap22.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.


\chapter{Optimization}
\label{chap23}

In the previous chapter we developed a model of the flight of a baseball, including gravity and a simple version of drag, but neglecting spin, Magnus force, and the dependence of the coefficient of drag on velocity.

In this chapter we apply that model to an optimization problem.

\section{The Manny Ramirez problem}
\label{manny}

Manny Ramirez is a former member of the Boston Red Sox (an American baseball team) who was notorious for a relaxed attitude and a taste for practical jokes that his managers did not always appreciate.  Our objective in this chapter is to solve the following Manny-inspired problem:

{\it What is the minimum effort required to hit a home run in Fenway Park?}

Fenway Park is a baseball stadium in Boston, Massachusetts.  One of its most famous features is the ``Green Monster", which is a wall in left field that is unusually close to home plate, only 310 feet away.  To compensate for the short distance, the wall is unusually high, at 37 feet (see \url{http://modsimpy.com/wally}).

\index{Ramirez, Manny}
\index{Fenway Park}
\index{baseball}
\index{Green Monster}
\index{velocity}

We want to find the minimum velocity at which a ball can leave home plate and still go over the Green Monster.  We'll proceed in the following steps:

\begin{enumerate}

\item For a given velocity, we'll find the optimal {\bf launch angle}, that is, the angle the ball should leave home plate to maximize its height when it reaches the wall.

\index{launch angle}

\item Then we'll find the minimal velocity that clears the wall, given that it has the optimal launch angle.

\end{enumerate}

We'll use the same model as in the previous chapter, with this \py{Params} object:

\begin{python}
params = Params(x = 0 * m, 
                y = 1 * m,
                g = 9.8 * m/s**2,
                mass = 145e-3 * kg,
                diameter = 73e-3 * m,
                rho = 1.2 * kg/m**3,
                C_d = 0.3,
                angle = 45 * degree,
                velocity = 40 * m / s,
                t_end = 20 * s)
\end{python}
  
This version of \py{make_system}:

\begin{python}
def make_system(condition):
    unpack(params)
    
    theta = np.deg2rad(angle)
    vx, vy = pol2cart(theta, velocity)
    init = State(x=x, y=y, vx=vx, vy=vy)
    area = np.pi * (diameter/2)**2
    
    return System(params, init=init, area=area)
\end{python}
    
This slope function:

\begin{python}
def slope_func(state, t, system):
    x, y, vx, vy = state
    unpack(system)

    V = Vector(vx, vy)    
    a_drag = drag_force(V, system) / mass
    a_grav = Vector(0, -g)
    
    a = a_grav + a_drag
    
    return vx, vy, a.x, a.y
\end{python}

And this event function:

\begin{python}
def event_func(state, t, system):
    x, y, vx, vy = state
    return y
\end{python}


\section{Finding the range}

Suppose we want to find the launch angle that maximizes {\bf range}, that is, the distance the ball travels in the air before landing.   We'll use a function in the \py{modsim} library, \py{max_bounded}, which takes a function and finds its maximum.

The function we pass to \py{max_bounded} should take launch angle and a \py{params} object, and return range:

\begin{python}
def range_func(angle, params):  
    params = Params(params, angle=angle)
    system = make_system(params)
    results, details = run_ode_solver(system, slope_func, 
                                      events=event_func)
    x_dist = get_last_value(results.x) * m
    return x_dist
\end{python}

\py{range_func} makes a new \py{Params} object with the given value of \py{angle}.  Then it makes a \py{System} object, calls \py{run_ode_solver}, and returns the final value of \py{x} from the results.  

We can call \py{range_func} directly like this:

\begin{python}
range_func(45, params)
\end{python}

And we can sweep a sequence of angles like this:

\index{parameter sweep}
\index{SweepSeries object}

\begin{python}
angles = linspace(20, 80, 21)
sweep = SweepSeries()

for angle in angles:
    x_dist = range_func(angle, params)
    print(angle, x_dist)
    sweep[angle] = x_dist
\end{python}

\begin{figure}
\centerline{\includegraphics[height=3in]{figs/chap10-fig03.pdf}}
\caption{Distance from home plate as a function of launch angle, with fixed velocity.}
\label{chap10-fig03}
\end{figure}

Figure~\ref{chap10-fig03} shows the results.  It looks like the optimal angle is between \SI{40}{\degree} and \SI{45}{\degree}.

We can find the optimal angle more precisely and more efficiently using \py{max_bounded}, like this:

\begin{python}
res = max_bounded(range_func, [0, 90], params)
\end{python}

The first parameter is the function we want to maximize.  The second is the range of values we want to search; in this case it's the range of angles from \SI{0}{\degree} to \SI{90}{\degree}.  The third argument can be any object; it gets passed along as an argument when \py{max_bounded} calls \py{range_func}.

\index{Params object}

The return value from \py{max_bounded} is an \py{ModSimSeries} that contains the results, including \py{x}, which is the angle that yielded the highest range, and \py{fun}, which is the value of \py{range_func} when it's evaluated at \py{x}, that is, range when the baseball is launched at the optimal angle.

For these parameters, the optimal angle is \SI{41.1}{\degree}, which yields a range of \SI{103.4}{\meter}.

\index{ModSimSeries}




\section{Finishing off the problem}

In the notebook for this chapter, \py{chap22.ipynb}, you'll have to chance to finish off the Manny Ramirez problem.  There are a few things you'll have to do:

\begin{itemize}

\item In the previous section the ``optimal" launch angle is the one that maximizes range, but that's not what we want.  Rather, we want the angle that maximizes the height of the ball when it gets to the wall (310 feet from home plate).  So you'll have to write a height function to compute it, and then use \py{max_bounded} to find the revised optimum.

\item Once you can find the optimal angle for any velocity, you have to find the minimum velocity that gets the ball over the wall.  You'll write a function that takes a velocity as a parameter, computes the optimal angle for that velocity, and returns the height of the ball, at the wall, using the optimal angle.

\item Finally, you'll use \py{fsolve} to find the velocity that makes the optimal height at the wall just barely 37 feet.
  
\index{\py{fsolve}}

\end{itemize}

The notebook provides some additional hints, but at this point you should have everything you need.  Good luck!

If you enjoy this exercise, you might be interested in this paper: ``How to hit home runs: Optimum baseball bat swing parameters for maximum range trajectories", by Sawicki, Hubbard, and Stronge, at \url{http://modsimpy.com/runs}.


\chapter{Rotation}
\label{chap24}

In this chapter we model systems that involve rotating objects.  In general, rotation is complicated:  in three dimensions, objects can rotate around three axes; objects are often easier to spin around some axes than others; and they may be stable when spinning around some axes but not others.

\index{rotation}

If the configuration of an object changes over time, it might become easier or harder to spin, which explains the surprising dynamics of gymnasts, divers, ice skaters, etc.

And when you apply a twisting force to a rotating object, the effect is often contrary to intuition.  For an example, see this video on gyroscopic precession \url{http://modsimpy.com/precess}.

\index{gyroscopic precession}

In this chapter, we will not take on the physics of rotation in all its glory.  Rather, we will focus on simple scenarios where all rotation and all twisting forces are around a single axis.  In that case, we can treat some vector quantities as if they were scalars (in the same way that we sometimes treat velocity as a scalar with an implicit direction).

\index{scalar}

This approach makes it possible to simulate and analyze many interesting systems, but you will also encounter systems that would be better approached with the more general toolkit.

The fundamental ideas in this chapter and the next are {\bf angular velocity}, {\bf angular acceleration}, {\bf torque}, and {\bf moment of inertia}.  If you are not already familiar with these concepts, I will define them as we go along, and I will point to additional reading.

At the end of the next chapter, you will use these tools to simulate the behavior of a yo-yo (see \url{http://modsimpy.com/yoyo}).  But we'll work our way up to it gradually, starting with toilet paper.



\section{The physics of toilet paper}
\label{paper}

As a simple example of a system with rotation, we'll simulate the manufacture of a roll of toilet paper.  Starting with a cardboard tube at the center, we will roll up \SI{47}{\meter} of paper, the typical length of a roll of toilet paper in the U.S. (see \url{http://modsimpy.com/paper}).

\index{toilet paper}

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/paper_roll.pdf}}
\caption{Diagram of a roll of toilet paper, showing change in paper length as a result of a small rotation, $d\theta$.}
\label{paper_roll}
\end{figure}

Figure~\ref{paper_roll} shows a diagram of the system: $r$ represents the radius of the roll at a point in time.  Initially, $r$ is the radius of the cardboard core, $R_{min}$.  When the roll is complete, $r$ is $R_{max}$.

I'll use $\theta$ to represent the total rotation of the roll in radians.  In the diagram, $d\theta$ represents a small increase in $\theta$, which corresponds to a distance along the circumference of the roll of $r~d\theta$.

\index{radian}

Finally, I'll use $y$ to represent the total length of paper that's been rolled.  Initially, $\theta=0$ and $y=0$.  For each small increase in $\theta$, there is a corresponding increase in $y$:
%
\[ dy = r~d\theta \]
%
If we divide both sides by a small increase in time, $dt$, we get a differential equation for $y$ as a function of time.
%
\[ \frac{dy}{dt} = r \frac{d\theta}{dt} \]
%
As we roll up the paper, $r$ increases, too.  Assuming that $r$ increases by a fixed amount per revolution, we can write
%
\[ dr = k~d\theta \]
%
Where $k$ is an unknown constant we'll have to figure out.  Again, we can divide both sides by $dt$ to get a differential equation in time:
%
\[ \frac{dr}{dt} = k \frac{d\theta}{dt} \]
%
Finally, let's assume that $\theta$ increases at a constant rate of \SI{10}{\radian\per\second} (about 95 revolutions per minute):
%
\[ \frac{d\theta}{dt} = 10  \]
%
This rate of change is called an {\bf angular velocity}.  Now we have a system of three differential equations we can use to simulate the system.

\index{angular velocity}
\index{differential equation}


\section{Implementation}
\label{papersim}

At this point we have a pretty standard process for writing simulations like this.  First, we'll get the units we need from Pint:
\index{Pint}

\begin{python}
radian = UNITS.radian
m = UNITS.meter
s = UNITS.second
\end{python}

And create a \py{Params} object with the parameters of the system:

\index{Params object}

\begin{python}
params = Params(Rmin = 0.02 * m,
                Rmax = 0.055 * m,
                L = 47 * m,
                t_end = 130 * s)
\end{python}

\py{Rmin} and \py{Rmax} are the initial and final values for the radius, \py{r}.  \py{L} is the total length of the paper, and \py{t_end} is the length of the simulation in time.

Then we use the \py{Params} object to make a \py{System} object:

\index{System object}
\index{\py{make_system}}

\begin{python}
def make_system(params):
    unpack(params)
    
    init = State(theta = 0 * radian,
                 y = 0 * m,
                 r = Rmin)
    
    k = estimate_k(params)
    
    return System(init=init, k=k, t_end=t_end)
\end{python}

The initial state contains three variables, \py{theta}, \py{y}, and \py{r}.

\index{unpack}

To get started, we'll estimate a reasonable value for \py{k}; then in Section~\ref{paper_analysis} we'll figure it out exactly.  Here's how we compute the estimate:

\begin{python}
def estimate_k(params):
    unpack(params)
    
    Ravg = (Rmax + Rmin) / 2
    Cavg = 2 * pi * Ravg
    revs = L / Cavg
    rads = 2 * pi * revs
    k = (Rmax - Rmin) / rads
    return k
\end{python}

\py{Ravg} is the average radius, half way between \py{Rmin} and \py{Rmax}, so \py{Cavg} is the circumference of the roll when \py{r} is \py{Ravg}.

\py{revs} is the total number of revolutions it would take to roll up length \py{L} if \py{r} were constant at \py{Ravg}.  And \py{rads} is just \py{revs} converted to radians.

Finally, \py{k} is the change in \py{r} for each radian of revolution.  For these parameters, \py{k} is about \py{2.8e-5} \si{\meter\per\radian}.

Now we can use the differential equations from Section~\ref{paper} to write a slope function:

\index{slope function}
\index{Function!slope}

\begin{python}
def slope_func(state, t, system):
    theta, y, r = state
    unpack(system)
    
    omega = 10 * radian / s
    dydt = r * omega
    drdt = k * omega
    
    return omega, dydt, drdt
\end{python}

\begin{figure}[t]
\centerline{\includegraphics[height=4.5in]{figs/chap11-fig01.pdf}}
\caption{Results from paper rolling simulation, showing rotation, length, and radius over time.}
\label{chap11-fig01}
\end{figure}

As usual, the slope function takes a \py{State} object, a time, and a \py{System} object.  The \py{State} object contains hypothetical values of \py{theta}, \py{y}, and \py{r} at time \py{t}.  The job of the slope function is to compute the time derivatives of these values.  The time derivative of \py{theta} is angular velocity, which is often denoted \py{omega}.

\index{State object}

We'd like to stop the simulation when the length of paper on the roll is \py{L}.  We can do that with an event function that passes through 0 when \py{y} equals \py{L}:

\begin{python}
def event_func(state, t, system):
    theta, y, r = state
    unpack(system)
    return y - L
\end{python}

Now we can run the simulation like this:

\begin{python}
results, details = run_ode_solver(system, slope_func,
                       events=event_func, max_step=1*s)
\end{python}


Figure~\ref{chap11-fig01} shows the results.  \py{theta} grows linearly over time, as we should expect.  As a result, \py{r} also grows linearly.  But since the derivative of \py{y} depends on \py{r}, and \py{r} is increasing, \py{y} grows with increasing slope.

Because this system is so simple, it is almost silly to simulate it.  As we'll see in the next section, it is easy enough to solve the differential equations analytically.  But it is often useful to start with a simple simulation as a way of exploring and checking assumptions.

In order to get the simulation working, we have to get the units right, which can help catch conceptual errors early.  And by plugging in realistic parameters, we can detect errors that cause unrealistic results.  For example, in this system we can check:

\begin{itemize}

\item The total time for the simulation is about 2 minutes, which seems plausible for the time it would take to roll \SI{47}{\meter} of paper.

\item The final value of \py{theta} is about \SI{1250}{\radian}, which corresponds to about 200 revolutions, which also seems plausible.

\item The initial and final values for \py{r} are consistent with \py{Rmin} and \py{Rmax}, as we intended when we chose \py{k}.

\end{itemize}

But now that we have a working simulation, it is also useful to do some analysis.


\section{Analysis}
\label{paper_analysis}

The differential equations in Section~\ref{paper} are simple enough that we can just solve them.  Since angular velocity is constant:
%
\[ \frac{d\theta}{dt} = \omega  \]
%
We can find $\theta$ as a function of time by integrating both sides:
%
\[ \theta(t) = \omega t + C_1 \]
%
With the initial condition $\theta(0)=0$,  we find $C_1=0$.  Similarly,
%
\begin{equation}
\frac{dr}{dt} = k \omega                    \label{eqn1}
\end{equation}
%
So
%
\[ r(t) = k \omega t + C_2 \]
%
With the initial condition $r(0)=R_{min}$,  we find $C_2=R_{min}$.  Then we can plug the solution for $r$ into the equation for $y$:
%
\begin{align}
\frac{dy}{dt} & = r \omega                    \label{eqn2}   \\
              & = \left[ k \omega t + R_{min} \right] \omega \nonumber
\end{align}
%
%
Integrating both sides yields:
%
\[ y(t) = \left[ k \omega t^2 / 2 + R_{min} t \right] \omega + C_3\]
%
So $y$ is a parabola, as you might have guessed.  With initial condition $y(0)=0$, we find $C_3=0$.

\index{analysis}
\index{integration}

We can also use these equations to find the relationship between $y$ and $r$, independent of time, which we can use to compute $k$.  Using a move we saw in Section~\ref{contact}, I'll divide Equations~\ref{eqn1} and \ref{eqn2}, yielding
%
\[ \frac{dr}{dy} = \frac{k}{r}\]
%
Separating variables yields
%
\[ r~dr = k~dy\]
%
Integrating both sides yields
%
\[ r^2 / 2 = k y + C \]
%
When $y=0$, $r=R_{min}$, so
%
\[ C = \frac{1}{2} R_{min}^2 \]
%
Solving for $y$, we have
%
\begin{equation}
y = \frac{1}{2k} (r^2 - R_{min}^2)                 \label{eqn3}
\end{equation}
%
When $y=L$, $r=R_{max}$; substituting in those values yields
%
\[ L = \frac{1}{2k} (R_{max}^2 - R_{min}^2) \]
%
Solving for $k$ yields
%
\begin{equation}
k =  \frac{1}{2L} (R_{max}^2 - R_{min}^2)           \label{eqn4}
\end{equation}
%
Plugging in the values of the parameters yields \py{2.8e-5} \si{\meter\per\radian}, the same as the ``estimate" we computed in Section~\ref{papersim}.  In this case the estimate turns out to be exact.

In the next chapter, we'll run the simulation the other way, unrolling the paper.

Before you go on, you might want to read the notebook for this chapter, \py{chap24.ipynb}, and work on the exercises.  For instructions on downloading and running the code, see Section~\ref{code}.


\chapter{Torque}
\label{chap25}

In the previous chapter we modeled a scenario with constant angular velocity.  In this chapter we make it more complex; we'll model a teapot, on a turntable, revolving with constant angular acceleration and deceleration.


\section{Angular acceleration}

\index{angular acceleration}
\index{torque}

Just as linear acceleration is the derivative of velocity, {\bf angular acceleration} is the derivative of angular velocity.  And just as linear acceleration is caused by force, angular acceleration is caused by the rotational version of force, {\bf torque}.  If you are not familiar with torque, you can read about it at \url{http://modsimpy.com/torque}.

In general, torque is a vector quantity, defined as the {\bf cross product} of $\vec{r}$ and $\vec{F}$, where $\vec{r}$ is the {\bf lever arm}, a vector from the point of rotation to the point where the force is applied, and $\vec{F}$ is the vector that represents the magnitude and direction of the force.

\index{vector}
\index{lever arm}
\index{cross product}

However, for the problems in this chapter, we only need the {\em magnitude} of torque; we don't care about the direction.  In that case, we can compute
%
\[ \tau = r F \sin \theta \]
%
where $\tau$ is torque, $r$ is the length of the lever arm, $F$ is the magnitude of force, and $\theta$ is the angle between $\vec{r}$ and $\vec{F}$.  

\index{magnitude}

Since torque is the product of a length and a force, it is expressed in newton meters (\si{\newton\meter}).


\section{Moment of inertia}

In the same way that linear acceleration is related to force by Newton's second law of motion, $F=ma$, angular acceleration is related to torque by another form of Newton's law:
%
\[ \tau = I \alpha \]
%
Where $\alpha$ is angular acceleration and $I$ is {\bf moment of inertia}.  Just as mass is what makes it hard to accelerate an object\footnote{That might sound like a dumb way to describe mass, but its actually one of the fundamental definitions.}, moment of inertia is what makes it hard to spin an object.

\index{mass}
\index{moment of inertia}

In the most general case, a 3-D object rotating around an arbitrary axis, moment of inertia is a tensor, which is a function that takes a vector as a parameter and returns a vector as a result.

\index{tensor}

Fortunately, in a system where all rotation and torque happens around a single axis, we don't have to deal with the most general case.  We can treat moment of inertia as a scalar quantity.

\index{scalar}

For a small object with mass $m$, rotating around a point at distance $r$, the moment of inertia is $I = m r^2$, in SI units \si{\kilogram\meter\squared}.  For more complex objects, we can compute $I$ by dividing the object into small masses, computing moments of inertia for each mass, and adding them up.

However, for most simple shapes, people have already done the calculations; you can just look up the answers.  For example, see \url{http://modsimpy.com/moment}.


\section{Teapots and turntables}

Tables in Chinese restaurants often have a rotating tray or turntable
that makes it easy for customers to share dishes. These turntables are
supported by low-friction bearings that allow them to turn easily and
glide. However, they can be heavy, especially when they are loaded with
food, so they have a high moment of inertia.

\index{teapot}
\index{turntable}

Suppose I am sitting at a table with a pot of tea on the turntable
directly in front of me, and the person sitting directly opposite asks
me to pass the tea. I push on the edge of the turntable with \SI{1}{\newton} of force until it has turned \SI{0.5}{\radian}, then let go. The turntable glides until it comes to a stop \SI{1.5}{\radian} from the starting position. How much force should I apply for a second push so the teapot glides to a
stop directly opposite me?

\index{force}
\index{Newton}
\index{friction}

We'll answer this question in these steps:

\begin{enumerate}

\item
  I'll use the results from the first push to estimate the coefficient
  of friction for the turntable.

\item
  As an exercise, you'll use that coefficient of friction to estimate the force needed to rotate the turntable through the remaining angle.

\end{enumerate}

Our simulation will use the following parameters:

\begin{enumerate}
\item
  The radius of the turntable is \SI{0.5}{\meter}, and its weight is \SI{7}{\kg}.
\item
  The teapot weights \SI{0.3}{\kg}, and it sits \SI{0.4}{\meter} from the center of
  the turntable.
\end{enumerate}

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/teapot.pdf}}
\caption{Diagram of a turntable with a teapot.}
\label{teapot}
\end{figure}

Figure~\ref{teapot} shows the scenario, where $F$ is the force I apply to the turntable at the perimeter, perpendicular to the moment arm, $r$, and $\tau$ is the resulting torque. The blue circle near the bottom is the teapot.

Here's a \py{Params} object with these values

\begin{python}
params = Params(radius_disk=0.5*m,
                mass_disk=7*kg,
                radius_pot=0.4*m,
                mass_pot=0.3*kg,
                force=1*N,
                torque_friction=0.2*N*m,
                theta_end=0.5*radian)
\end{python}

\index{Params object}

\py{make_system} creates the initial state, \py{init}, and
computes the total moment of inertia for the turntable and the teapot.

\begin{python}
def make_system(params):
    unpack(params)
    
    init = State(theta=0, omega=0)
    
    I_disk = mass_disk * radius_disk**2 / 2
    I_pot = mass_pot * radius_pot**2
    
    return System(params, init=init, t_end=20*s,
                  I=I_disk+I_pot)
\end{python}

%\index{make_system}

\py{theta} represents the initial angle of the table, in \si{\radian}; \py{omega} represents the angular velocity in \si{\radian\per\second}.

\py{I_disk} is the moment of inertia of the turntable, which is based on the moment of inertia for a horizontal disk revolving around a vertical axis through its center:
%
\[ I_{disk} = m r^2 / 2 \]
%
\py{I_pot} is the moment of inertia of the teapot, which I treat as a point mass with:
%
\[ I_{point} = m r^2 \]
%
Now we can make a \py{System} object:

\begin{python}
system1 = make_system(params)
\end{python}

\index{System object}

Here's a slope that takes the current state, which contains angle and angular velocity, and returns the derivatives, angular velocity and angular acceleration:

\begin{python}
def slope_func(state, t, system):
    theta, omega = state
    unpack(system)
    
    torque = radius_disk * force - torque_friction
    alpha = torque / I
    
    return omega, alpha 
\end{python}

\index{slope function}

In this scenario, the force I apply to the turntable is always perpendicular to the lever arm, so $\sin \theta = 1$ and the torque due to force is $\tau = r F$.

In a more detailed model, I might quantify force due to friction and the moment arm of that force, but that's not really necessary; instead, I chose to quantify torque due to friction, leaving out the details.

\index{friction}

Now we are ready to run the simulation, but first there's a problem we have to address.

When I stop pushing on the turntable, the angular acceleration changes
abruptly. We could implement the slope function with an \py{if}
statement that checks the value of \py{theta} and sets
\py{force} accordingly. And for a coarse model like this one, that
might be fine. But we will get more accurate results if we simulate the
system in two phases:

\begin{enumerate}
\item
  During the first phase, force is constant, and we run until
  \py{theta} is 0.5 radians.
\item
  During the second phase, force is 0, and we run until \py{omega}
  is 0.
\end{enumerate}

Then we can combine the results of the two phases into a single
\py{TimeFrame}.

\index{two-phase simulation}

Here's the event function I'll use for Phase 1; it stops the simulation when \py{theta} reaches \py{theta_end}, which is when I stop pushing:

\begin{python}
def event_func1(state, t, system):
    theta, omega = state
    unpack(system)
    return theta - theta_end 
\end{python}

Now we can run the first phase.

\begin{python}
results1, details1 = run_ode_solver(system1, slope_func,
                         events=event_func1, max_step=0.1*s)
\end{python}

%\index{run_ode_solver}
%\index{max_step}

Again, I specify \py{max_step} so the results look smoother when I plot them, at the cost of some extra computation.

\begin{figure}
\centerline{\includegraphics[height=4.0in]{figs/chap25-fig01.pdf}}
\caption{Angle and angular velocity of a turntable with applied force and friction.}
\label{chap25-fig01}
\end{figure}

Before we run the second phase, we have to extract the final time and
state of the first phase.

\begin{python}
t_0 = get_last_label(results1) * s
theta, omega = get_last_value(results1)
init2 = State(theta=theta*radian, omega=omega*radian/s)
\end{python}

Now we can make a \py{System} object for Phase 2, with the initial state from Phase 1, and with \py{force=0}.

%\index{get_last_label}
%\index{get_last_value}

\begin{python}
system2 = System(system1, t_0=t_0, init=init2, force=0)
\end{python}

For the second phase, we need an event function that stops when the turntable stops; that is, when angular velocity is 0.

\begin{python}
def event_func2(state, t, system):
    theta, omega = state
    return omega
\end{python}

Now we can run the second phase.

\begin{python}
results2, details2 = run_ode_solver(system2, slope_func,
                         events=event_func2, max_step=0.1*s)
\end{python}

Pandas provides \py{combine_first}, which combines
\py{results1} and \py{results2}.

\index{Pandas}

\begin{python}
results = results1.combine_first(results2)
\end{python}

Figure~\ref{chap25-fig01} shows the results.  Angular velocity, \py{omega}, increases linearly while I am pushing, and decreases linearly after I let go.  The angle, \py{theta}, is the integral of angular velocity, so it forms a parabola during each phase.

In the next section, we'll use this simulation to estimate the torque due to friction.


\section{Estimating friction}

Let's take the code from the previous section and wrap it in a function.

\index{function}

\begin{python}
def run_two_phases(force, torque_friction, params):
    params = Params(params, force=force, 
                    torque_friction=torque_friction)

    # run phase 1
    system1 = make_system(params)
    results1, _ = run_ode_solver(system1, slope_func,
                      events=event_func1, max_step=0.1*s)

    # get the final state from phase 1
    t_0 = get_last_label(results1) * s
    theta, omega = get_last_value(results1)
    init2 = State(theta=theta, omega=omega)
    
    # run phase 2
    system2 = System(system1, t_0=t_0, init=init2, force=0)
    results2, _ = run_ode_solver(system2, slope_func,
                      events=event_func2, max_step=0.1*s)
    
    # combine and return the results
    results = results1.combine_first(results2)
    return results
\end{python}

Now we can use \py{run_two_phases} to write an error function we can use, with \py{fsolve}, to find the torque due to friction that yields the observed results from the first push, a total rotation of \SI{1.5}{\radian}.

\index{\py{fsolve}}
\index{error function}

\begin{python}
def error_func1(torque_friction, params):
    force = 1
    results = run_two_phases(force, torque_friction, params)
    theta_final = get_last_value(results.theta)
    print(torque_friction, theta_final)
    return theta_final - 1.5
\end{python}

But before we call \py{fsolve}, we have to deal with a problem.  In order to support computation with units, the \py{modsim} library uses a certain amount of black magic.  With most units, the magic works pretty well, but some units are problematic, including Newtons.

\index{\py{fsolve}}

However, now that we have a working simulation, and some confidence that it is correct, it is less important to carry units through the computation.

We can drop them by creating a new \py{Params} object with the same values and no units.  The \py{modsim} library provides \py{remove_unit}, which does just that.

\begin{python}
params_nodim = remove_units(params)
\end{python}

%\index{remove_units}

The rest of the code works without modification, in part because I designed it to keep almost all of the units in one place.

Now we can use \py{fsolve} to estimate torque due to friction.

\index{torque}
\index{friction}
\index{\py{fsolve}}

\begin{python}
guess = 0.2
res = fsolve(error_func1, guess, params_nodim)
\end{python}

The result is \SI{0.166}{\newton\meter}, a little less than the initial guess.

Now that we know the torque due to friction, we can compute the force needed to rotate the turntable through the remaining angle, that is, from \SI{1.5}{\radian} to \SI{3.14}{\radian}.

In the notebook for this chapter, \py{chap25.ipynb}, you will have a chance to finish off the exercise.  For instructions on downloading and running the code, see Section~\ref{code}.


\chapter{Case studies}
\label{chap26}

\section{Computational tools}

In Chapter~\ref{chap20} we rewrote a second order differential equation as a system of first order equations, and solved them using a slope function like this:

\begin{python}
def slope_func(state, t, system):
    y, v = state
    unpack(system)    

    dydt = v
    dvdt = -g
    
    return dydt, dvdt
\end{python}

We used the \py{crossings} function to search for zero-crossings in the simulation results.

Then we used an event function like this:

\begin{python}
def event_func(state, t, system):
    y, v = state
    return y
\end{python}

To stop the simulation when an event occurs.  Notice that the event function takes the same parameters as the slope function.

In Chapter~\ref{chap21} we developed a model of air resistance and used a  \py{Params} object, which is a collection of parameters:

\begin{python}
params = Params(height = 381 * m,
                v_init = 0 * m / s,
                g = 9.8 * m/s**2,
                mass = 2.5e-3 * kg,
                diameter = 19e-3 * m,
                rho = 1.2 * kg/m**3,
                v_term = 18 * m / s)
\end{python}

And we saw a new way to create a \py{System} object, copying the variables from a \py{Params} object and adding or changing variables:

\begin{python}
    return System(params, area=area, C_d=C_d, 
                  init=init, t_end=t_end)
\end{python}

We also used the \py{gradient} function to estimate acceleration, given velocity:

\begin{python}
a = gradient(results.v)
\end{python}

Chapter~\ref{chap22} introduces \py{Vector} objects, which can represent vector quantities, like position, velocity, force, and acceleration, in 2 or 3 dimensions.

\begin{python}
A = Vector(3, 4) * m
\end{python}

It also introduces trajectory plots, which show the path of an object in two dimensions:

\begin{python}
plot(results.x, results.y, label='trajectory')
\end{python}

In Chapter~\ref{chap23} we define a range function that computes the distance a baseball flies as a function of launch angle:

\begin{python}
def range_func(angle, params):  
    params = Params(params, angle=angle)
    system = make_system(params)
    results, details = run_ode_solver(system, slope_func, 
                                      events=event_func)
    x_dist = get_last_value(results.x) * m
    return x_dist
\end{python}

Then we use \py{max_bounded} to find the launch angle that maximizes range:

\begin{python}
res = max_bounded(range_func, [0, 90], params)
\end{python}

With that, your toolkit is complete.  Chapter~\ref{chap24} and Chapter~\ref{chap25} introduce the physics of rotation, but no new computational tools.


\section{Under the hood}

The \py{crossings} function uses \py{InterpolatedUnivariateSpline} from SciPy, which provides a \py{roots} function that finds zero-crossings.  It uses a cubic spline to interpolate between the time steps of the ODE solution.

\index{crossings}

The \py{Params} object is identical to the \py{System} object in all but name, and based on a Pandas \py{Series}.  I sometimes find it useful to use \py{Params} objects to create \py{System} objects, but it is not necessary.

\index{Params}

The \py{Vector} object is a \py{Quantity}, as defined by Pint, so it normally has units.  It contains a NumPy array that contains the coordinates.  So most vector arithmetic is really array arithmetic.

\index{Vector}

\py{max_bounded} uses the SciPy function \py{minimize_scalar}, which uses Brent's method.  You can read about it at \url{http://modsimpy.com/minimize}).

\index{\py{max_bounded}}
\index{SciPy}
\index{\py{minimize_scalar}}
\index{Brent's method}


\section{Bungee dunk revisited}

In Chapter~\ref{chap21}, we simulated a bungee jump with a model that took into account gravity, air resistance, and the spring force of the bungee cord, but we ignored the weight of the cord.

\index{bungee jump}
\index{bungee cord}

It is tempting to say that the cord has no effect because it falls along with the jumper, but that intuition is incorrect.  As the cord falls, it transfers energy to the jumper.

At \url{http://modsimpy.com/bungee} you'll find a paper\footnote{Heck, Uylings, and Kędzierska, ``Understanding the physics of bungee jumping", Physics Education, Volume 45, Number 1, 2010.} that explains this phenomenon and derives the acceleration of the jumper, $a$, as a function of position, $y$, and velocity, $v$:
%
\[ a = g + \frac{\mu v^2/2}{\mu(L+y) + 2L} \] 
%
where $g$ is acceleration due to gravity, $L$ is the length of the cord, and $\mu$ is the ratio of the mass of the cord, $m$, and the mass of the jumper, $M$.

If you don't believe that their model is correct, this video might convince you: \url{http://modsimpy.com/drop}.

Modify the code from Chapter~\ref{chap21} to model this effect.  How does the behavior of the system change as we vary the mass of the cord?  When the mass of the cord equals the mass of the jumper, what is the net effect on the lowest point in the jump?


\section{Spider-Man}

In this case study we'll develop a model of Spider-Man swinging from a
springy cable of webbing attached to the top of the Empire State
Building.  Initially, Spider-Man is at the top of a nearby building, as
shown in Figure~\ref{spiderman}.

\index{Spider-man}
\index{Empire State Building}

\begin{figure}
\centerline{\includegraphics[height=2.8in]{figs/spiderman.pdf}}
\caption{Diagram of the initial state for the Spider-Man case study.}
\label{spiderman}
\end{figure}

The origin, \texttt{O}, is at the base of the Empire State Building. The
vector \py{H} represents the position where the webbing is attached
to the building, relative to \py{O}. The vector \py{P} is the
position of Spider-Man relative to \py{O}. And \py{L} is the
vector from the attachment point to Spider-Man.

\index{vector}

By following the arrows from \py{O}, along \py{H}, and along
\py{L}, we can see that

\begin{code}
H + L = P
\end{code}

So we can compute \py{L} like this:

\begin{code}
L = P - H
\end{code}

The goals of this case study are:

\begin{enumerate}

\item
  Implement a model of this scenario to predict Spider-Man's trajectory.
\index{trajectory}

\item
  Choose the right time for Spider-Man to let go of the webbing in order
  to maximize the distance he travels before landing.
\index{range}

\item
  Choose the best angle for Spider-Man to jump off the building, and let
  go of the webbing, to maximize range.
\index{optimization}  
  
\end{enumerate}

We'll use the following parameters:
\index{parameter}

\begin{enumerate}

\item According to the Spider-Man Wiki\footnote{\url{http://modsimpy.com/spider}}, Spider-Man weighs \SI{76}{\kg}.

\item
  Let's assume his terminal velocity is \SI{60}{\meter\per\second}.
\index{terminal velocity}

\item
  The length of the web is \SI{100}{\meter}.

\item
  The initial angle of the web is \SI{45}{\degree} to the left of straight
  down.

\item
  The spring constant of the web is \SI{40}{\newton\per\meter} when the cord is stretched, and 0 when it's compressed.

\end{enumerate}

In the repository for this book, you will find a notebook, \py{spiderman.ipynb}, which contains starter code.   Read through the notebook and run the code.  It uses \py{minimize}, which is a SciPy function that can search for an optimal set of parameters (as contrasted with \py{min_bounded}, which can only search along a single axis).


\section{Kittens}

Let's simulate a kitten unrolling toilet paper.  As reference material, see this video: \url{http://modsimpy.com/kitten}.

\index{kitten}

The interactions of the kitten and the paper roll are complex.  To keep things simple, let's assume that the kitten pulls down on the free end of the roll with constant force.  Also, we will neglect the friction between the roll and the axle.  

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/kitten.pdf}}
\caption{Diagram of a roll of toilet paper, showing a force, lever arm, and the resulting torque.}
\label{kitten}
\end{figure}

Figure~\ref{kitten} shows the paper roll with $r$, $F$, and $\tau$.  As a vector quantity, the direction of $\tau$ is into the page, but we only care about its magnitude for now.

Here's the \py{Params} object with the parameters we'll need:

\index{Params object}

\begin{python}
params = Params(Rmin = 0.02 * m,
                Rmax = 0.055 * m,
                Mcore = 15e-3 * kg,
                Mroll = 215e-3 * kg,
                L = 47 * m,
                tension = 2e-4 * N,
                t_end = 180 * s)
\end{python}

As before, \py{Rmin} is the minimum radius and \py{Rmax} is the maximum.  \py{L} is the length of the paper.  \py{Mcore} is the mass of the cardboard tube at the center of the roll; \py{Mroll} is the mass of the paper.  \py{tension} is the force applied by the kitten, in \si{\newton}.  I chose a value that yields plausible results.

At \url{http://modsimpy.com/moment} you can find moments of inertia for simple geometric shapes.  I'll model the cardboard tube at the center of the roll as a ``thin cylindrical shell", and the paper roll as a ``thick-walled cylindrical tube with open ends".

\index{cylinder}

The moment of inertia for a thin shell is just $m r^2$, where $m$ is the mass and $r$ is the radius of the shell.

For a thick-walled tube the moment of inertia is
%
\[ I = \frac{\pi \rho h}{2} (r_2^4 - r_1^4) \]
%
where $\rho$ is the density of the material, $h$ is the height of the tube, $r_2$ is the outer diameter, and $r_1$ is the inner diameter.

Since the outer diameter changes as the kitten unrolls the paper, we have to compute the moment of inertia, at each point in time, as a function of the current radius, \py{r}.  Here's the function that does it:

\index{unpack}

\begin{python}
def moment_of_inertia(r, system):
    unpack(system)
    Icore = Mcore / 2 * Rmin**2
    Iroll = pi * rho_h / 2 * (r**4 - Rmin**4)
    return Icore + Iroll
\end{python}

\py{rho_h} is the product of density and height, $\rho h$, which is the mass per area.  \py{rho_h} is computed in \py{make_system}:

\index{density}
\index{\py{make_system}}

\begin{python}
def make_system(params):
    unpack(params)
    
    init = State(theta = 0 * radian,
                 omega = 0 * radian/s,
                 y = L)
    area = pi * (Rmax**2 - Rmin**2)
    rho_h = Mroll / area
    k = (Rmax**2 - Rmin**2) / 2 / L / radian    
    
    return System(init=init, k=k, rho_h=rho_h,
                  Rmin=Rmin, Rmax=Rmax,
                  Mcore=Mcore, Mroll=Mroll, 
                  t_end=t_end)
\end{python}

\py{make_system} also computes \py{k} using Equation~\ref{eqn4}.

In the repository for this book, you will find a notebook, \py{kitten.ipynb}, which contains starter code for this case study.   Use it to implement this model and check whether the results seem plausible.


\section{Simulating a yo-yo}

Suppose you are holding a yo-yo with a length of string wound around its axle, and you drop it while holding the end of the string stationary.  As gravity accelerates the yo-yo downward, tension in the string exerts a force upward.  Since this force acts on a point offset from the center of mass, it exerts a torque that causes the yo-yo to spin.

\index{yo-yo}
\index{torque}
\index{lever arm}

\begin{figure}
\centerline{\includegraphics[height=2.5in]{figs/yoyo.pdf}}
\caption{Diagram of a yo-yo showing forces due to gravity and tension in the string, the lever arm of tension, and the resulting torque.}
\label{yoyo}
\end{figure}

Figure~\ref{yoyo} is a diagram of the forces on the yo-yo and the resulting torque.  The outer shaded area shows the body of the yo-yo.  The inner shaded area shows the rolled up string, the radius of which changes as the yo-yo unrolls.

\index{system of equations}

In this model, we can't figure out the linear and angular acceleration independently; we have to solve a system of equations:
%
\begin{align*}
\sum F &= m a \\
\sum \tau &= I \alpha
\end{align*}
%
where the summations indicate that we are adding up forces and torques.

As in the previous examples, linear and angular velocity are related because of the way the string unrolls:
%
\[ \frac{dy}{dt} = -r \frac{d \theta}{dt} \]
%
In this example, the linear and angular accelerations have opposite sign.  As the yo-yo rotates counter-clockwise, $\theta$ increases and $y$, which is the length of the rolled part of the string, decreases.

Taking the derivative of both sides yields a similar relationship between linear and angular acceleration:
%
\[ \frac{d^2 y}{dt^2} = -r \frac{d^2 \theta}{dt^2} \]
%
Which we can write more concisely:
%
\[ a = -r \alpha \]
%
This relationship is not a general law of nature; it is specific to scenarios like this where there is rolling without stretching or slipping.

\index{rolling}

Because of the way we've set up the problem, $y$ actually has two meanings: it represents the length of the rolled string and the height of the yo-yo, which decreases as the yo-yo falls.  Similarly, $a$ represents acceleration in the length of the rolled string and the height of the yo-yo.

We can compute the acceleration of the yo-yo by adding up the linear forces:
%
\[ \sum F = T - mg = ma \]
%
Where $T$ is positive because the tension force points up, and $mg$ is negative because gravity points down.

Because gravity acts on the center of mass, it creates no torque, so the only torque is due to tension:
%
\[ \sum \tau = T r = I \alpha \]
%
Positive (upward) tension yields positive (counter-clockwise) angular acceleration.

\index{SymPy}

Now we have three equations in three unknowns, $T$, $a$, and $\alpha$, with $I$, $m$, $g$, and $r$ as known quantities.  It is simple enough to solve these equations by hand, but we can also get SymPy to do it for us:

\begin{python}
T, a, alpha, I, m, g, r = symbols('T a alpha I m g r')
eq1 = Eq(a, -r * alpha)
eq2 = Eq(T - m*g, m * a)
eq3 = Eq(T * r, I * alpha)
soln = solve([eq1, eq2, eq3], [T, a, alpha])
\end{python}

The results are
%
\begin{align*}
T      &= m g I / I^*   \\
a      &= -m g r^2 / I^* \\
\alpha &= m g r / I^*    \\
\end{align*}
%
where $I^*$ is the augmented moment of inertia, $I + m r^2$.
To simulate the system, we don't really need $T$; we can plug $a$ and $\alpha$ directly into the slope function.

In the repository for this book, you will find a notebook, \py{yoyo.ipynb}, which contains the derivation of these equations and starter code for this case study.   Use it to implement and test this model.


%\section{Rigid pendulum}

%\section{LRC circuit}

% Pendulum:

% Springy pendulum

% Stiff problem as k increases

% Add drag

% Rigid pendulum: solve those constraints

% Generalized coordinates


\backmatter
\printindex

\afterpage{\blankpage}


\end{document}

\end{itemize}


\section{Under the hood}

Throughout this book, we'll use functions defined in the \py{modsim} library.  You don't have to know how they work, but you might be curious.  So at the end of some chapters I'll provide additional information.  If you are an experienced programmer, you might be interested by the design decisions I made.  If you are a beginner, and you feel like you have your hands full already, feel free to skip these sections.

\index{modsim}

Most of the functions in \py{modsim} are based on other Python libraries; the libraries we have used so far include:

\begin{itemize}

\item {\bf Pint}, which provides units like meters and seconds, as we saw in Section~\ref{penny}.

\item {\bf NumPy}, which provides mathematical operations like \py{sqrt}, which we saw in Section~\ref{computation}.

\item {\bf Pandas}, which provides the \py{Series} object, which is the basis of the \py{State} object in Section~\ref{modeling}.

\item {\bf Pyplot}, which provides plotting functions, as we saw in Section~\ref{plotting}.

\end{itemize}

You could use these libraries directly, and when you have more experience, you probably will.  But the functions in \py{modsim} are meant to be easier to use; they provide some additional capabilities, including error checking; and by hiding details you don't need to know about, they let you focus on more important things.

However, there are drawbacks.  One is that it can be hard to understand the error messages.  I'll have more to say about this in later chapters, but for now I have a suggestion.  When you are getting started, you should practice making errors.

\index{debugging}

For each new function you learn, you should deliberately make as many mistakes as possible so you can see what happens.  When you see what the errors messages are, you will understand what they mean.  And that should help later, when you make errors accidentally.


